<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>插入排序</title>
    <url>/2019/12/01/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="插入排序的原理"><a href="#插入排序的原理" class="headerlink" title="插入排序的原理"></a>插入排序的原理</h2><p>插入排序其实就像是我们平时玩扑克牌时的取牌操作，初始时我们手中没有任何牌，拿到第一张牌之后自然就不用做任何的移动操作。接着我们继续拿到牌，将每次新拿到的牌跟前面（已排序）的牌依次进行对比，然后将之放到正确的位置上。</p>
<a id="more"></a>
<h2 id="插入排序的实现（C"><a href="#插入排序的实现（C" class="headerlink" title="插入排序的实现（C++)"></a>插入排序的实现（C++)</h2><p>按照原理我们首先实现直接插入排序（直插法）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;直插法</span></pre></td></tr><tr><td class="code"><pre><span class="line">void insertSort(int arr[], int n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;	&#x2F;&#x2F;假设我们手中已经有第一张牌</span></pre></td></tr><tr><td class="code"><pre><span class="line">	for (int j &#x3D; 1; j &lt; n; ++j)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">		int key &#x3D;arr[j];	&#x2F;&#x2F;保留新拿到的牌值</span></pre></td></tr><tr><td class="code"><pre><span class="line">		int i &#x3D; j - 1;		&#x2F;&#x2F;新牌前面待对比的牌下标</span></pre></td></tr><tr><td class="code"><pre><span class="line">		while(key&lt;arr[i]&amp;&amp;i&gt;&#x3D;0)	</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;		&#x2F;&#x2F;当key小时不断对前面比它大的元素往后移动</span></pre></td></tr><tr><td class="code"><pre><span class="line">			arr[i+1] &#x3D; arr[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">			--i;		&#x2F;&#x2F;然后继续循环对比前面一个元素</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;		&#x2F;&#x2F;当i的元素值大于key或i&#x3D;-1时退出循环</span></pre></td></tr><tr><td class="code"><pre><span class="line">		arr[i+1] &#x3D; key;		&#x2F;&#x2F;最后i+1即为该新牌的位置下标</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>最好情况：数组已经有序，此时只需要进行n-1次比较，时间复杂度为O（n）;</p>
<p>最坏情况是数组逆序排序，此时需要进行n(n-1)/2次比较以及n-1次赋值操作（插入）；</p>
<p>平均来说插入排序算法的复杂度为O(n^2)。</p>
<p>直接插入排序采用就地排序（in-place)，空间复杂度为O（1）</p>
<h3 id="插入排序使用时机"><a href="#插入排序使用时机" class="headerlink" title="插入排序使用时机"></a>插入排序使用时机</h3><p>不适合对大量数据进行排序应用，但排序数量级小于1000时插入排序的效率还不错，可以考虑使用。</p>
<h2 id="二分法插入排序"><a href="#二分法插入排序" class="headerlink" title="二分法插入排序"></a>二分法插入排序</h2><p>直插法每次都是将新牌的值与前面的序列元素依次对比，那么我们能不能更快地确定新牌的位置呢？<br>答案当然是有的，由于我们当前手中的牌都是已经牌好序的，那么我们就可以通过直接跟当前牌最中间的牌值进行比较，然后就可以进一步确定牌的位置</p>
<h3 id="二分插入法的实现（C-）"><a href="#二分插入法的实现（C-）" class="headerlink" title="二分插入法的实现（C++）"></a>二分插入法的实现（C++）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二插法找到该新牌的位置</span></pre></td></tr><tr><td class="code"><pre><span class="line">int BinarySearch(int array[], int start, int end, int key)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    while (start &lt;&#x3D; end)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        int middle &#x3D; (start + end) &#x2F; 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        int middleData &#x3D; array[middle];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (middleData &gt; key)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            end &#x3D; middle - 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        else</span></pre></td></tr><tr><td class="code"><pre><span class="line">            start &#x3D; middle + 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return start;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;总的实现函数，找到位置后进行元素移动</span></pre></td></tr><tr><td class="code"><pre><span class="line">void BinaryInsertSort(int array[], int n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;		判断数组是否需要排序</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (array &#x3D;&#x3D; NULL || n &lt; 0)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int i, j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (i &#x3D; 1; i &lt; n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;		&#x2F;&#x2F;确认该新牌需要移动</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (array[i]&lt;array[i - 1])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            int temp &#x3D; array[i];	&#x2F;&#x2F;提前保存新牌的值</span></pre></td></tr><tr><td class="code"><pre><span class="line">            int insertIndex &#x3D; BinarySearch(array,0,i,array[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            for (j &#x3D; i - 1; j&gt;&#x3D;insertIndex; j--) &#x2F;&#x2F;将比新牌值大的元素后移</span></pre></td></tr><tr><td class="code"><pre><span class="line">                array[j + 1] &#x3D; array[j];        </span></pre></td></tr><tr><td class="code"><pre><span class="line">            array[insertIndex] &#x3D; temp;    &#x2F;&#x2F;最后插入元素</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>这个二分查找的算法并不会因为等于某一个值而停止查找，它将查找整个序列直到start&lt;=end条件不满足而得到插入的位置，所以对于长度为n的数组来说，比较次数为log2n ,时间复杂度为O（log2n）。二分插入排序的主要操作为比较+后移赋值，则：<br>最坏情况：每次都在有序序列的起始位置插入，则整个有序序列的元素需要后移，时间复杂度为O（n^2）</p>
<p>最好情况：待排序数组本身就是正序的，每个元素所在位置即为它的插入位置，此时时间复杂度仅为比较时的时间复杂度，为O(log2n)</p>
<p>平均情况：O（n^2）</p>
<p>空间复杂度上， 二分插入排序也是就地排序算法，它的空间复杂度为O（1）.</p>
]]></content>
      <categories>
        <category>-算法 -排序算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>暗夜--撕裂</title>
    <url>/2019/11/29/%E6%9A%97%E5%A4%9C--%E6%92%95%E8%A3%82/</url>
    <content><![CDATA[<h2 id="欢迎来到我的博客"><a href="#欢迎来到我的博客" class="headerlink" title="欢迎来到我的博客"></a>欢迎来到我的博客</h2><h3 id="搭建这个网站的初衷"><a href="#搭建这个网站的初衷" class="headerlink" title="搭建这个网站的初衷"></a>搭建这个网站的初衷</h3><p>作为一个半路出家（终于回到正轨）的伪程序员来说，找工作是一大难关，然后我就考虑到找工作时设计简历的问题，看到网上的大神说简历上附上自己的博客和github比较好，所以我就猛的一脚踹开了博客大门。</p>
<a id="more"></a>
<h3 id="为什么要自己搭建博客"><a href="#为什么要自己搭建博客" class="headerlink" title="为什么要自己搭建博客"></a>为什么要自己搭建博客</h3><p>其实这是挺奇怪的事情，我没有用CSDN，也没有用其他的博客，但是偶然看到网上教人搭建博客的视频，一时心血来潮就动起手来了，这两天的时间什么事情都没干就在搞这个。其实框架倒是挺好搭建的，就是配置的优化实在是不好搞（主要还是因为我没学过前端吧哈哈）。</p>
<p>像是网站的小图标我就搞了一小时，结果才知道要部署到Github上才会显示网站图标，气摔！之前还出了一个发布不了文章的Bug，但是我搞很久都没搞定就直接全部重头开始了。还有今天才解决的显示页面的问题，网上看了很多大神的博客都没解决，到群上问，各大神也都不知道怎么搞。结果一个比我还弱鸡的人让换个编辑器试试，我抱着大不了重头开始的想法试了一下，最后居然解决了哈哈哈哈哈。</p>
<p>感谢群里的各位大神和弱鸡。</p>
<p>这个网站大概就这模样了，其他的我就不搞了，不搞版权也不搞赞赏，评论我也不搞，可能后面会优化一下搜索引擎吧。</p>
<h3 id="我会发布什么内容"><a href="#我会发布什么内容" class="headerlink" title="我会发布什么内容"></a>我会发布什么内容</h3><p>之前我是用oneNote记录的，里面有很多基础的东西，其他的也都是网上可以搜到的，感觉好像就没什么再PO到网上的必要。但是后面会进行精简吧，在复习的过程中我会把一些（对我来说）比较难的点PO上来，或者利用这个网站重新系统化自己学过的东西。</p>
<p>当然，也不排除情绪低落的时候跑到这里发Sao的可能，毕竟对生活的记录也是很重要的嘛。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>希望每个进来这里的人能够找到需要的答案<br>希望所有夜里挣扎的人都能找到自己的方向</p>
<p>谢谢。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>

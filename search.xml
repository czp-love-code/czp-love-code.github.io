<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>静态库和动态库</title>
    <url>//articles/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93.html</url>
    <content><![CDATA[<p>制作静态库：（Linux下是libxxx.a文件，共享库是.so结尾）<br>1、编译为.o文件<br>2、打包.o文件：ar rcs libmycalc.a file1.o file2.o……<br>3、需要将头文件和库一起发布<br>编译时需要加静态库名</p>
<a id="more"></a>
<p>优点：执行快，发布应用时不需要发布库<br>缺点：执行程序体积会比较大，库变更时需要重新编译应用</p>
<p>32位系统的最大寻址范围是4G</p>
<p>制作动态库：<br>1、编译与位置无关的代码，生成.o文件，关键参数：-fPIC(大写i)<br>2、将.o文件打包：-shared<br>3、将库和头文件一起发布</p>
<p>注意：<br>使用静态库是直接将代码加进代码区<br>而使用的动态库临时加载进栈和堆之间，用完即释放，比如使用库里的add函数，就临时加载进去，因为是临时加载，所以不确定是哪个地址，就不能直接与位置绑定。因此要编译成与位置无关的代码，也就是说我们知道自己所使用函数在库中的相对位置就可以了。使用时首先知道库名，然后知道使用的函数在库中的偏移，进行定位，这样才能使用这个函数<br>eg: gcc -shared -o libcalc.so a.c b.c<br>使用动态库生成的程序比使用静态库生成的程序小，因为是使用时才临时加进去的，一般动态库变更不需要重新编译，除非接口修改了</p>
<p>举例：运行a.out时，首先检查内存中是否有相同的库代码在运行，如果有，则计算出正确的逻辑地址以备使用；否则先确定逻辑地址，再载入代码到内存中。</p>
<p>根据载入程序何时确定动态库代码的逻辑地址，可分为：<br>1静态绑定<br>程序一载入内存就把动态代码地址算出，这样程序刚运行时初始化时间较长，但一旦完成动态装载，程序运行就很快。<br>2动态绑定<br>在程序真正调用动态库中代码时才计算相关逻辑地址，故初始化时间较短，但运行性能不如静态绑定。</p>
<p>可以用ldd命令检查程序链接情况，程序执行时可能会出现.so文件not found<br>可以使用软链接：ln -s /lib/a.so(绝对路径) /lib/a.so，也可以将库路径添加到环境变量LD_LIBRARY_PATH中<br>export LD_LIBRARY_PATH=/home/czp/……/lib/（绝对路径）:$LD_LIBRARY_PATH<br>还可以进/etc/ld.so.conf进行设置：添加lib的绝对路径，然后进行sudo ldconfig -v</p>
<p>系统库位置：/lib,/usr/lib</p>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>库的制作</category>
      </categories>
      <tags>
        <tag>静态库</tag>
        <tag>动态库</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc 笔记</title>
    <url>//articles/gcc-%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>gcc编译流程：gcc -E hello.c(调用cpp,预处理+头文件展开+宏替换)–&gt;hello.i<br>gcc -S hello.i/hello.c（生成汇编代码）–&gt;hello.s<br>gcc -c hello.s(编译成二进制文件)–&gt;hello.o<br>调用ld命令    链接–&gt;a.out</p>
<a id="more"></a>

<p>gcc -I (大写i) 指定包含头文件的路径<br>gcc -o 指定生成程序名<br>gcc -D 宏定义<br>-L 包含库路径<br>-l(小写L)指定库名（用法：libxxx.so用-lxxx）<br>-g 用于gdb调试    （会在可执行程序里加入调试信息，文件变大）<br>-Wall     显示全部警告<br>-lstdc++        编译C++代码（或者直接使用g++）<br>-O        优化1-3，数字越大优化强度越强（-O1，-O2，-O3）</p>
]]></content>
      <categories>
        <category>编译器</category>
        <category>gcc</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 笔记</title>
    <url>//articles/vim-%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>vimtutor        vim教程<br>光标移动：hjkl    左下上右<br>0：到行首<br>$：到行尾<br>gg:到文件头<br>G:到文件末行首<br>12G: 到12行</p>
<a id="more"></a>

<p>x:删除光标所在位置的字符但不切换模式<br>X：删除光标前的字母<br>s:删除光标所在位置的字符并切换为插入<br>S：删除当前所在行并切换为插入<br>i:不移动光标，光标前插入切换为插入模式<br>大写I:在行首切换为插入模式<br>a:在光标后插入<br>A：在行尾插入<br>o:在下方开启新行，切换为插入模式<br>O：在上方开启新行，切换为插入模式</p>
<p>进行末行模式：冒号:<br>退出末行模式：两下ESC<br>(末行模式下可以执行命令:! ls -l)<br>：s/jack/jackon    替换jack为jackon，只替换光标后的第一个匹配<br>：s/jack/tom/g    当前行的所有匹配都替换<br>：%s/jack/tom    所有行第一个匹配都替换<br>：%s/jack/tom/g    所有行都替换<br>：w        只保存不退出<br>：q        只退出，文件不能修改<br>：q!        不保存退出<br>：wq    保存退出<br>：x        保存退出<br>：sp+文件名字，横屏分屏显示（按ctrl+w两下就切换当前屏，：q就退一个：qall 全部退出：wqall全部保存退出）<br>：vsp+文件名字，竖屏分屏显示</p>
<p>ZZ（命令模式下）：保存退出</p>
<p>u;撤销<br>d+w:从光标位置开始删除后续单词中的部分<br>d+$（D）:删至行尾<br>d+0：删至行首（不包括光标所在位置的字符）<br>dd:删除光标所在行<br>2dd:删除两行<br>yy:复制一行<br>nyy：复制多行<br>p:粘贴到下一行<br>P:粘贴到上一行</p>
<p>r+某个字母：替换字母<br>v:切换为可视模式（y复制内容+p/P进行粘贴）<br>查找内容：/+内容，n/N进行遍历<br>？+内容，也可行，不过遍历方式不一样<br>光标定位在字符串上用#也可行<br>gg=G    格式调整（对齐）全部<br>&lt;&lt; ，&gt;&gt;单行调整格式(tab)<br>3&lt;&lt;,3&gt;&gt;多行调整格式</p>
<p>定位到某个函数按K等同于用man搜索帮助文档<br>2+K则是看到声明（2是对应的章）<br>/home/czp/.vimrc        本用户的配置文件</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 常用命令</title>
    <url>//articles/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<p>echo $BASH（环境变量）        检查系统使用的Shell<br>echo $HOME        家目录环境变量<br>echo 输出变量或字符串<br>alias 命令重命名<br>alias grep=’grep –color=auto’    查找并标红<br>(可以进.bashrc改)<br>cat /etc/shells        查看当前系统下的shell<br>history        显示历史命令<br>date +’%Y%m%d’ 日期显示格式</p>
<a id="more"></a>

<p>man man<br>ls         (list)<br>ls -l         显示详细的目录下文件信息<br>(文件权限，硬链接计数，用户，用户组)<br>（-代表普通文件（查找该类型文件时用f）   d目录文件  l表示软连接文件（符号链接）  c字符设备文件（键盘，鼠标）   b块设备文件   p(pipe) 管道设备     s本地套接字）<br>（用户权限+用户组权限+其他人的权限    0777，r读，w写，x执行）</p>
<p>rwx    111    7<br>rw-    110    6<br>r-x    101    5<br>r–    100    4<br>-wx    011    3<br>-w-    010    2<br>–x    001    1<br>—    000    0</p>
<p>chmod u|g|o|a +|- r|w|x filename<br>chmod 0777 filename 目录需要有可执行权限才能进入<br>sudo chown a    filename        改变用户<br>sudo chown a:a filename    改变用户和组<br>sudo chgrp filename    改变组</p>
<p>ln hello hello.hard        建立硬链接，目录也可以<br>ln -s     hello hello.hard    建立软链接    （快捷方式）目录也可以<br>unlink hello.hard        删除链接<br>硬链接计数为0时，文件被删除</p>
<p>ls -a            显示全部文件（包括隐藏文件）<br>ls -R            递归显示子目录<br>ls -lrt        按时间显示<br>ls *.c<br>ls /            查看根目录下的文件</p>
<p>cd             change directory        回到用户家目录<br>cd ~            回到用户家目录<br>cd     $HOME    回到用户家目录</p>
<p>cd /            回到根目录<br>cd -            回到上次的目录</p>
<p>$            表示普通用户</p>
<h1 id="表示超级用户"><a href="#表示超级用户" class="headerlink" title="表示超级用户"></a>表示超级用户</h1><p>pwd            显示当前工作目录</p>
<p>/home/czp    用户家目录<br>/bin         可执行程序的目录<br>/sbin        超级管理员的可执行程序目录<br>/boot        启动相关的文件<br>/lib             存放库的（系统最基本的动态共享库）<br>/media        U盘等外接设备的目录（自动挂载）<br>/mnt         手动挂载<br>/usr            unix system resources    系统资源，自己安装的库等应用<br>/usr/local    用户自己安装的软件的目录<br>（ifconfig）    查看IP<br>/proc         系统内存的映射，进程运行的信息保存位置<br>/etc         系统软件的启动和配置目录<br>/etc/passwd    用户存放文件<br>/dev            设备文件目录</p>
<p>cat /etc/passwd<br>man 5 passwd    查看文件格式</p>
<p>mkdir        创建目录，可多个<br>mkdir    aa/cc    aa存在才可以<br>mkdir -p dd/bb    dd不存在也可<br>rmdir -p dd/bb    两个一起remove<br>rmdir    aa    aa非空则不可<br>touch         创建文件，若文件已存在则修改最后访问时间</p>
<p>which        显示命令位置<br>which cd        什么都没有显示，因为cd是shell本身带的<br>whoami        显示当前用户名<br>date         查看时间日期</p>
<p>rm -r    递归删除<br>rm -f    强制删除<br>rm -rf *    删除当前目录下所有内容</p>
<p>cp hello aa    aa为目录<br>cp hello world    world是文件<br>cp -r aa bb<br>mv hello hello1    改名</p>
<p>cat          concatenate        显示文件信息<br>more        分屏显示文件，空格下一页，回车下一行<br>less            分屏显示文件信息</p>
<p>head        查看文件头    默认显示10行<br>head -n 5 xxx.c            显示5行<br>tail            查看文件尾<br>tail    -f        可以一直跟踪文件末尾    调试服务器用用</p>
<p>wc         行、词、字节<br>wc -l -w -c    分开显示</p>
<p>du    （disk usage）    磁盘使用率 显示目录下文件大小<br>du -h    人性化显示<br>du -h –max-depth=1    只显示一级<br>df -h  (disk free)        空余硬盘</p>
<p>find dir -option 内容<br>find dir -name “*.c”<br>find dir -type f<br>find dir -size +1M    （k用小写）<br>find dir -size +1M -size -5M<br>不写+-即为等，但不精确<br>find dir -maxdepth -size +1M        (只要一级目录，maxdepth要放前面)<br>find dir -maxdepth -size +1M | ls -l  详细显示，利用了管道，但这个不好使<br>find dir -maxdepth -size +1M | xargs ls -l     这个才可以<br>find dir -maxdepth -size +1M -exec ls -l     { } \：这个也可以用<br>find dir -maxdepth -size +1M -ok ls -l     { } \：会进行询问<br>-exec有弊端，会一下子把前面的东西全部传给后面的指令，很有可能会造成后面的溢出<br>xargs 会把前面查找的结果分成若干个块，按块传递给后面的指令</p>
<p>find dir -type f | grep txt     直接输出给后面的指令，对文件里的内容进行查找<br>grep “main” *.c    按内容查找，输出文件中对应行<br>grep -rn “main” *.c   递归目录并显示具体行数<br>cat a.c | grep main        结合管道使用<br>tail -f a.c | grep main    结合管道使用<br>tail -f a.c | grep -v main    过滤对应信息</p>
<p>zip -r dir.zip dir     递归压缩<br>unzip dir.zip<br>gzip与gunzip生成的是.gz文件，只能对文件处理，不能对目录<br>tar zcvf bb.tar.gz bb(压缩包.gz，不带z的话只会生成tar包，压缩c，v显示信息，f代表指定压缩包名字) 生成.tar.gz，最常用<br>tar zxvf bb.tar.gz    （x代表解压）<br>tar jcvf bb.tar.bzip2 bb<br>tar jxvf bb.tar.bzip2    bzip2格式</p>
<p>rar a -r newdir dir<br>rar x -r newdir.rar</p>
<p>apt-get 自动安装软件，需要知道软件名称<br>sudo apt-get update    更新源    /etc/apt/sources.list<br>sudo apt-get install<br>sudo apt-get remove<br>sudo apt-get clean</p>
<p>dpkg 根据deb安装包来安装软件<br>sudo dpkg-i xxx.deb<br>sudo dpkg-r xxx.deb</p>
<p>源码安装<br>1、    解压缩源代码包<br>2、    cd dir<br>3、    ./config    检测文件是否有缺失，创建makefile，检测编译环境<br>4、    make 编译源码，生成库和可执行程序<br>5、    sudo make install 把库和可执行程序安装到系统路径下<br>6、    sudo make distclean    删除和卸载软件</p>
<p>ping baidu.com    查看是否联网<br>sudo useradd -s（指定Shell)-g（指定组）-d（用户家目录）-m（家目录不存在时自动创建）<br>例：sudo useradd -s /bin/bash -g czp -d /home/czp -m czp<br>sudo groupadd czp<br>sudo passwd czp<br>suczp    缺少环境变量，可能某些功能有问题<br>su-czp    带有环境变量<br>sudo su 切换到超级用户 super user<br>sudo userdel czp<br>sudo userdel -r czp 连带删除家目录</p>
<p>umask 补码显示文件权限        umask -S    文字表示显示权限<br>0002 取反 0775 &amp; 0666（touch后的默认文件权限）0664（之后的文件权限）<br>重启：reboot<br>关机 init 0</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举类型使用注意事项</title>
    <url>//articles/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html</url>
    <content><![CDATA[<p>未命名的enum只能在定义该enum时定义它的对象（分号前面）</p>
<a id="more"></a>
<p>枚举成员是const，提供初始值时必须是常量表达式，同时，我们也可以在任何需要常量表达式的地方使用枚举成员。如使用enum作为switch语句的表达式，而将枚举值作为case标签，也能将枚举类型作为非类型模板形参使用，或者在类的定义中初始化枚举类型的静态数据成员</p>
<p>初始化已命名的enum对象或对其赋值必须使用一个枚举成员或该类型的另一个对象，同时我们不能将整型值传给enum形参，但是可以将一个不限定作用域的枚举类型的对象或枚举成员传给整型形参，因为一个不限定作用域的枚举类型的对象或枚举成员自动转换为整型，而限定作用域的枚举类型则不会进行这样的隐式转换。<br>此时enum的值类型进行提升，但是永远不会提升成unsigned char，即使枚举值可以用unsigned char存储也是如此</p>
<p>默认情况下限定作用域的enum成员类型是int，我们可以进行指定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum adsa:unsigned long long&#123;</span><br><span class="line">	-------</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于不限定作用域的枚举类型的枚举成员则不存在默认类型，一般认为足够大够容纳枚举值，如果我们再指定大小的话容易引发程序错误</p>
<p>枚举类型的前置声明必须指定其成员的大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum adsa:unsigned long long;</span><br><span class="line">enum class opadsa;&#x2F;&#x2F;限定作用域默认为int</span><br></pre></td></tr></table></figure>
<p>我们不可以在同一个上下文先声明一个限定作用域的enum名字，再声明一个不限定作用域的同名enum；</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用using的别名声明与typedef的区别</title>
    <url>//articles/%E5%88%AB%E5%90%8D%E5%A3%B0%E6%98%8E%E4%B8%8Etypedef%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content><![CDATA[<p>使用using的别名声明和typedef完成的是一模一样的工作，那么两个之间有什么区别呢？</p>
<a id="more"></a>
<p>一个最重要的区别就是使用using的别名声明可以直接进行模板化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">using MyAllocList&#x3D;std::list&lt;T,MyAlooc&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">MyAllocList&lt;Widget&gt; lw;</span><br></pre></td></tr></table></figure>
<p>而使用typedef的话，就需要将类型放置在类中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct MyAllocList&#123;</span><br><span class="line">	typedef std::list&lt;T,MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;使用模板实例下的类型别名;</span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw;</span><br></pre></td></tr></table></figure>
<p>此外，如果要在模板内使用typedef来创建一个成员，而且它的类型由模板形参指定的话，就需要添加前缀typename来告知编译器这是一个类型成员，而不是static成员(如果是使用using声明的别名则可以直接使用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Widget&#123;</span><br><span class="line">private:</span><br><span class="line">	typename MyAllocList&lt;T&gt;::type list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用红黑树实现关联容器map（待更新）</title>
    <url>//articles/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8map(%E5%BE%85%E6%9B%B4%E6%96%B0%EF%BC%89.html</url>
    <content><![CDATA[<p>关联容器map是一个pair&lt;const key_type,value_type&gt;，基于此建立了从key到value的映射，并且相关的复杂度是log(N)。那么如何使用红黑树来实现它呢？</p>
<a id="more"></a>
<p>首先建立一个红黑树的结点结构体，并且这个结点要关联到map的元素，即一个pair数据成员</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">enum COLOR&#123;RED,BLACK&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key_type,typename Value_type&gt;</span><br><span class="line">struct RBTreeNode&#123;</span><br><span class="line">	RBTreeNode&lt;Key_type, Value_type&gt;* left;</span><br><span class="line">	RBTreeNode&lt;Key_type, Value_type&gt;* right;</span><br><span class="line">	RBTreeNode&lt;Key_type, Value_type&gt;* parent;</span><br><span class="line">	pair&lt;Key_type, Value_type&gt; value;</span><br><span class="line">	COLOR color;</span><br><span class="line">	RBTreeNode(const Key_type&amp; key &#x3D; Key_type(), const Value_type&amp; value&#x3D;Value_type(),COLOR Color&#x3D;RED)</span><br><span class="line">		:left(NULL),right(NULL),parent(NULL),value(key,value),color(Color)&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有了红黑树的结点，现在假想我们已经有了一颗以map元素类型为结点的红黑树。那么要遍历一个map容器来进行搜索的话我们就需要遍历这颗红黑树，即从它关键值最小的结点遍历到关键值最大的结点。那么我们就需要一种操作（一个类）来进行红黑树的遍历。不难想到可以构建一个红黑树的迭代器来实现这个遍历操作。</p>
<p>我们知道，迭代器的begin()指向容器的首元素（最小元素），而end()指向容器的尾后元素（最大元素的后一个位置），那么对于一颗红黑树而言，我们就需要另外构建一个尾后结点来让迭代器的end()指向它。假设这个结点命名为header，因为这个结点不能破坏原先红黑树的性质，、所以不能是黑色，只能是红色。</p>
<p>现在我们需要将这个游离的结点与原先的红黑树相连接，考虑到我们是打算构建一个迭代器，那么就需要将header与树中最小和最大结点连接，假设树中最小元素为minNode，最大元素为maxNode</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">header-&gt;left&#x3D;minNode;</span><br><span class="line">header-&gt;right&#x3D;maxNode;</span><br></pre></td></tr></table></figure>
<p>即我们构建的迭代器的begin()指向header的左孩子，而end()指向header，end()后退一步就指向header的右孩子。</p>
<p>最后这个header结点还需要连接parent，此时我们可以把它和原先树中的根节点互联</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">header-&gt;parent&#x3D;rootNode;</span><br><span class="line">rootNode-&gt;parent&#x3D;header;</span><br></pre></td></tr></table></figure>
<p>接下来就可以开心地实现红黑树的迭代器了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename Key_type,typename Value_type&gt;</span><br><span class="line">class RBTreeIterator</span><br><span class="line">&#123;</span><br><span class="line">	typedef RBTreeNode&lt;Key_type, Value_type&gt; Node;</span><br><span class="line">	typedef node* NodePtr;</span><br><span class="line">	typedef RBTreeIterator&lt;Key_type, Value_type&gt; self;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	RBTreeIterator(NodePtr node_ptr&#x3D;nullptr):nodePtr(node_ptr)&#123;&#125;</span><br><span class="line">	RBTreeIterator(const self&amp; s) :nodePtr(s.nodePtr)&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	pair&lt;Key_type, Value_type&gt;&amp; operator*() &#123;</span><br><span class="line">		return nodePtr-&gt;value;</span><br><span class="line">	&#125;</span><br><span class="line">	pair&lt;Key_type, Value_type&gt;* operator-&gt;() &#123;</span><br><span class="line">		return &amp;(operator*()):</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; operator++() &#123;</span><br><span class="line">		RBTreeItIncrement();</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	self operator++(int) &#123;</span><br><span class="line">		self tmp(*this);</span><br><span class="line">		RBTreeItIncrement();</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; operator--() &#123;</span><br><span class="line">		RBTreeItDeCrement();</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	self operator--(int) &#123;</span><br><span class="line">		self tmp(*this);</span><br><span class="line">		RBTreeItDecrement();</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator&#x3D;&#x3D;(const self&amp; s) &#123;</span><br><span class="line">		return nodePtr &#x3D;&#x3D; s.nodePtr;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator!&#x3D;(const self&amp; s) &#123;</span><br><span class="line">		return !(this &#x3D;&#x3D; s);</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	void RBTreeItIncrement() &#123;</span><br><span class="line">		if (nodePtr-&gt;right) &#123;</span><br><span class="line">			nodePtr &#x3D; nodePtr-&gt;right;</span><br><span class="line">			while (nodePtr-&gt;left)</span><br><span class="line">				nodePtr &#x3D; nodePtr-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			NodePtr nodeParent &#x3D; nodePtr-&gt;parent;</span><br><span class="line">			while (nodePtr &#x3D;&#x3D; nodeParent-&gt;right) &#123;</span><br><span class="line">				nodePtr &#x3D; nodeParent;</span><br><span class="line">				nodeParent &#x3D; nodePtr-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			if (nodePtr-&gt;right !&#x3D; nodeParent)</span><br><span class="line">				nodePtr &#x3D; nodeParent;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void RBTreeItDecrement() &#123;</span><br><span class="line">		if (nodePtr-&gt;parent-&gt;parent &#x3D;&#x3D; nodePtr &amp;&amp; nodePtr-&gt;color &#x3D;&#x3D; RED)</span><br><span class="line">			nodePtr &#x3D; nodePtr-&gt;right;</span><br><span class="line">		else if (nodePtr-&gt;left) &#123;</span><br><span class="line">			nodePtr &#x3D; nodePtr-&gt;left;</span><br><span class="line">			while (nodePtr-&gt;right)</span><br><span class="line">				nodePtr &#x3D; nodePtr-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			NodePtr nodeParent &#x3D; nodePtr-&gt;parent;</span><br><span class="line">			while (nodePtr &#x3D;&#x3D; nodePtr-&gt;left) &#123;</span><br><span class="line">				nodePtr &#x3D; nodeParent;</span><br><span class="line">				nodeParent &#x3D; nodePtr-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			nodePtr &#x3D; nodeParent;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	NodePtr nodePtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>学习笔记</category>
        <category>STL源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么说vector的接口设计是败笔</title>
    <url>//articles/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4vector%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E6%98%AF%E8%B4%A5%E7%AC%94.html</url>
    <content><![CDATA[<p>作为一个类的设计者，我们应该把构造函数设计成客户无论使用小括号还是大括号都不会影响要调用的重载版本，而vector的构造函数却恰恰破坏了这个隐性规定。我们知道，在构造一个vector的时候，使用大小括号来构造对象会产生完全不一样的结果。</p>
<a id="more"></a>
<p>为什么会这样呢？<br>首先，使用大括号来进行初始化对象有三个特点，第一个特点就是它禁止了会损失精度的隐式转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double x,y,z;</span><br><span class="line">int sum&#123;x+y+z&#125;; &#x2F;&#x2F;错误</span><br></pre></td></tr></table></figure>
<p>第二个特点就是不会变成一个函数的声明，因为用小括号来调用不带参数的构造函数的时候就会变成一个函数的声明，而大括号则不会，依旧会调用没有形参的构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Widget w1();	&#x2F;&#x2F;这是一个函数声明</span><br><span class="line">Widget w2&#123; &#125;;	&#x2F;&#x2F;这调用了没有形参的构造函数</span><br></pre></td></tr></table></figure>
<p>第三个特点就是在构造函数的重载决议期间，只要大括号内的实参能与带std::initializer_list类型的形参匹配或进行隐式转换，就会调用这个构造函数，而若是存在带std::initializer_list类型的形参的构造函数，而实参与形参之间需要进行转换且转换会损失精度，那么就会出错。此外如果该构造函数的形参与实参完全不匹配（无法进行隐式转换，如实参int形参string），才会考虑其他的候选函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Widget(std::initializer_list&lt;bool&gt; il);&#x2F;&#x2F;其中一个构造函数</span><br><span class="line"></span><br><span class="line">Widget w&#123;10,5.0&#125;;&#x2F;&#x2F;错误，bool无法精确表示这两个值中的任何一个</span><br><span class="line"></span><br><span class="line">Widget(std::initializer_list&lt;string&gt; il)	&#x2F;&#x2F;其中一个构造函数</span><br><span class="line"></span><br><span class="line">Widget w2&#123;10,5.0&#125;; &#x2F;&#x2F;考虑匹配其他构造函数</span><br></pre></td></tr></table></figure>
<p>还有一点需要注意的就是当实参为空的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Widget w1&#123; &#125;;	&#x2F;&#x2F;调用默认构造函数</span><br><span class="line">Widget w2 (&#123; &#125;);	&#x2F;&#x2F;调用带std::initializer_list的构造函数</span><br><span class="line">Widget w2 &#123;&#123; &#125;&#125;;	&#x2F;&#x2F;调用带std::initializer_list的构造函数</span><br></pre></td></tr></table></figure>
<p>我们知道vector中有一个带initializer_list的构造函数和一个不带initializer_list形参的构造函数，那么用大小括号来初始化它的对象的时候，就会出现完全不一样的结果，但是我们原先却是希望无论使用大小括号都不要影响到调用的重载版本的。所以才说vector的接口设计就是败笔</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解auto与隐形代理类之间的冲突</title>
    <url>//articles/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3auto%E4%B8%8E%E4%BB%A3%E7%90%86%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%B2%E7%AA%81.html</url>
    <content><![CDATA[<p>代理类：指为了模拟或增广其他类型的类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;bool&gt;类下的operator[ ]返回一个隐形代理类对象，即std::vector&lt;bool&gt;::reference对象</span><br><span class="line"></span><br><span class="line">std::bitset::reference也是同样的隐形代理类</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>为什么说是隐形？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::vector&lt;bool&gt;是一个经过特例化的类，它的对象采用了一种压缩的方式表示其特有的bool元素，</span><br><span class="line">每一个bool元素用一个比特来表示。</span><br><span class="line">因为C++中禁止了比特的引用，所以它的operator[ ]不能返回bool&amp;。</span><br><span class="line">那么它就需要返回一个像bool&amp;的对象。</span><br><span class="line">即需要模拟bool&amp;，就是用std::vector&lt;bool&gt;::reference这个代理类对象来代理bool&amp;,</span><br><span class="line">所以要保证它像bool&amp;，而且所有能用bool&amp;的地方都能用这个对象代替。</span><br></pre></td></tr></table></figure>
<p>那么auto为什么会与隐形代理类有冲突呢？<br>考虑下面这个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::vector&lt;bool&gt; reference(const Widget &amp;w);</span><br><span class="line">Widget w;</span><br><span class="line">auto highPriority&#x3D;features(w)[5];</span><br><span class="line">processWidet(w,highPriority);&#x2F;&#x2F;未定义行为</span><br></pre></td></tr></table></figure>
<p>为什么最后会是未定义的行为呢？因为processWidget函数中的highPriority参数中接受的实参是一个指针，然后这个指针指向了一个临时对象。<br>下面来一步步剖析这个行为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先features(w)产生一个std::vector&lt;bool&gt;临时对象temp,</span><br><span class="line">执行opterator[ ]后产生一个std::vector&lt;bool&gt;::reference的代理类对象，</span><br><span class="line">这个对象中含有一个指向临时对象temp中的指针，然后再加上5个偏移量。</span><br><span class="line">而processWidget函数中的参数拷贝了这个指针的地址，</span><br><span class="line">在auto highPriority&#x3D;features(w)[5]这条表达式结束的时候，</span><br><span class="line">临时对象temp销毁，但我们却还在后面使用了一个指向这个临时对象temp的指针，</span><br><span class="line">该指针就变成了一个空悬指针，最后就导致了未定义行为。</span><br></pre></td></tr></table></figure>
<p>那么如何避免这种行为呢？<br>可以采用直接转换的方式，将产生的那个临时对象temp中的某个地址的bool值拷贝下来即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool highPriority&#x3D;features(w)[5];</span><br></pre></td></tr></table></figure>
<p>也同样可以使用auto+强制类型转换的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto highPriority&#x3D;static_cast&lt;bool&gt;(features(w)[5]);</span><br></pre></td></tr></table></figure>

<p>综上，auto表达式右边不能直接使用代理类对象，因为auto会推断出一个代理类对象的类型，而不是它想要的类型，就上面这个例子而言，它想要的是一个bool值，而不是一个指向临时对象中的bool的指针。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>auto、decltype与模板类型推断的异同</title>
    <url>//articles/auto-decltype%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E7%9A%84%E5%BC%82%E5%90%8C.html</url>
    <content><![CDATA[<p>auto和模板类型推断在一般情况下等价（除非遇到列表实参的情况），这两种推断方式同样会忽略掉初始化表达式的引用性，同样会在形参不是引用的情况下将数组名和函数名退化为指针，而在形参是引用的情况将类型推断为数组类型（包括数组大小）和函数类型。</p>
<a id="more"></a>
<p>但是在实参为列表的时候，auto会假定用大括号括起来的初始化表达式代表一个initializer_list，而模板类型推断则不会。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto x&#x3D;&#123;1,2,3&#125;;&#x2F;&#x2F;推断类型为initializer_list&lt;int&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void f(T param);</span><br><span class="line"></span><br><span class="line">f(&#123;1,2,3&#125;);&#x2F;&#x2F;这个是错误的，因为模板类型推断无法推断出一个initialist_list</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正确做法</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void f(std::initializer_list&lt;T&gt; initList);</span><br><span class="line"></span><br><span class="line">f(&#123;1,2,3&#125;);&#x2F;&#x2F;正确，推断出T为int</span><br></pre></td></tr></table></figure>
<p>但是！在函数返回值或者lambda表达式的形参中使用auto，表示的就是要使用模板类型推断！此时不能推断出一个initialist_list！</p>
<p>那么decltype的类型推断方式有什么不同呢？<br>decltype的类型推断其实就是一个“火眼金睛”，它能够还原实参本来的类型，即数组就推断出数组类型，函数就推断出函数类型。除非另外用括号将一个变量括起来，此时会推断出引用类型。</p>
<p>在C++ 11中，只允许堆单表达式的lambda的返回值进行类型推断，而在C++ 14中，这个范围扩张到了一切lambda和一切函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C++ 11中</span><br><span class="line">template&lt;typename Container,typename Index&gt;</span><br><span class="line">auto func(Container &amp;c,Index i)-&gt;decltype(c[i])</span><br><span class="line">&#123;</span><br><span class="line">	return c[i];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++ 14 中</span><br><span class="line">template&lt;typename Container,typename Index&gt;</span><br><span class="line">auto func(Container &amp;c,Index i)</span><br><span class="line">&#123;	&#x2F;&#x2F;这是不正确的，因为引用性会被忽略</span><br><span class="line">	return c[i];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;保存引用性</span><br><span class="line">template&lt;typename Container,typename Index&gt;</span><br><span class="line">delctype(auto) func(Container &amp;c,Index i)</span><br><span class="line">&#123;</span><br><span class="line">	return c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>decltype(auto)指auto指定了要实施类型推断的类型，然后采用了decltype的规则，即可以保存引用性</p>
<p>考虑到传进来的容器可能是一个右值容器，我们需要保存实参的类型再进行类型推断，否则就会出现在对一个右值容器进行赋值的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename Container,typename Index&gt;</span><br><span class="line">delctype(auto) func(Container &amp;&amp;c,Index i)</span><br><span class="line">&#123;</span><br><span class="line">	return std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Effective Modern C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>对string调用swap迭代器失效的原因</title>
    <url>//articles/%E5%AF%B9string%E8%B0%83%E7%94%A8swap%E4%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0.html</url>
    <content><![CDATA[<p>在《C++ Primer》中提到，除string外的容器在swap后指向容器的迭代器、引用和指针都不会失效，但却没有说明string调用swap后会失效的原因。</p>
<a id="more"></a>
<p>在查阅资料后发现，C++中存在对短字符串的优化，即Short String Optimization（SSO)。</p>
<p>因为在默认情况下，C++的string都是存储在堆中，导致访问string需要经过一次寻址过程，速度较慢，并且这种实现的空间局部性不好，对cache的利用较低。而且很多string的字符串长度很小，这个时候，就可以把字符串存储到栈上，从而不需要进行内存分配，优化创建速度，并且访问栈上数据的局部性很好，速度比较快。</p>
<p>即C++会自动把较短的字符串放到对象内部，较长的字符串放到动态内存。假如string 用 SSO 实现，而待交换的两个对象中的字符串恰好一长一短，则原先指向短字符串中的迭代器会全部失效。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>实现空间配置器（allocator)</title>
    <url>//articles/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8.html</url>
    <content><![CDATA[<p>allocator 是一个空间配置器而不是内存配置器，因为空间也可以是磁盘或其他辅助存储介质，我们可以写一个allocator直接向磁盘取空间</p>
<a id="more"></a>
<h2 id="设计一个简单的空间配置器"><a href="#设计一个简单的空间配置器" class="headerlink" title="设计一个简单的空间配置器"></a>设计一个简单的空间配置器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef _CZPALLOC_</span><br><span class="line">#define _CZPALLOC_</span><br><span class="line"></span><br><span class="line">#include &lt;new&gt;;		&#x2F;&#x2F;使用定位new</span><br><span class="line">#include &lt;cstddef&gt;	&#x2F;&#x2F;使用ptrdiff_t,size_t</span><br><span class="line">#include &lt;cstdlib&gt;	&#x2F;&#x2F;使用exit()</span><br><span class="line">#include &lt;climits&gt;	&#x2F;&#x2F;使用UINT_MAX,指未分配的可用空间</span><br><span class="line">#include &lt;iostream&gt;	&#x2F;&#x2F;使用cerr</span><br><span class="line"></span><br><span class="line">namespace CZP &#123;</span><br><span class="line">	&#x2F;&#x2F;分配空间</span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	inline T _allocate(ptrdiff_t size, T*) &#123;	&#x2F;&#x2F;size表示分配对应类型内存的个数</span><br><span class="line">		set_new_handler(0);&#x2F;&#x2F;设置new失败时调用的处理函数，参数0表示处理函数将被设置为默认值，即会执行抛出bad_alloc异常</span><br><span class="line">		T* tmp &#x3D; (T*)(::operator new((size_t)(size * sizeof(T))));</span><br><span class="line">		if（!tmp)&#123;</span><br><span class="line">			cerr &lt;&lt; &quot;out of memory&quot; &lt;&lt; endl;</span><br><span class="line">			exit(1);	&#x2F;&#x2F;程序异常退出，参数为0时表示程序正常退出</span><br><span class="line">		&#125;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;释放空间</span><br><span class="line">	template&lt;typename T&gt;</span><br><span class="line">	inline void _deallocate(T* buffer) &#123;</span><br><span class="line">		::operator delete(buffer);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;构造对象</span><br><span class="line">	template &lt;typename T1,typename T2&gt;</span><br><span class="line">	inline void _construct(T1* p, const T2&amp; value) &#123;</span><br><span class="line">		new(p)T1(value);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;销毁对象</span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	inline void _destroy(T* ptr) &#123;</span><br><span class="line">		ptr-&gt;~T();</span><br><span class="line">	&#125;</span><br><span class="line">	template &lt;typename T&gt;</span><br><span class="line">	class allocator &#123;</span><br><span class="line">	public:</span><br><span class="line">		&#x2F;&#x2F;各个类型别名的声明</span><br><span class="line">		typedef T value_type;</span><br><span class="line">		typedef T* pointer;</span><br><span class="line">		typedef const T* const_pointer;</span><br><span class="line">		typedef T&amp; reference;</span><br><span class="line">		typedef const T&amp; const_reference;</span><br><span class="line">		typedef size_t size_type;</span><br><span class="line">		typedef ptrdiff_t difference_type;</span><br><span class="line">		&#x2F;&#x2F;一个嵌套的类模板</span><br><span class="line">		template &lt;typename U&gt;</span><br><span class="line">		struct rebind &#123;</span><br><span class="line">			typedef allocator&lt;U&gt; other;</span><br><span class="line">		&#125;;</span><br><span class="line">		pointer allocate(size_type n, const void* hint &#x3D; 0) &#123;&#x2F;&#x2F;第二个参数是个提示，可能会利用来增进区域性（locality），可完全忽略</span><br><span class="line">			return _allocate((difference_type)n, (pointer)0);</span><br><span class="line">		&#125;</span><br><span class="line">		void deallocate(pointer p, size_type n) &#123;</span><br><span class="line">			_deallocate(p);</span><br><span class="line">		&#125;</span><br><span class="line">		void construct(pointer p, const T&amp; value) &#123;</span><br><span class="line">			_construct(p, value);</span><br><span class="line">		&#125;</span><br><span class="line">		void destroy(pointer p) &#123;</span><br><span class="line">			_destroy(p);</span><br><span class="line">		&#125;</span><br><span class="line">		pointer address(reference X) &#123;</span><br><span class="line">			return (pointer)&amp;X;</span><br><span class="line">		&#125;</span><br><span class="line">		const_pointer const_address(const_reference X) &#123;</span><br><span class="line">			return (const_pointer)&amp;X;</span><br><span class="line">		&#125;</span><br><span class="line">		size_type max_size()const &#123;</span><br><span class="line">			return size_type(UNIT_MAX &#x2F; sizeof(T));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;我们可以用这个空间配置器作为vector的第二个参数来指定使用它分配空间</span><br><span class="line">#endif &#x2F;&#x2F; !_CZPALLOC_</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>学习笔记</category>
        <category>STL源码剖析</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中类的对象模型探讨</title>
    <url>//articles/C-%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%8E%A2%E8%AE%A8.html</url>
    <content><![CDATA[<p>在C++中，类可以发生多继承，那么派生类中就会出现多份数据，进而导致访问出现二义性的情况。此时我们可以通过访问时添加作用域来解决二义性，但却无法避免同时保存多份数据浪费内存的情况。</p>
<a id="more"></a>
<p>这个时候，就可以使用虚继承来使派生类中只有一份数据，避免浪费内存，那么这样的虚继承是怎么实现的呢？</p>
<p>通过实践知道，对于一个空类，它占用的内存是1字节，而对于只有一个虚函数的类，它占用的内存却是4个字节。而这4个字节，就是一个vptr，即一个指向虚函数表的指针。</p>
<p>虚函数表中会保存类对象的相关类型（动态类型）以及相关的虚函数。派生类若是重新实现了继承下来的虚函数，那么这个时候虚函数表在运行时就会绑定到这个派生类的类型，其中的虚函数也是对应的相关类型的函数，而此时的vptr就是指向这个虚函数表中对应的函数</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>深度探索C++对象模型</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++移动构造函数为什么需要noexcept</title>
    <url>//articles/C-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81noexcept.html</url>
    <content><![CDATA[<p>在C++中，类的移动操作通常“窃取”资源而不分配资源，所以通常不会抛出任何异常。在编写一个不抛出异常的操作时，我们应该实现通知标准库以避免一些额外的工作。此时我们要在移动操作的声明和定义中添加noexcept来告知标准库。</p>
<a id="more"></a>
<p>虽然移动操作通常不会抛出异常，但是抛出异常也是允许的。那么当移动操作抛出异常时会发生什么呢？</p>
<p>举例来说，标准库要求容器能对异常发生时其自身的行为提供保障，如vector保证如果调用push_back然后分配内存的过程发生异常的话，vector自身不会发生改变。</p>
<p>而在vector重新分配内存的过程中，如果使用的是拷贝构造函数，即使异常发生了，那么只需要销毁新构造的对象然后释放刚分配的内存即可，vector本身自然不会发生任何改变。</p>
<p>如果使用的是移动构造函数，而这个移动构造函数发生了异常，那么对象可能移动了一部分，而此时明显无法满足vector本身不发生任何改变的要求。也就是说，我们必须把移动构造函数声明为noexcept来告知标准库这个移动操作可以安全使用，不然就必须使用拷贝构造函数。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序</title>
    <url>//articles/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>对于每一个元素，确定小于它的元素个数，然后将该元素放置在对应的位置上。</p>
<a id="more"></a>
<h2 id="代码实现（C-）"><a href="#代码实现（C-）" class="headerlink" title="代码实现（C++）"></a>代码实现（C++）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CountSort(vector&lt;int&gt;&amp; arr, int maxVal) &#123;</span><br><span class="line">	int len &#x3D; arr.size();</span><br><span class="line">	if (len &lt; 1)</span><br><span class="line">		return;</span><br><span class="line">	vector&lt;int&gt; count(maxVal + 1, 0);</span><br><span class="line">	vector&lt;int&gt; tmp(arr);</span><br><span class="line">	for (auto x : arr)</span><br><span class="line">		count[x]++;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; maxVal; ++i)</span><br><span class="line">		count[i] +&#x3D; count[i - 1];</span><br><span class="line">	for (int i &#x3D; len - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">		arr[count[tmp[i]] - 1] &#x3D; tmp[i];</span><br><span class="line">		count[tmp[i]]--;				&#x2F;&#x2F;注意这里要减1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），<br>快于任何比较排序算法。</p>
<p>而且当O(k)&gt;O(nlogn)的时候其效率反而不如基于比较的排序（<br>基于比较的排序的时间复杂度在理论上的下限是O(nlogn), 如归并排序，堆排序）</p>
<p>稳定性：稳定<br>注意：计数排序算法不是一个基于比较的排序算法，从而它的计算时间下界不再是O(nlogn)。<br>计数排序算法之所以能取得线性计算时间的上界是因为对元素的取值范围作了一定限制，<br>即k=O(n)。如果k=n2,n3,..，就得不到线性时间的上界。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法导论</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>//articles/%E7%BA%A2%E9%BB%91%E6%A0%91.html</url>
    <content><![CDATA[<h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h2><p>每个结点非红即黑，根结点和叶结点为黑色<br>红结点的孩子都是黑结点<br>对每个结点，从该结点到所有后代叶结点的简单路径上，均包含相同数目的黑结点</p>
<a id="more"></a>
<h2 id="左旋转操作"><a href="#左旋转操作" class="headerlink" title="左旋转操作"></a>左旋转操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void RBTree::RotateLeft(RBTreeNode* Node) &#123;</span><br><span class="line">	RBTreeNode* RNode &#x3D; Node-&gt;right;</span><br><span class="line">	Node-&gt;right &#x3D; RNode-&gt;left;</span><br><span class="line">	if (RNode-&gt;left !&#x3D; NULL) &#123;</span><br><span class="line">		RNode-&gt;left-&gt;parent &#x3D; Node;</span><br><span class="line">	&#125;</span><br><span class="line">	RNode-&gt;parent&#x3D;Node-&gt;parent; </span><br><span class="line">	if (Node-&gt;parent &#x3D;&#x3D; nil) root &#x3D; RNode;</span><br><span class="line">	else if (Node-&gt;parent-&gt;left &#x3D;&#x3D; Node) Node-&gt;parent-&gt;left &#x3D; RNode;</span><br><span class="line">	else Node-&gt;parent-&gt;right &#x3D; RNode;</span><br><span class="line">	RNode-&gt;left &#x3D; Node;</span><br><span class="line">	Node-&gt;parent &#x3D; RNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="右旋转操作"><a href="#右旋转操作" class="headerlink" title="右旋转操作"></a>右旋转操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void RBTree::RotateRight(RBTreeNode* Node) &#123;</span><br><span class="line">	RBTreeNode* LNode &#x3D; Node-&gt;left;</span><br><span class="line">	Node-&gt;left &#x3D; LNode-&gt;right;</span><br><span class="line">	if (LNode-&gt;right !&#x3D; NULL) &#123;</span><br><span class="line">		LNode-&gt;right-&gt;parent &#x3D; Node;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode-&gt;parent &#x3D; Node-&gt;parent;</span><br><span class="line">	if (Node-&gt;parent &#x3D;&#x3D; nil) root &#x3D; LNode;</span><br><span class="line">	else if (Node-&gt;parent-&gt;left &#x3D;&#x3D; Node) Node-&gt;parent-&gt;left &#x3D; LNode;</span><br><span class="line">	else Node-&gt;parent-&gt;right &#x3D; LNode;</span><br><span class="line">	LNode-&gt;right &#x3D; Node;</span><br><span class="line">	Node-&gt;parent &#x3D; LNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//注意：旋转操作中如果旋转结点为红色，且其父结点也是红色，那么旋转之后不会破坏红黑树的最后一条性质</p>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void RBTree::Insert(RBTreeNode* root,RBTreeNode* NNode) &#123;</span><br><span class="line">	RBTreeNode* PNode &#x3D; nil;</span><br><span class="line">	RBTreeNode* TempNode &#x3D; root;</span><br><span class="line">	while (TempNode !&#x3D; NULL) &#123;</span><br><span class="line">		PNode &#x3D; TempNode;</span><br><span class="line">		if (val &lt; TempNode-&gt;val) TempNode &#x3D; TempNode-&gt;left;</span><br><span class="line">		else TempNode &#x3D; TempNode-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">	NNode-&gt;parent &#x3D; PNode;</span><br><span class="line">	if (PNode &#x3D;&#x3D; nil) root &#x3D; NNode;</span><br><span class="line">	else if (val &lt; PNode-&gt;val) PNode-&gt;left &#x3D; NNode;</span><br><span class="line">	else PNode-&gt;right &#x3D; NNode;</span><br><span class="line">	NNode-&gt;color&#x3D;RED;&#x2F;&#x2F;记得将插入结点的颜色设为红色</span><br><span class="line">	InsertFixup(NNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入的性质修复"><a href="#插入的性质修复" class="headerlink" title="插入的性质修复"></a>插入的性质修复</h2><p>因为插入操作中将插入结点设置为红色，就不会破坏红黑树的最后一条性质，即每个结点到叶结点的简单路径上黑色结点树相同。那么此时若是插入结点的父结点为红色，就会破坏一条红黑树的性质，即红结点的孩子结点都是黑色，只要围绕这条性质来修复即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void RBTree::InsertFixup(RBTreeNode* Node) &#123;	</span><br><span class="line">	while (Node-&gt;parent-&gt;color &#x3D;&#x3D; RED) &#123;	</span><br><span class="line">		if (Node-&gt;parent-&gt;parent-&gt;left &#x3D;&#x3D; Node-&gt;parent) &#123;	</span><br><span class="line">			RBTreeNode* UNode &#x3D; Node-&gt;parent-&gt;parent-&gt;right;</span><br><span class="line">			if (UNode-&gt;color &#x3D;&#x3D; RED) &#123;		</span><br><span class="line">				Node-&gt;parent-&gt;color &#x3D; BLACK;	</span><br><span class="line">				UNode-&gt;color &#x3D; BLACK;</span><br><span class="line">				Node-&gt;parent-&gt;parent &#x3D; RED;		</span><br><span class="line">				Node &#x3D; Node-&gt;parent-&gt;parent;	</span><br><span class="line">			&#125;	</span><br><span class="line">			else if (Node &#x3D; Node-&gt;parent-&gt;right) &#123;&#x2F;&#x2F;两个结点弄一边</span><br><span class="line">				Node &#x3D; Node-&gt;parent;	</span><br><span class="line">				RotateLeft(Node);		</span><br><span class="line">			&#125;</span><br><span class="line">			Node-&gt;parent-&gt;color &#x3D; BLACK;	</span><br><span class="line">			Node-&gt;parent-&gt;parent-&gt;color &#x3D; RED;	</span><br><span class="line">			RotateRight(Node-&gt;parent-&gt;parent);		&#x2F;&#x2F;爷结点右转,带动染黑的父结点上移，维护性质</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;		</span><br><span class="line">			RBTreeNode* UNode &#x3D; Node-&gt;parent-&gt;parent-&gt;left;		</span><br><span class="line">			if (UNode-&gt;color &#x3D;&#x3D; RED) &#123;</span><br><span class="line">				UNode-&gt;color &#x3D; BLACK;</span><br><span class="line">				Node-&gt;parent-&gt;color &#x3D; BLACK;</span><br><span class="line">				Node-&gt;parent-&gt;parent-&gt;color &#x3D; RED;</span><br><span class="line">				Node &#x3D; Node-&gt;parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (Node-&gt;parent-&gt;left &#x3D; Node) &#123;	</span><br><span class="line">				Node &#x3D; Node-&gt;parent;</span><br><span class="line">				RotateRight(Node);</span><br><span class="line">			&#125;</span><br><span class="line">			Node-&gt;parent-&gt;color &#x3D; BLACK;</span><br><span class="line">			Node-&gt;parent-&gt;parent-&gt;color &#x3D; RED;</span><br><span class="line">			RotateLeft(Node-&gt;parent-&gt;parent);	</span><br><span class="line">		&#125;</span><br><span class="line">		root-&gt;color &#x3D; BLACK;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心思想：将破坏性质的红色结点（即插入结点的父结点）层层上移直到根，最后然染黑即可</p>
<h2 id="移植操作"><a href="#移植操作" class="headerlink" title="移植操作"></a>移植操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void RBTree::Transplant(RBTreeNode* Tree, RBTreeNode* GoneTree, RBTreeNode* NewTree) &#123;</span><br><span class="line">	if (GoneTree-&gt;parent &#x3D;&#x3D; nil) </span><br><span class="line">		root &#x3D; NewTree;	</span><br><span class="line">	else if (GoneTree &#x3D;&#x3D; GoneTre                                        e-&gt;parent-&gt;left) </span><br><span class="line">		GoneTree-&gt;parent-&gt;left &#x3D; NewTree;</span><br><span class="line">	else GoneTree-&gt;parent-&gt;right &#x3D; NewTree;		</span><br><span class="line">	NewTree-&gt;parent &#x3D; GoneTree-&gt;parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RBTreeNode* RBTree::DeleteNode(RBTreeNode* root,RBTreeNode* Node) &#123;</span><br><span class="line">	RBTreeNode* DNode &#x3D; Node;	</span><br><span class="line">	RBTreeNode* NNode &#x3D; nil;	</span><br><span class="line">	RBTreeNode* TempNode &#x3D; nil;		</span><br><span class="line">	TempNode-&gt;color &#x3D; Node-&gt;color;</span><br><span class="line">	if (Node-&gt;left &#x3D;&#x3D; nil) &#123;	</span><br><span class="line">		NNode &#x3D; Node-&gt;right;</span><br><span class="line">		Transplant(root, Node, Node-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (Node-&gt;right &#x3D;&#x3D; nil) &#123;</span><br><span class="line">		NNode &#x3D; Node-&gt;left;</span><br><span class="line">		Transplant(root, Node, Node-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;		</span><br><span class="line">		DNode &#x3D; Minimum(Node-&gt;right);</span><br><span class="line">		TempNode-&gt;color &#x3D; DNode-&gt;color;</span><br><span class="line">		NNode &#x3D; DNode-&gt;right;</span><br><span class="line">		if (DNode-&gt;parent !&#x3D; Node) &#123;		</span><br><span class="line">			Transplant(root, DNode, DNode-&gt;right);	</span><br><span class="line">			DNode-&gt;right &#x3D; Node-&gt;right;		</span><br><span class="line">			Node-&gt;right-&gt;parent &#x3D; DNode;</span><br><span class="line">		&#125;</span><br><span class="line">		Transplant(root, Node, DNode);	</span><br><span class="line">		DNode-&gt;left &#x3D; Node-&gt;left;		</span><br><span class="line">		Node-&gt;left-&gt;parent &#x3D; DNode;</span><br><span class="line">		DNode-&gt;color &#x3D; Node-&gt;color;		</span><br><span class="line">	&#125;</span><br><span class="line">	if (TempNode-&gt;color &#x3D;&#x3D; BLACK) DeleteFixup(NNode);</span><br><span class="line">	return DNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除操作的性质修复"><a href="#删除操作的性质修复" class="headerlink" title="删除操作的性质修复"></a>删除操作的性质修复</h2><p>赋予破坏红黑树性质的结点双色属性，然后致力于将这种双色属性消除，主要是使得兄弟结点的颜色是黑色，并且其右孩子的颜色是红色，在这种情况下就可以消除掉双色结点的双色属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void RBTree::DeleteFixup(RBTreeNode* Node) &#123;</span><br><span class="line">	while (Node !&#x3D; root &amp;&amp; Node-&gt;color &#x3D;&#x3D; BLACK) &#123;</span><br><span class="line">		if (Node &#x3D; Node-&gt;parent-&gt;left) &#123;</span><br><span class="line">			RBTreeNode* BNode &#x3D; Node-&gt;right;	</span><br><span class="line">			if (BNode-&gt;color &#x3D;&#x3D; RED) &#123;&#x2F;&#x2F;换个兄弟结点</span><br><span class="line">				BNode-&gt;color &#x3D; BLACK;	</span><br><span class="line">				Node-&gt;parent-&gt;color &#x3D; RED;		</span><br><span class="line">				RotateLeft(Node-&gt;parent);		</span><br><span class="line">				BNode &#x3D; Node-&gt;parent-&gt;right;	</span><br><span class="line">			&#125;</span><br><span class="line">			if (BNode-&gt;left-&gt;color &#x3D;&#x3D; BLACK &amp;&amp; BNode-&gt;right-&gt;color &#x3D;&#x3D; BLACK) &#123;	&#x2F;&#x2F;双色结点上移</span><br><span class="line">				BNode-&gt;color &#x3D; RED;		</span><br><span class="line">				Node &#x3D; Node-&gt;parent;	</span><br><span class="line">			&#125;</span><br><span class="line">			else if (BNode-&gt;right-&gt;color &#x3D;&#x3D; BLACK) &#123;</span><br><span class="line">			&#x2F;&#x2F;换兄弟，使兄弟为黑，其右孩子为红</span><br><span class="line">				BNode-&gt;left-&gt;color &#x3D; BLACK;		</span><br><span class="line">				BNode-&gt;color &#x3D; RED;			</span><br><span class="line">				RotateRight(BNode);		</span><br><span class="line">				BNode &#x3D; Node-&gt;parent-&gt;right;	</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				BNode-&gt;color &#x3D; Node-&gt;parent-&gt;color;</span><br><span class="line">				Node-&gt;parent-&gt;color &#x3D; BLACK;</span><br><span class="line">				BNode-&gt;right-&gt;color &#x3D; BLACK;</span><br><span class="line">				RotateLeft(Node-&gt;parent);</span><br><span class="line">				Node &#x3D; root;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			RBTreeNode* BNode &#x3D; Node-&gt;parent-&gt;left;</span><br><span class="line">			if (BNode-&gt;color &#x3D; RED) &#123;</span><br><span class="line">				BNode-&gt;color &#x3D; BLACK;</span><br><span class="line">				Node-&gt;parent-&gt;color &#x3D; RED;</span><br><span class="line">				RotateRight(Node-&gt;parent);</span><br><span class="line">				BNode &#x3D; Node-&gt;parent-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (BNode-&gt;left-&gt;color &#x3D;&#x3D; BLACK &amp;&amp; BNode-&gt;right-&gt;color &#x3D;&#x3D; BLACK) &#123;</span><br><span class="line">				BNode-&gt;color &#x3D; RED;</span><br><span class="line">				Node &#x3D; Node-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (BNode-&gt;left-&gt;color &#x3D;&#x3D; BLACK) &#123;</span><br><span class="line">				BNode-&gt;right-&gt;color &#x3D; BLACK;</span><br><span class="line">				BNode-&gt;color &#x3D; RED;</span><br><span class="line">				RotateLeft(BNode);</span><br><span class="line">				BNode &#x3D; Node-&gt;parent-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				BNode-&gt;color &#x3D; Node-&gt;parent-&gt;color;</span><br><span class="line">				Node-&gt;parent-&gt;color &#x3D; BLACK;</span><br><span class="line">				BNode-&gt;left-&gt;color &#x3D; BLACK;</span><br><span class="line">				RotateRight(Node-&gt;parent);</span><br><span class="line">				Node &#x3D; root;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Node-&gt;color &#x3D; BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法导论</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>//articles/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>二叉搜索树的原理无非就是左孩子的值小于等于父节点，右孩子的值大于等于父节点，所有的操作都是围绕这个原理来实现的<br>随机构造一棵二叉搜索树的期望高度为O（lg n），因此二叉搜索树上的动态集合的基本操作平均运行时间为（lg n）</p>
<a id="more"></a>
<h2 id="实现（C-）"><a href="#实现（C-）" class="headerlink" title="实现（C++）"></a>实现（C++）</h2><h3 id="结点的结构体定义"><a href="#结点的结构体定义" class="headerlink" title="结点的结构体定义"></a>结点的结构体定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉树的结点的结构体定义</span><br><span class="line">struct treeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	treeNode* left;</span><br><span class="line">	treeNode* right;</span><br><span class="line">	treeNode* parent;</span><br><span class="line">	treeNode(int x) :val(x),left(NULL),right(NULL),parent(NULL)&#123;   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="搜索操作"><a href="#搜索操作" class="headerlink" title="搜索操作"></a>搜索操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉树的搜索操作实现</span><br><span class="line">treeNode* tree_search(treeNode* tree, int x) &#123;</span><br><span class="line">	if (tree &#x3D;&#x3D; NULL || tree-&gt;val &#x3D;&#x3D; x)  return tree;</span><br><span class="line">	else if (x &lt; tree-&gt;val) return tree_search(tree-&gt;left, x);</span><br><span class="line">	else</span><br><span class="line">		return tree_search(tree-&gt;right, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找最大-最小结点"><a href="#查找最大-最小结点" class="headerlink" title="查找最大/最小结点"></a>查找最大/最小结点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉搜索树的最大&#x2F;最小结点</span><br><span class="line">treeNode* treeMin(treeNode* tree) &#123;</span><br><span class="line">	if (tree-&gt;left &#x3D;&#x3D; NULL) return tree;</span><br><span class="line">	else return treeMin(tree-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">treeNode* treeMax(treeNode* tree) &#123;</span><br><span class="line">	if (tree-&gt;right &#x3D;&#x3D; NULL) return tree;</span><br><span class="line">	else return treeMax(tree-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后继结点"><a href="#后继结点" class="headerlink" title="后继结点"></a>后继结点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉搜索树的后继结点</span><br><span class="line">treeNode* successor(treeNode* tree) &#123;</span><br><span class="line">	if (tree-&gt;right !&#x3D; NULL) return treeMin(tree-&gt;right);</span><br><span class="line">	treeNode* y &#x3D; tree-&gt;parent;</span><br><span class="line">	while (y !&#x3D; NULL &amp;&amp; y-&gt;left !&#x3D; tree) &#123;</span><br><span class="line">		tree &#x3D; y;</span><br><span class="line">		y &#x3D; tree-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前驱结点"><a href="#前驱结点" class="headerlink" title="前驱结点"></a>前驱结点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉搜索树的前驱结点</span><br><span class="line">treeNode* predecessor(treeNode* tree) &#123;</span><br><span class="line">	if (tree-&gt;left !&#x3D; NULL) return treeMax(tree-&gt;left);</span><br><span class="line">	treeNode* y &#x3D; tree-&gt;parent;</span><br><span class="line">	while (y !&#x3D; NULL &amp;&amp; y-&gt;right !&#x3D; tree) &#123;</span><br><span class="line">		tree &#x3D; y;</span><br><span class="line">		y &#x3D; tree-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉树的结点插入操作实现</span><br><span class="line">treeNode* insert(treeNode* tree, treeNode* node) &#123;</span><br><span class="line">	treeNode* y &#x3D; NULL;		&#x2F;&#x2F;y作为插入结点的父结点</span><br><span class="line">	treeNode* x &#x3D; tree;		&#x2F;&#x2F;x为插入结点的位置</span><br><span class="line">	while (x !&#x3D; NULL) &#123;</span><br><span class="line">		y &#x3D; x;</span><br><span class="line">		if (node-&gt;val &lt; x-&gt;val) x &#x3D; x-&gt;left;</span><br><span class="line">		else x &#x3D; x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	node-&gt;parent &#x3D; y;</span><br><span class="line">	if (y &#x3D;&#x3D; NULL) tree &#x3D; node;</span><br><span class="line">	else if (node-&gt;val &lt; y-&gt;val) y-&gt;left &#x3D; node;</span><br><span class="line">	else y-&gt;right &#x3D; node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移植操作"><a href="#移植操作" class="headerlink" title="移植操作"></a>移植操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉树删除操作中使用的移植操作实现</span><br><span class="line">void transplant(treeNode* tree, treeNode* u, treeNode* v) &#123;</span><br><span class="line">	if (u-&gt;parent &#x3D;&#x3D; NULL) tree &#x3D; v;</span><br><span class="line">	else if (u-&gt;parent-&gt;left &#x3D;&#x3D; u) u-&gt;parent-&gt;left &#x3D; v;</span><br><span class="line">	else u-&gt;parent-&gt;right &#x3D; v;		&#x2F;&#x2F;切断原来的父结点与要被替换的树的联系</span><br><span class="line">	if (v !&#x3D; NULL) v-&gt;parent &#x3D; u-&gt;parent;	&#x2F;&#x2F;最后才将新的树与其父节点连接</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉搜索树的删除操作</span><br><span class="line">void treeDelete(treeNode* tree, treeNode* node) &#123;</span><br><span class="line">	if (node-&gt;left &#x3D;&#x3D; NULL) transplant(tree,node, node-&gt;right);</span><br><span class="line">	else if (node-&gt;right &#x3D;&#x3D; NULL) transplant(tree,node, node-&gt;left);</span><br><span class="line">	else &#123;</span><br><span class="line">		treeNode* y &#x3D; treeMin(node-&gt;right);</span><br><span class="line">		if (y-&gt;parent !&#x3D; node) &#123;		&#x2F;&#x2F;y不是删除结点的孩子时</span><br><span class="line">			transplant(tree, y, y-&gt;right);	&#x2F;&#x2F;先将y独立，用其右孩子将其移植</span><br><span class="line">			y-&gt;right &#x3D; node-&gt;right;</span><br><span class="line">			y-&gt;right-&gt;parent &#x3D; y;</span><br><span class="line">		&#125;</span><br><span class="line">		transplant(tree, node, y);</span><br><span class="line">		y-&gt;left &#x3D; node-&gt;left;		&#x2F;&#x2F;左孩子的拼接</span><br><span class="line">		y-&gt;left-&gt;parent &#x3D; y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法导论</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>//articles/%E5%A0%86%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h2 id="堆排序原理"><a href="#堆排序原理" class="headerlink" title="堆排序原理"></a>堆排序原理</h2><p>首先利用堆的性质维护来建立最大堆，然后不断将最大堆中首元素与尾元素交换，并减少相应的堆中的有效元素数量，再以首元素为标志点进行堆的性质维护</p>
<a id="more"></a>
<p>注意：i的左孩子为2i,右孩子为2i+1,父结点为i/2往下取整<br>这里用的n是元素个数，再通过n来计算下标，而不是直接传下标</p>
<h2 id="堆性质维护算法（C-）"><a href="#堆性质维护算法（C-）" class="headerlink" title="堆性质维护算法（C++）"></a>堆性质维护算法（C++）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;堆的性质维护算法</span><br><span class="line">void max_heapify(int arr[], int n) &#123;</span><br><span class="line">	int left_child, right_child, largest;</span><br><span class="line">	left_child &#x3D; 2 * n;</span><br><span class="line">	right_child &#x3D; 2 * n + 1;</span><br><span class="line">	if (left_child &lt;&#x3D; len &amp;&amp; arr[left_child - 1] &gt; arr[n - 1]) &#123;</span><br><span class="line">		largest &#x3D; left_child;	&#x2F;&#x2F;len表示堆的有效元素数量</span><br><span class="line">	&#125;</span><br><span class="line">	else largest &#x3D; n;</span><br><span class="line">	if (right_child &lt;&#x3D; len &amp;&amp; arr[right_child - 1] &gt; arr[largest - 1]) &#123;</span><br><span class="line">		largest &#x3D; right_child;</span><br><span class="line">	&#125;</span><br><span class="line">	if (largest !&#x3D; n) &#123;</span><br><span class="line">		swap(arr[n - 1], arr[largest - 1]);</span><br><span class="line">		max_heapify(arr, largest);	&#x2F;&#x2F;largest处的值变小了，所以要对他进行维护</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><p>建堆时在n/2处可能交换某个元素，而在n/2-1处三个元素中那个相同的元素却没有被交换，此时元素的相对次序发生改变，所以是不稳定的</p>
<h2 id="建堆（C-）"><a href="#建堆（C-）" class="headerlink" title="建堆（C++）"></a>建堆（C++）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;建立最大堆</span><br><span class="line">void build_max_heap(int arr[], int n) &#123;</span><br><span class="line">	for (int i &#x3D; n &#x2F; 2; i &gt; 0; i--) &#123;</span><br><span class="line">		max_heapify(arr, i);</span><br><span class="line">	&#125;	&#x2F;&#x2F;叶节点集合为A【n&#x2F;2+1---n】，性质维护是从n&#x2F;2到1；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序（C-）"><a href="#堆排序（C-）" class="headerlink" title="堆排序（C++）"></a>堆排序（C++）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;堆排序算法</span><br><span class="line">void heap_sort(int arr[], int n) &#123;</span><br><span class="line">	build_max_heap(arr, n);</span><br><span class="line">	for (int i &#x3D; len; i &gt; 1; i--) &#123;</span><br><span class="line">		swap(arr[0], arr[i-1]);</span><br><span class="line">		len--;	</span><br><span class="line">		max_heapify(arr, 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试-（C-）"><a href="#测试-（C-）" class="headerlink" title="测试 （C++）"></a>测试 （C++）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;测试代码</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void heap_sort(int arr[], int n);</span><br><span class="line">void build_max_heap(int arr[], int n);</span><br><span class="line">void max_heapify(int arr[], int n);</span><br><span class="line">int len;	&#x2F;&#x2F;用一个全局的len来表示有效长度</span><br><span class="line">int main() &#123;</span><br><span class="line">	int arr[] &#x3D; &#123; 1,5,3,11,4,6,7,9,8 &#125;;</span><br><span class="line">	len &#x3D; sizeof(arr) &#x2F; 4;</span><br><span class="line">	heap_sort(arr, len);</span><br><span class="line">	for (auto x : arr) &#123;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法导论</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>//articles/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h2 id="快速排序原理"><a href="#快速排序原理" class="headerlink" title="快速排序原理"></a>快速排序原理</h2><p>首先通过一趟排序将数字分割两半，其中一半的元素全部小于另外一半，然后用同样的方式递归处理两边的数组，直到数组有序</p>
<a id="more"></a>
<h2 id="代码实现（C-）"><a href="#代码实现（C-）" class="headerlink" title="代码实现（C++）"></a>代码实现（C++）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void quickSort(int a[], int low ,int high)</span><br><span class="line">&#123;</span><br><span class="line">	if(low&lt;high)  &#x2F;&#x2F;递归的终止条件，只有数组内元素大于1时才进行排序</span><br><span class="line">	&#123;</span><br><span class="line">		int i &#x3D; low, j &#x3D; high;   </span><br><span class="line">		int x &#x3D; a[low];                                     </span><br><span class="line">		while(i&lt;j)  </span><br><span class="line">		&#123;</span><br><span class="line">		  while(i&lt;j &amp;&amp; a[j] &gt;&#x3D; x) j--;  &#x2F;&#x2F;右边开始，找到不满足条件的j</span><br><span class="line">		  if(i&lt;j) a[i++] &#x3D; a[j];   &#x2F;&#x2F;若此时扫描未完成，将其代替哨兵，哨兵右移</span><br><span class="line">		  while(i&lt;j &amp;&amp; a[i] &lt;&#x3D; x) i++; &#x2F;&#x2F;左边开始，找到不满足条件的i</span><br><span class="line">		  if(i&lt;j) a[j--] &#x3D; a[i];  </span><br><span class="line">		&#125; </span><br><span class="line">	     a[i] &#x3D; x;   </span><br><span class="line">		quickSort(a, low ,i-1);  </span><br><span class="line">		quickSort(a, i+1 ,high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最坏情况下的时间复杂度：O（n^2)<br>平均情况的时间复杂度：O（nLog2n)<br>最好的时间复杂度：O（nLog2n)<br>空间复杂度：  O(Log2n)-O(n)<br>稳定性：不稳定</p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>快速排序的一次划分算法从两头交替搜索，直到low和high重合，因此其时间复杂度是O(n)；而整个快速排序算法的时间复杂度与划分的趟数有关。</p>
<p>理想的情况，每次划分所选择的中间数恰好将当前序列几乎等分，经过logn趟划分，便可得到长度为1的子表。此时，整个算法的时间复杂度为O(nlogn)。 </p>
<p>最坏的情况，每次所选的中间数是当前序列中的最大或最小元素，这使得每次划分所得的子表中一个为空表，另一子表的长度为原表的长度-1。此时，整个排序算法的时间复杂度为O(n^2)。</p>
<p>可以证明，快速排序的平均时间复杂度也是O(nlogn)。因此，该排序方法被认为是目前最好的一种内部排序方法。 </p>
<p>从空间性能上看，尽管快速排序只需要一个元素的辅助空间，但快速排序需要一个栈空间来实现递归。</p>
<p>最好的情况下，即快速排序的每一趟排序都将元素序列均匀地分割成长度相近的两个子表，所需栈的最大深度为log(n+1)；此时空间复杂度为O（logn)<br>但最坏的情况下，栈的最大深度为n。此时，快速排序的空间复杂度为O(n)。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法导论</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>//articles/KMP%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h2 id="分析朴素算法"><a href="#分析朴素算法" class="headerlink" title="分析朴素算法"></a>分析朴素算法</h2><p> 朴素算法在进行扫描的时候每次不匹配都是将A的初始扫描点后移一位，再重新进行扫描，而在这个过程中会有很多没有必要的比对情况出现。比如我们对字符串“REGRET”和“REGROW”，在第一次扫描失配的时候，我们就已经知道<code>A[1]</code>必然不等于<code>B[0]</code>，那么就没有必要再进行这两个字符的比对了</p>
<a id="more"></a>
<p>想象A上B下进行比对，此时我们就应该跳过<code>A[1]</code>跟<code>B[0]</code>这样已经知道结果的比对。既然我们知道了<code>A[3]=B[0]</code>,那么我们再继续比对<code>A[4]</code>和<code>B[1]</code>就OK了</p>
<h2 id="KMP算法思想"><a href="#KMP算法思想" class="headerlink" title="KMP算法思想"></a>KMP算法思想</h2><p> A字符串的扫描位置不断后移，而B字符串的扫描位置 j 若是不匹配就寻找下一个 j 进行比对， 这次比对是对从失配的A[ i ]开始的，我们就要找到B[ j ]（失配位置）前面子串的前后两个相等的两个真子串，比如B串中子串“REGR”的前后两个相等的真子串就是”R“，然后将B串右移使得A[ i ] 前面的子串跟B[next[ j ] ] （此时即为B[1]）前面的子串匹配，再开始进行比对</p>
<h2 id="构造next表"><a href="#构造next表" class="headerlink" title="构造next表"></a>构造next表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* BuildNext(string B) &#123;</span><br><span class="line">	int n &#x3D; B.size(), j &#x3D; 0;</span><br><span class="line">	int* N &#x3D; new int[n];</span><br><span class="line">	int t &#x3D; N[0] &#x3D; -1;	&#x2F;&#x2F;这里记得先初始化N[0]为-1；</span><br><span class="line">	while (j &lt; n - 1) &#123;	&#x2F;&#x2F;这里不取最后一个元素是因为讨论的是“当前元素不匹配，然后要找前面的子串自匹配的情况，然后找到下一个j值</span><br><span class="line">		if (t &lt; 0||B[j] &#x3D;&#x3D; B[t] ) &#123;		&#x2F;&#x2F;注意这里的短路求值</span><br><span class="line">			j++; t++;</span><br><span class="line">			N[j] &#x3D; t;		&#x2F;&#x2F;此代码可以优化</span><br><span class="line">		&#125;</span><br><span class="line">		else t &#x3D; N[t];</span><br><span class="line">	&#125;</span><br><span class="line">	return N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="next表构造优化"><a href="#next表构造优化" class="headerlink" title="next表构造优化"></a>next表构造优化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* BuildNext(string B) &#123;</span><br><span class="line">	int n &#x3D; B.size(), j &#x3D; 0;</span><br><span class="line">	int* N &#x3D; new int[n];</span><br><span class="line">	int t &#x3D; N[0] &#x3D; -1;	</span><br><span class="line">	while (j &lt; n - 1) &#123;</span><br><span class="line">		if (t &lt; 0||B[j] &#x3D;&#x3D; B[t] ) &#123;	</span><br><span class="line">			j++; t++;</span><br><span class="line">			N[j] &#x3D; (B[j] !&#x3D; B[t]) ? t : N[t];	&#x2F;&#x2F;修改了next表的定义</span><br><span class="line">		&#125;	&#x2F;&#x2F;最后的元素不与之前匹配失败的元素相等</span><br><span class="line">		else t &#x3D; N[t];</span><br><span class="line">	&#125;</span><br><span class="line">	return N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KMP主算法"><a href="#KMP主算法" class="headerlink" title="KMP主算法"></a>KMP主算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;KMP主算法 O（m) 模式串长度</span><br><span class="line">int match(string A, string B) &#123;</span><br><span class="line">	int m &#x3D; A.size();</span><br><span class="line">	int n &#x3D; B.size();</span><br><span class="line">	int i &#x3D; 0, j &#x3D; 0;</span><br><span class="line">	while (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">		if ( j &lt; 0 || A[i] &#x3D;&#x3D; B[j]) &#123;	</span><br><span class="line">			i++; j++;</span><br><span class="line">		&#125;</span><br><span class="line">		else j &#x3D; next[j];</span><br><span class="line">	&#125;</span><br><span class="line">	delete[ ] next;</span><br><span class="line">	return i - j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O（n+m）</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法导论</category>
        <category>字符串匹配</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素字符串匹配算法</title>
    <url>//articles/%E6%9C%B4%E7%B4%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定两个字符串A和B，我们要判断A中是否包含B，并找到A与B相等的第一个位置下标</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>我们将两个字符串都从头开始扫描，然后若是扫描的两个位置字符相同，则两个字符串继续往后扫描。若是扫描的位置字符不相同，那么我们就将字符串B从头开始扫描，而字符串A就从刚才扫描它的初始位置往后挪一位接着扫描</p>
<a id="more"></a>
<h2 id="算法实现（C-）"><a href="#算法实现（C-）" class="headerlink" title="算法实现（C++）"></a>算法实现（C++）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;朴素字符串匹配算法</span><br><span class="line">int match(string A, string B) &#123;</span><br><span class="line">	int m &#x3D; A.size(), i &#x3D; 0;</span><br><span class="line">	int n &#x3D; B.size(), j &#x3D; 0;</span><br><span class="line">	while (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">		if (A[i] &#x3D;&#x3D; B[j]) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;	&#x2F;&#x2F;若匹配，两个字符串同时往后扫描</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			i &#x3D; i-j+1;	&#x2F;&#x2F;字符串A扫描回到原点并后移一位</span><br><span class="line">			j &#x3D; 0;		&#x2F;&#x2F;重置字符串B的扫描</span><br><span class="line">		&#125;</span><br><span class="line">		return i - j;	&#x2F;&#x2F;若值大于m-n时不存在匹配</span><br><span class="line">	&#125;                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>朴素算法至多迭代m-n+1轮，各轮至多n次比对，因n&gt;&gt;m，所以其时间复杂度为O（nm)</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法导论</category>
        <category>字符串匹配</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>//articles/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<h2 id="插入排序的原理"><a href="#插入排序的原理" class="headerlink" title="插入排序的原理"></a>插入排序的原理</h2><p>插入排序其实就像是我们平时玩扑克牌时的取牌操作，初始时我们手中没有任何牌，拿到第一张牌之后自然就不用做任何的移动操作。接着我们继续拿到牌，将每次新拿到的牌跟前面（已排序）的牌依次进行对比，然后将之放到正确的位置上。</p>
<a id="more"></a>
<h2 id="插入排序的实现（C"><a href="#插入排序的实现（C" class="headerlink" title="插入排序的实现（C++)"></a>插入排序的实现（C++)</h2><p>按照原理我们首先实现直接插入排序（直插法）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;直插法</span><br><span class="line">void insertSort(int arr[], int n)</span><br><span class="line">&#123;	&#x2F;&#x2F;假设我们手中已经有第一张牌</span><br><span class="line">	for (int j &#x3D; 1; j &lt; n; ++j)</span><br><span class="line">	&#123;	</span><br><span class="line">		int key &#x3D;arr[j];	&#x2F;&#x2F;保留新拿到的牌值</span><br><span class="line">		int i &#x3D; j - 1;		&#x2F;&#x2F;新牌前面待对比的牌下标</span><br><span class="line">		while(i&gt;&#x3D;0&amp;&amp;key&lt;arr[i])	</span><br><span class="line">		&#123;		&#x2F;&#x2F;当key小时不断对前面比它大的元素往后移动</span><br><span class="line">			arr[i+1] &#x3D; arr[i];</span><br><span class="line">			--i;		&#x2F;&#x2F;然后继续循环对比前面一个元素</span><br><span class="line">		&#125;		&#x2F;&#x2F;当i的元素值大于key或i&#x3D;-1时退出循环</span><br><span class="line">		arr[i+1] &#x3D; key;		&#x2F;&#x2F;最后i+1即为该新牌的位置下标</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>最好情况：数组已经有序，此时只需要进行n-1次比较，时间复杂度为O（n）;</p>
<p>最坏情况是数组逆序排序，此时需要进行n(n-1)/2次比较以及n-1次赋值操作（插入）；</p>
<p>平均来说插入排序算法的复杂度为O(n^2)。</p>
<p>直接插入排序采用就地排序（in-place)，空间复杂度为O（1）</p>
<h3 id="插入排序使用时机"><a href="#插入排序使用时机" class="headerlink" title="插入排序使用时机"></a>插入排序使用时机</h3><p>不适合对大量数据进行排序应用，但排序数量级小于1000时插入排序的效率还不错，可以考虑使用。</p>
<h2 id="二分法插入排序"><a href="#二分法插入排序" class="headerlink" title="二分法插入排序"></a>二分法插入排序</h2><p>直插法每次都是将新牌的值与前面的序列元素依次对比，那么我们能不能更快地确定新牌的位置呢？<br>答案当然是有的，由于我们当前手中的牌都是已经牌好序的，那么我们就可以通过直接跟当前牌最中间的牌值进行比较，然后就可以进一步确定牌的位置</p>
<h3 id="二分插入法的实现（C-）"><a href="#二分插入法的实现（C-）" class="headerlink" title="二分插入法的实现（C++）"></a>二分插入法的实现（C++）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二插法找到该新牌的位置</span><br><span class="line">int BinarySearch(int array[], int start, int end, int key)</span><br><span class="line">&#123;</span><br><span class="line">    while (start &lt;&#x3D; end)</span><br><span class="line">    &#123;</span><br><span class="line">        int middle &#x3D; (start + end) &#x2F; 2;</span><br><span class="line">        int middleData &#x3D; array[middle];</span><br><span class="line">        if (middleData &gt; key)</span><br><span class="line">            end &#x3D; middle - 1;</span><br><span class="line">        else</span><br><span class="line">            start &#x3D; middle + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return start;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;总的实现函数，找到位置后进行元素移动</span><br><span class="line">void BinaryInsertSort(int array[], int n)</span><br><span class="line">&#123;		判断数组是否需要排序</span><br><span class="line">    if (array &#x3D;&#x3D; NULL || n &lt; 0)</span><br><span class="line">        return;</span><br><span class="line">    int i, j;</span><br><span class="line">    for (i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">    &#123;		&#x2F;&#x2F;确认该新牌需要移动</span><br><span class="line">        if (array[i]&lt;array[i - 1])</span><br><span class="line">        &#123;</span><br><span class="line">            int temp &#x3D; array[i];	&#x2F;&#x2F;提前保存新牌的值</span><br><span class="line">            int insertIndex &#x3D; BinarySearch(array,0,i,array[i]);</span><br><span class="line">            for (j &#x3D; i - 1; j&gt;&#x3D;insertIndex; j--) &#x2F;&#x2F;将比新牌值大的元素后移</span><br><span class="line">                array[j + 1] &#x3D; array[j];        </span><br><span class="line">            array[insertIndex] &#x3D; temp;    &#x2F;&#x2F;最后插入元素</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>这个二分查找的算法并不会因为等于某一个值而停止查找，它将查找整个序列直到start&lt;=end条件不满足而得到插入的位置，所以对于长度为n的数组来说，比较次数为log2n ,时间复杂度为O（log2n）。二分插入排序的主要操作为比较+后移赋值，则：<br>最坏情况：每次都在有序序列的起始位置插入，则整个有序序列的元素需要后移，时间复杂度为O（n^2）</p>
<p>最好情况：待排序数组本身就是正序的，每个元素所在位置即为它的插入位置，此时时间复杂度仅为比较时的时间复杂度，为O(log2n)</p>
<p>平均情况：O（n^2）</p>
<p>空间复杂度上， 二分插入排序也是就地排序算法，它的空间复杂度为O（1）.</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法导论</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
</search>

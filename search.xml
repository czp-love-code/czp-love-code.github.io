<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>红黑树</title>
    <url>/2019/12/08/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h2><p>每个结点非红即黑，根结点和叶结点为黑色<br>红结点的孩子都是黑结点<br>对每个结点，从该结点到所有后代叶结点的简单路径上，均包含相同数目的黑结点</p>
<a id="more"></a>
<h2 id="左旋转操作"><a href="#左旋转操作" class="headerlink" title="左旋转操作"></a>左旋转操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void RBTree::RotateLeft(RBTreeNode* Node) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	RBTreeNode* RNode &#x3D; Node-&gt;right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Node-&gt;right &#x3D; RNode-&gt;left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (RNode-&gt;left !&#x3D; NULL) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		RNode-&gt;left-&gt;parent &#x3D; Node;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	RNode-&gt;parent&#x3D;Node-&gt;parent; </span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (Node-&gt;parent &#x3D;&#x3D; nil) root &#x3D; RNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else if (Node-&gt;parent-&gt;left &#x3D;&#x3D; Node) Node-&gt;parent-&gt;left &#x3D; RNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else Node-&gt;parent-&gt;right &#x3D; RNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	RNode-&gt;left &#x3D; Node;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Node-&gt;parent &#x3D; RNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="右旋转操作"><a href="#右旋转操作" class="headerlink" title="右旋转操作"></a>右旋转操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void RBTree::RotateRight(RBTreeNode* Node) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	RBTreeNode* LNode &#x3D; Node-&gt;left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Node-&gt;left &#x3D; LNode-&gt;right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (LNode-&gt;right !&#x3D; NULL) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		LNode-&gt;right-&gt;parent &#x3D; Node;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	LNode-&gt;parent &#x3D; Node-&gt;parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (Node-&gt;parent &#x3D;&#x3D; nil) root &#x3D; LNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else if (Node-&gt;parent-&gt;left &#x3D;&#x3D; Node) Node-&gt;parent-&gt;left &#x3D; LNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else Node-&gt;parent-&gt;right &#x3D; LNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	LNode-&gt;right &#x3D; Node;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Node-&gt;parent &#x3D; LNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>//注意：旋转操作中如果旋转结点为红色，且其父结点也是红色，那么旋转之后不会破坏红黑树的最后一条性质</p>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void RBTree::Insert(RBTreeNode* root,RBTreeNode* NNode) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	RBTreeNode* PNode &#x3D; nil;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	RBTreeNode* TempNode &#x3D; root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	while (TempNode !&#x3D; NULL) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		PNode &#x3D; TempNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (val &lt; TempNode-&gt;val) TempNode &#x3D; TempNode-&gt;left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		else TempNode &#x3D; TempNode-&gt;right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	NNode-&gt;parent &#x3D; PNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (PNode &#x3D;&#x3D; nil) root &#x3D; NNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else if (val &lt; PNode-&gt;val) PNode-&gt;left &#x3D; NNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else PNode-&gt;right &#x3D; NNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	NNode-&gt;color&#x3D;RED;&#x2F;&#x2F;记得将插入结点的颜色设为红色</span></pre></td></tr><tr><td class="code"><pre><span class="line">	InsertFixup(NNode);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="插入的性质修复"><a href="#插入的性质修复" class="headerlink" title="插入的性质修复"></a>插入的性质修复</h2><p>因为插入操作中将插入结点设置为红色，就不会破坏红黑树的最后一条性质，即每个结点到叶结点的简单路径上黑色结点树相同。那么此时若是插入结点的父结点为红色，就会破坏一条红黑树的性质，即红结点的孩子结点都是黑色，只要围绕这条性质来修复即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void RBTree::InsertFixup(RBTreeNode* Node) &#123;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	while (Node-&gt;parent-&gt;color &#x3D;&#x3D; RED) &#123;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (Node-&gt;parent-&gt;parent-&gt;left &#x3D;&#x3D; Node-&gt;parent) &#123;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">			RBTreeNode* UNode &#x3D; Node-&gt;parent-&gt;parent-&gt;right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			if (UNode-&gt;color &#x3D;&#x3D; RED) &#123;		</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node-&gt;parent-&gt;color &#x3D; BLACK;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">				UNode-&gt;color &#x3D; BLACK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node-&gt;parent-&gt;parent &#x3D; RED;		</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node &#x3D; Node-&gt;parent-&gt;parent;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">			else if (Node &#x3D; Node-&gt;parent-&gt;right) &#123;&#x2F;&#x2F;两个结点弄一边</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node &#x3D; Node-&gt;parent;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">				RotateLeft(Node);		</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Node-&gt;parent-&gt;color &#x3D; BLACK;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Node-&gt;parent-&gt;parent-&gt;color &#x3D; RED;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">			RotateRight(Node-&gt;parent-&gt;parent);		&#x2F;&#x2F;爷结点右转,带动染黑的父结点上移，维护性质</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		else &#123;		</span></pre></td></tr><tr><td class="code"><pre><span class="line">			RBTreeNode* UNode &#x3D; Node-&gt;parent-&gt;parent-&gt;left;		</span></pre></td></tr><tr><td class="code"><pre><span class="line">			if (UNode-&gt;color &#x3D;&#x3D; RED) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				UNode-&gt;color &#x3D; BLACK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node-&gt;parent-&gt;color &#x3D; BLACK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node-&gt;parent-&gt;parent-&gt;color &#x3D; RED;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node &#x3D; Node-&gt;parent-&gt;parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			else if (Node-&gt;parent-&gt;left &#x3D; Node) &#123;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node &#x3D; Node-&gt;parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				RotateRight(Node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Node-&gt;parent-&gt;color &#x3D; BLACK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Node-&gt;parent-&gt;parent-&gt;color &#x3D; RED;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			RotateLeft(Node-&gt;parent-&gt;parent);	</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		root-&gt;color &#x3D; BLACK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>核心思想：将破坏性质的红色结点（即插入结点的父结点）层层上移直到根，最后然染黑即可</p>
<h2 id="移植操作"><a href="#移植操作" class="headerlink" title="移植操作"></a>移植操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void RBTree::Transplant(RBTreeNode* Tree, RBTreeNode* GoneTree, RBTreeNode* NewTree) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (GoneTree-&gt;parent &#x3D;&#x3D; nil) </span></pre></td></tr><tr><td class="code"><pre><span class="line">		root &#x3D; NewTree;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else if (GoneTree &#x3D;&#x3D; GoneTre                                        e-&gt;parent-&gt;left) </span></pre></td></tr><tr><td class="code"><pre><span class="line">		GoneTree-&gt;parent-&gt;left &#x3D; NewTree;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else GoneTree-&gt;parent-&gt;right &#x3D; NewTree;		</span></pre></td></tr><tr><td class="code"><pre><span class="line">	NewTree-&gt;parent &#x3D; GoneTree-&gt;parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RBTreeNode* RBTree::DeleteNode(RBTreeNode* root,RBTreeNode* Node) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	RBTreeNode* DNode &#x3D; Node;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	RBTreeNode* NNode &#x3D; nil;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	RBTreeNode* TempNode &#x3D; nil;		</span></pre></td></tr><tr><td class="code"><pre><span class="line">	TempNode-&gt;color &#x3D; Node-&gt;color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (Node-&gt;left &#x3D;&#x3D; nil) &#123;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">		NNode &#x3D; Node-&gt;right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Transplant(root, Node, Node-&gt;right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else if (Node-&gt;right &#x3D;&#x3D; nil) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		NNode &#x3D; Node-&gt;left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Transplant(root, Node, Node-&gt;left);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else &#123;		</span></pre></td></tr><tr><td class="code"><pre><span class="line">		DNode &#x3D; Minimum(Node-&gt;right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		TempNode-&gt;color &#x3D; DNode-&gt;color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		NNode &#x3D; DNode-&gt;right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (DNode-&gt;parent !&#x3D; Node) &#123;		</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Transplant(root, DNode, DNode-&gt;right);	</span></pre></td></tr><tr><td class="code"><pre><span class="line">			DNode-&gt;right &#x3D; Node-&gt;right;		</span></pre></td></tr><tr><td class="code"><pre><span class="line">			Node-&gt;right-&gt;parent &#x3D; DNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Transplant(root, Node, DNode);	</span></pre></td></tr><tr><td class="code"><pre><span class="line">		DNode-&gt;left &#x3D; Node-&gt;left;		</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Node-&gt;left-&gt;parent &#x3D; DNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		DNode-&gt;color &#x3D; Node-&gt;color;		</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (TempNode-&gt;color &#x3D;&#x3D; BLACK) DeleteFixup(NNode);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return DNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="删除操作的性质修复"><a href="#删除操作的性质修复" class="headerlink" title="删除操作的性质修复"></a>删除操作的性质修复</h2><p>赋予破坏红黑树性质的结点双色属性，然后致力于将这种双色属性消除，主要是使得兄弟结点的颜色是黑色，并且其右孩子的颜色是红色，在这种情况下就可以消除掉双色结点的双色属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void RBTree::DeleteFixup(RBTreeNode* Node) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	while (Node !&#x3D; root &amp;&amp; Node-&gt;color &#x3D;&#x3D; BLACK) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (Node &#x3D; Node-&gt;parent-&gt;left) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			RBTreeNode* BNode &#x3D; Node-&gt;right;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">			if (BNode-&gt;color &#x3D;&#x3D; RED) &#123;&#x2F;&#x2F;换个兄弟结点</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode-&gt;color &#x3D; BLACK;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node-&gt;parent-&gt;color &#x3D; RED;		</span></pre></td></tr><tr><td class="code"><pre><span class="line">				RotateLeft(Node-&gt;parent);		</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode &#x3D; Node-&gt;parent-&gt;right;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			if (BNode-&gt;left-&gt;color &#x3D;&#x3D; BLACK &amp;&amp; BNode-&gt;right-&gt;color &#x3D;&#x3D; BLACK) &#123;	&#x2F;&#x2F;双色结点上移</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode-&gt;color &#x3D; RED;		</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node &#x3D; Node-&gt;parent;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			else if (BNode-&gt;right-&gt;color &#x3D;&#x3D; BLACK) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#x2F;&#x2F;换兄弟，使兄弟为黑，其右孩子为红</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode-&gt;left-&gt;color &#x3D; BLACK;		</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode-&gt;color &#x3D; RED;			</span></pre></td></tr><tr><td class="code"><pre><span class="line">				RotateRight(BNode);		</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode &#x3D; Node-&gt;parent-&gt;right;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode-&gt;color &#x3D; Node-&gt;parent-&gt;color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node-&gt;parent-&gt;color &#x3D; BLACK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode-&gt;right-&gt;color &#x3D; BLACK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				RotateLeft(Node-&gt;parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node &#x3D; root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			RBTreeNode* BNode &#x3D; Node-&gt;parent-&gt;left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			if (BNode-&gt;color &#x3D; RED) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode-&gt;color &#x3D; BLACK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node-&gt;parent-&gt;color &#x3D; RED;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				RotateRight(Node-&gt;parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode &#x3D; Node-&gt;parent-&gt;left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			else if (BNode-&gt;left-&gt;color &#x3D;&#x3D; BLACK &amp;&amp; BNode-&gt;right-&gt;color &#x3D;&#x3D; BLACK) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode-&gt;color &#x3D; RED;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node &#x3D; Node-&gt;parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			else if (BNode-&gt;left-&gt;color &#x3D;&#x3D; BLACK) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode-&gt;right-&gt;color &#x3D; BLACK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode-&gt;color &#x3D; RED;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				RotateLeft(BNode);</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode &#x3D; Node-&gt;parent-&gt;left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode-&gt;color &#x3D; Node-&gt;parent-&gt;color;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node-&gt;parent-&gt;color &#x3D; BLACK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				BNode-&gt;left-&gt;color &#x3D; BLACK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				RotateRight(Node-&gt;parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">				Node &#x3D; root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Node-&gt;color &#x3D; BLACK;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>QT02</title>
    <url>/2019/12/08/QT02/</url>
    <content><![CDATA[<h2 id="对象树"><a href="#对象树" class="headerlink" title="对象树"></a>对象树</h2><p>当创建的对象在堆区的时候，如果指定的父亲是QObject继承体系中的类，可以不用管理释放的操作，创建的对象会添加到对象树中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">btn-&gt;setParent(this);</span></pre></td></tr></table></figure>
<a id="more"></a>
<p>为创建的QObject对象提供一个父对象，会自动将其添加到其父对象的children()列表，当父对象析构的时候，这个列表中的所有对象也会被析构<br>因此在一定程度上简化了内存回收机制</p>
<h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><p>连接函数：connect(断开连接用disconnect）<br>参数：信号的发送者，发送的信号（函数地址)，信号的接收者，处理的槽函数（函数地址）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connect(myBtn,&amp;QPushButton::clicked,this,&amp;QWidget::close);</span></pre></td></tr><tr><td class="code"><pre><span class="line">connect(myBtn,&amp;MyPushButton::clicked,this,&amp;MyWidget::close);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;信号的接收方如果是this的话可以省略</span></pre></td></tr></table></figure>
<h2 id="自定义信号和槽"><a href="#自定义信号和槽" class="headerlink" title="自定义信号和槽"></a>自定义信号和槽</h2><p>自定义信号：写到signals下，返回void，需要声明但不需要实现，可以有参数也可以重载（触发信号使用emit）<br>自定义槽函数：写到public slots下或public或全局函数，返回void，需要声明也需要实现，可以有参数也可以重载<br>注意：当函数发生重载时，在connect中要用函数指针指向具体函数，信号函数和槽函数的参数类型要匹配，信号函数的参数可以多于槽函数的参数，但第一个参数类型要匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void(Teacher::*teacherSignal)(QString)&#x3D;&amp;Teacher::hungry;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void(Student::*studentSlot)(QString)&#x3D;&amp;Student::treat;</span></pre></td></tr><tr><td class="code"><pre><span class="line">connect(zt,teacherSignal,st,StudentSlot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">classIsOver();</span></pre></td></tr></table></figure>
<h2 id="QString转char"><a href="#QString转char" class="headerlink" title="QString转char *"></a>QString转char *</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Student::treat(QString foodName)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;先转为QByteArray再转为char *</span></pre></td></tr><tr><td class="code"><pre><span class="line">	qDebug()&lt;&lt;&quot;请吃饭，要吃：&quot;&lt;&lt;foodName.toUtf8().data();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>学习笔记</category>
        <category>QT使用</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2019/12/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>二叉搜索树的原理无非就是左孩子的值小于等于父节点，右孩子的值大于等于父节点，所有的操作都是围绕这个原理来实现的<br>随机构造一棵二叉搜索树的期望高度为O（lg n），因此二叉搜索树上的动态集合的基本操作平均运行时间为（lg n）</p>
<a id="more"></a>
<h2 id="实现（C-）"><a href="#实现（C-）" class="headerlink" title="实现（C++）"></a>实现（C++）</h2><h3 id="结点的结构体定义"><a href="#结点的结构体定义" class="headerlink" title="结点的结构体定义"></a>结点的结构体定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉树的结点的结构体定义</span></pre></td></tr><tr><td class="code"><pre><span class="line">struct treeNode &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	treeNode* left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	treeNode* right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	treeNode* parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	treeNode(int x) :val(x),left(NULL),right(NULL),parent(NULL)&#123;   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<h3 id="搜索操作"><a href="#搜索操作" class="headerlink" title="搜索操作"></a>搜索操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉树的搜索操作实现</span></pre></td></tr><tr><td class="code"><pre><span class="line">treeNode* tree_search(treeNode* tree, int x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (tree &#x3D;&#x3D; NULL || tree-&gt;val &#x3D;&#x3D; x)  return tree;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else if (x &lt; tree-&gt;val) return tree_search(tree-&gt;left, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else</span></pre></td></tr><tr><td class="code"><pre><span class="line">		return tree_search(tree-&gt;right, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="查找最大-最小结点"><a href="#查找最大-最小结点" class="headerlink" title="查找最大/最小结点"></a>查找最大/最小结点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉搜索树的最大&#x2F;最小结点</span></pre></td></tr><tr><td class="code"><pre><span class="line">treeNode* treeMin(treeNode* tree) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (tree-&gt;left &#x3D;&#x3D; NULL) return tree;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else return treeMin(tree-&gt;left);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">treeNode* treeMax(treeNode* tree) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (tree-&gt;right &#x3D;&#x3D; NULL) return tree;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else return treeMax(tree-&gt;right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="后继结点"><a href="#后继结点" class="headerlink" title="后继结点"></a>后继结点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉搜索树的后继结点</span></pre></td></tr><tr><td class="code"><pre><span class="line">treeNode* successor(treeNode* tree) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (tree-&gt;right !&#x3D; NULL) return treeMin(tree-&gt;right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	treeNode* y &#x3D; tree-&gt;parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	while (y !&#x3D; NULL &amp;&amp; y-&gt;left !&#x3D; tree) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		tree &#x3D; y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		y &#x3D; tree-&gt;parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="前驱结点"><a href="#前驱结点" class="headerlink" title="前驱结点"></a>前驱结点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉搜索树的前驱结点</span></pre></td></tr><tr><td class="code"><pre><span class="line">treeNode* predecessor(treeNode* tree) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (tree-&gt;left !&#x3D; NULL) return treeMax(tree-&gt;left);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	treeNode* y &#x3D; tree-&gt;parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	while (y !&#x3D; NULL &amp;&amp; y-&gt;right !&#x3D; tree) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		tree &#x3D; y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		y &#x3D; tree-&gt;parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉树的结点插入操作实现</span></pre></td></tr><tr><td class="code"><pre><span class="line">treeNode* insert(treeNode* tree, treeNode* node) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	treeNode* y &#x3D; NULL;		&#x2F;&#x2F;y作为插入结点的父结点</span></pre></td></tr><tr><td class="code"><pre><span class="line">	treeNode* x &#x3D; tree;		&#x2F;&#x2F;x为插入结点的位置</span></pre></td></tr><tr><td class="code"><pre><span class="line">	while (x !&#x3D; NULL) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		y &#x3D; x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (node-&gt;val &lt; x-&gt;val) x &#x3D; x-&gt;left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		else x &#x3D; x-&gt;right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	node-&gt;parent &#x3D; y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (y &#x3D;&#x3D; NULL) tree &#x3D; node;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else if (node-&gt;val &lt; y-&gt;val) y-&gt;left &#x3D; node;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else y-&gt;right &#x3D; node;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="移植操作"><a href="#移植操作" class="headerlink" title="移植操作"></a>移植操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉树删除操作中使用的移植操作实现</span></pre></td></tr><tr><td class="code"><pre><span class="line">void transplant(treeNode* tree, treeNode* u, treeNode* v) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (u-&gt;parent &#x3D;&#x3D; NULL) tree &#x3D; v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else if (u-&gt;parent-&gt;left &#x3D;&#x3D; u) u-&gt;parent-&gt;left &#x3D; v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else u-&gt;parent-&gt;right &#x3D; v;		&#x2F;&#x2F;切断原来的父结点与要被替换的树的联系</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (v !&#x3D; NULL) v-&gt;parent &#x3D; u-&gt;parent;	&#x2F;&#x2F;最后才将新的树与其父节点连接</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉搜索树的删除操作</span></pre></td></tr><tr><td class="code"><pre><span class="line">void treeDelete(treeNode* tree, treeNode* node) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (node-&gt;left &#x3D;&#x3D; NULL) transplant(tree,node, node-&gt;right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else if (node-&gt;right &#x3D;&#x3D; NULL) transplant(tree,node, node-&gt;left);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		treeNode* y &#x3D; treeMin(node-&gt;right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (y-&gt;parent !&#x3D; node) &#123;		&#x2F;&#x2F;y不是删除结点的孩子时</span></pre></td></tr><tr><td class="code"><pre><span class="line">			transplant(tree, y, y-&gt;right);	&#x2F;&#x2F;先将y独立，用其右孩子将其移植</span></pre></td></tr><tr><td class="code"><pre><span class="line">			y-&gt;right &#x3D; node-&gt;right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			y-&gt;right-&gt;parent &#x3D; y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		transplant(tree, node, y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		y-&gt;left &#x3D; node-&gt;left;		&#x2F;&#x2F;左孩子的拼接</span></pre></td></tr><tr><td class="code"><pre><span class="line">		y-&gt;left-&gt;parent &#x3D; y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>QT01</title>
    <url>/2019/12/07/QT01/</url>
    <content><![CDATA[<h2 id="QT简介"><a href="#QT简介" class="headerlink" title="QT简介"></a>QT简介</h2><h3 id="什么是QT"><a href="#什么是QT" class="headerlink" title="什么是QT"></a>什么是QT</h3><p>一个跨平台的C++图形用户界面应用程序框架，面对对象且容易扩展，允许真正的组件编程<br>图形用户界面：GUI，采用图形方式显示的计算机操作用户界面</p>
<a id="more"></a>
<h3 id="QT的优点"><a href="#QT的优点" class="headerlink" title="QT的优点"></a>QT的优点</h3><p>跨平台，简化了内存回收机制，开发效率高，可以进行嵌入式开发</p>
<h3 id="创建QT"><a href="#创建QT" class="headerlink" title="创建QT"></a>创建QT</h3><p>名称不能有中文和空格，保存路径不能有中文路径<br>默认创建有窗口类：myWidget<br>基类有三种选择：QWidget,QMainWindow,QDialog</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;widget.h&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;QApplication&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;程序入口</span></pre></td></tr><tr><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    QApplication a(argc, argv);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Widget w;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w.show();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return a.exec();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>argc:命令行变量的数量<br>argv:命令行变量的数组<br>QApplication a:应用程序对象，有且仅有一个<br>maWidget w:实例化窗口对象<br>w.show():调用show函数，显示窗口<br>return a.exec():让应用程序进入消息循环机制，代码阻塞到当前行</p>
<h3 id="widget头文件"><a href="#widget头文件" class="headerlink" title="widget头文件"></a>widget头文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef WIDGET_H</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define WIDGET_H</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;QWidget&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Widget : public QWidget</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Q_OBJECT	&#x2F;&#x2F;宏，允许类中使用信号和槽的机制</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Widget(QWidget *parent &#x3D; nullptr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Widget();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif &#x2F;&#x2F; WIDGET_H</span></pre></td></tr></table></figure>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>注释：ctrl+/<br>查找：ctrl+f<br>整行移动：ctrl+shift+上下<br>帮助文档：F1<br>自动对齐：ctrl+i<br>同名文件切换：F4</p>
<h3 id="按钮空间常用API"><a href="#按钮空间常用API" class="headerlink" title="按钮空间常用API"></a>按钮空间常用API</h3><p>什么是API：Application Programming Interface ，应用程序接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;widget.h&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;QPushButton&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Widget::Widget(QWidget *parent)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    : QWidget(parent)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;创建一个按钮</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; QPushButton *btn&#x3D;new QPushButton;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; &#x2F;&#x2F;btn-&gt;show();&#x2F;&#x2F;以顶层方式弹出窗口控件</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; &#x2F;&#x2F;让btn对象依赖在widget窗口</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; btn-&gt;setParent(this);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; &#x2F;&#x2F;设置文本</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; btn-&gt;setText(&quot;第一个按钮&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#x2F;&#x2F;创建第二个按钮,按照控件大小创建窗口</span></pre></td></tr><tr><td class="code"><pre><span class="line">    QPushButton *btn&#x3D;new QPushButton(&quot;第二个按钮&quot;,this);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;设置窗口大小</span></pre></td></tr><tr><td class="code"><pre><span class="line">    resize(600,400);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;设置固定窗口大小</span></pre></td></tr><tr><td class="code"><pre><span class="line">    setFixedSize(600,400);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;移动按钮</span></pre></td></tr><tr><td class="code"><pre><span class="line">    btn-&gt;move(100,100);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;设置窗口标题</span></pre></td></tr><tr><td class="code"><pre><span class="line">    setWindowTitle(&quot;第一个窗口&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>学习笔记</category>
        <category>QT使用</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 19(下)</title>
    <url>/2019/12/05/C++%20Primer%2019(%E4%B8%8B)/</url>
    <content><![CDATA[<h2 id="成员指针"><a href="#成员指针" class="headerlink" title="成员指针"></a>成员指针</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义</span></pre></td></tr><tr><td class="code"><pre><span class="line">auto pdata&#x3D;&amp;Screen::contents;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;解引用</span></pre></td></tr><tr><td class="code"><pre><span class="line">auto s&#x3D;myScreen.*pdata;</span></pre></td></tr><tr><td class="code"><pre><span class="line">s&#x3D;pScreen-&gt;*pdata;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;指向const限定的成员函数</span></pre></td></tr><tr><td class="code"><pre><span class="line">char(Screen::*pmf2)(Screen::pos,Screen::pos)const;</span></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="使用指针"><a href="#使用指针" class="headerlink" title="使用指针"></a>使用指针</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c1&#x3D;(my.Screen.*pmf1)(0,0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">char c2&#x3D;(pScreen-&gt;*pmf2)();</span></pre></td></tr></table></figure>
<h3 id="使用类型别名"><a href="#使用类型别名" class="headerlink" title="使用类型别名"></a>使用类型别名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using Action&#x3D;char(Screen::*)(Screen::pos,Screen::pos)const;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Action get&#x3D;&amp;Screen::get;</span></pre></td></tr></table></figure>
<p>当成员函数指针用于形参的时候可以指定默认实参</p>
<h3 id="使用函数表"><a href="#使用函数表" class="headerlink" title="使用函数表"></a>使用函数表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Directions&#123;-------&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Screen&amp; move(Directions);</span></pre></td></tr><tr><td class="code"><pre><span class="line">static Action Menu[];</span></pre></td></tr><tr><td class="code"><pre><span class="line">Screen&amp; Screen::move(Directions cm)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return (this-&gt;*Menu[cm])();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Screen::Action Screen::Menu[]&#x3D;&#123;----------&#125;;</span></pre></td></tr></table></figure>
<h3 id="成员指针与可调用对象"><a href="#成员指针与可调用对象" class="headerlink" title="成员指针与可调用对象"></a>成员指针与可调用对象</h3><p>成员指针不是可调用对象，不能将其传递给算法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用function获取可调用对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">function&lt;bool(const string&amp;)&gt;fcn&#x3D;&amp;string::empty;</span></pre></td></tr></table></figure>
<h3 id="使用mem-fn"><a href="#使用mem-fn" class="headerlink" title="使用mem_fn"></a>使用mem_fn</h3><p>定义在function头文件中，接受一个成员指针生成一个可调用对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find_if(vec.begin(),vec.end(),mem_fn(&amp;string::empty));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;生成的可调用对象可以接受string对象，string指针&#x2F;地址</span></pre></td></tr></table></figure>
<h3 id="使用bind"><a href="#使用bind" class="headerlink" title="使用bind"></a>使用bind</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find_if(vec.begin(),vec.end(),bind(&amp;string::empty,_1))</span></pre></td></tr></table></figure>
<h2 id="union类"><a href="#union类" class="headerlink" title="union类"></a>union类</h2><p>节省空间的类，在任意时刻只有一个数据成员可以有值，不能含有引用类型的成员，默认情况下，它的成员是public的，它不能继承自其他类，也不能作为基类使用，所以不能含有虚函数<br>匿名union的成员在本作用域可以直接访问，但不能包含protected和private成员，也不能定义成员函数<br>如果union含有定义了默认构造函数或拷贝控制成员，则编译器会为union合成对应的版本并声明为删除的<br>含有类类型的union常声明在类内，此时可以用enum在类内定义一个判别式，来追踪union的成员</p>
<h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><p>定义在函数内部，它的成员必须完整地定义在类的内部，所以不允许为它定义静态数据成员，并且它不能使用本作用域的普通变量，而本作用域对它的私有成员也没有访问权限<br>当局部类中有嵌套类时，嵌套类的定义可以在局部类的外部，但是必须在本作用域中</p>
<h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>类可以将其非静态数据成员定义成位域，通常用于程序需要向其他程序或硬件设备传递二进制数据时，通常用无符号类型保存一个位域</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	unsigned mode:2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>在类的内部连续定义的位域压缩在同一个整数的相邻位，从而压缩存储<br>取地址符不能作用于位域，任何指针都无法指向类的位域</p>
<h2 id="volatile限定符"><a href="#volatile限定符" class="headerlink" title="volatile限定符"></a>volatile限定符</h2><p>表示对象的值可能程序的控制或检测之外改变，作用与const相似，区别在于类的拷贝控制成员对volatile对象无效，比如拷贝构造函数的形参是常量引用（非volatile），明显不能将一个非volatile形参绑定到一个volatile对象，此时需要自定义拷贝控制成员</p>
<h2 id="链接指示：extern-“C”"><a href="#链接指示：extern-“C”" class="headerlink" title="链接指示：extern “C”"></a>链接指示：extern “C”</h2><p>调用其他语言编写的函数时用，指出任意非C++函数所用的语言<br>链接指示可以嵌套</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern &quot;C&quot;&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	#include&lt;string.h&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>链接指示对整个声明都有效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern &quot;C&quot; void f(void(*)(int));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;形参是一个指向C函数的指针</span></pre></td></tr></table></figure>
<p>如果我们希望给C++函数传入一个指向C函数的指针，可以使用类型别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern &quot;C&quot; typedef void FC(int);</span></pre></td></tr><tr><td class="code"><pre><span class="line">void f2(FC*);</span></pre></td></tr></table></figure>
<p>导出C++函数到其他语言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern &quot;C&quot; double calc(double bd)&#123;------&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;该函数可被C程序调用</span></pre></td></tr></table></figure>
<p>在C和C++中编译头文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;预处理器定义了_ _cplusplus</span></pre></td></tr><tr><td class="code"><pre><span class="line">#ifdef _ _cpluscplus</span></pre></td></tr><tr><td class="code"><pre><span class="line">extern &quot;C&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif</span></pre></td></tr><tr><td class="code"><pre><span class="line">int strcmp(const char*,const char*);</span></pre></td></tr></table></figure>
<p>C语言不支持函数重载，所以一个C链接指示只能说明一组重载函数中的一个</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语言</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 19(上)</title>
    <url>/2019/12/05/C++%20Primer%2019(%E4%B8%8A)/</url>
    <content><![CDATA[<h2 id="控制内存分配"><a href="#控制内存分配" class="headerlink" title="控制内存分配"></a>控制内存分配</h2><h3 id="定义new-delete"><a href="#定义new-delete" class="headerlink" title="定义new/delete"></a>定义new/delete</h3><p>全局作用域或类作用域<br>当定义为类的成员时，是隐式static的，无须显式声明</p>
<p>当将delete定义为类的成员时，可以包含第二个size_t的形参，它是第一个指针形参所指对象的字节数，此也可以用于继承体系中的对象，由动态类型决定字节数</p>
<a id="more"></a>
<p>new的第一个形参必须是size_t，并且不能有默认实参，传入的是对象字节数或所有元素所需的空间</p>
<p>不能重载<code>void *operator new(size_t,void*);</code></p>
<h3 id="new-delete的查找"><a href="#new-delete的查找" class="headerlink" title="new/delete的查找"></a>new/delete的查找</h3><p>如果被分配/释放的是类类型，则编译器首先在类及其基类的作用域中查找，然后才在全局中查找</p>
<h3 id="不抛出异常"><a href="#不抛出异常" class="headerlink" title="不抛出异常"></a>不抛出异常</h3><p>类型nothrow_t是new头文件中的一个struct，在这个类型中不包含任何成员，new头文件中还有一个nothrow的const对象，用户通过这个对象请求new的非抛出版本<br>析构函数和delete都不允许抛出异常<br>当重载delete的时候，必须使用noexcept指定其不抛出异常</p>
<h3 id="使用malloc和free"><a href="#使用malloc和free" class="headerlink" title="使用malloc和free"></a>使用malloc和free</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void *operator new(size_t size)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if(void *mem&#x3D;malloc(size))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		return mem;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else</span></pre></td></tr><tr><td class="code"><pre><span class="line">		throw bad_alloc();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void operator delete(void *mem)noexcept&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	free(mem);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="使用定位new"><a href="#使用定位new" class="headerlink" title="使用定位new"></a>使用定位new</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new(place_address)type[size]&#123;initializer_list&#125;;</span></pre></td></tr></table></figure>
<p>当仅通过一个地址调用时，使用<code>operator new(size_t,void *)</code>，这个函数不分配任何内存，只是简单返回指针实参，然后在该地址初始化对象</p>
<h3 id="construct与定位new"><a href="#construct与定位new" class="headerlink" title="construct与定位new"></a>construct与定位new</h3><p>传给construct的指针必须指向同一个allocator对象分配的空间<br>传给定位new的则不用，甚至不用指向动态内存</p>
<h3 id="指针调用析构函数"><a href="#指针调用析构函数" class="headerlink" title="指针调用析构函数"></a>指针调用析构函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string *sp&#x3D;new string(&quot;a value&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">sp-&gt;~string();</span></pre></td></tr></table></figure>
<p>清除给定的对象，但不会释放内存空间，可以重新使用该空间</p>
<h2 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h2><h3 id="使用dynamic-cast"><a href="#使用dynamic-cast" class="headerlink" title="使用dynamic_cast"></a>使用dynamic_cast</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;转换目标为指针类型</span></pre></td></tr><tr><td class="code"><pre><span class="line">if(Derived *dp&#x3D;dynamic_cast&lt;Derived *&gt;(bp))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	------</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;else&#123;----&#125;</span></pre></td></tr></table></figure>
<p>如果转换失败结果为0<br>可以对一个空指针执行该操作，结果是所需类型的空指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;转换目标为引用类型</span></pre></td></tr><tr><td class="code"><pre><span class="line">void f(const Base &amp;b)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	try&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		const Derived &amp;d&#x3D;dynamic_cast&lt;const Derived&amp;&gt;(b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;catch(bad_cast)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		------</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>如果转换失败抛出std::bad_cast，该异常在typeinfo中</p>
<h3 id="使用typeid"><a href="#使用typeid" class="headerlink" title="使用typeid"></a>使用typeid</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(typeid(*bp)&#x3D;&#x3D;typeid(Derived))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	---------</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>实参是对象，而不是指针<br>作用于数组和函数时不会执行到指针的转换<br>当运算对象是带有虚函数的类时，编译器才会在运行时对表达式进行求值，此时指针必须是有效指针，空指针的话会抛出bad_typeid异常<br>其他情况不会对表达式进行求值，直接返回静态类型</p>
<h3 id="type-info类"><a href="#type-info类" class="headerlink" title="type_info类"></a>type_info类</h3><p>定义在typeinfo头文件中<br>操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1&#x3D;t2	t1!&#x3D;t2</span></pre></td></tr><tr><td class="code"><pre><span class="line">t.name()	t1.before(t2)&#x2F;&#x2F;返回bool</span></pre></td></tr></table></figure>
<p>没有默认构造函数，type_info类的拷贝、移动、赋值函数都被定义成删除的，只能通过typeid创建它的对象</p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum color&#123;red,yellow,green&#125;;&#x2F;&#x2F;不限定作用域</span></pre></td></tr><tr><td class="code"><pre><span class="line">enum class peppers&#123;red,yellow,green&#125;&#x2F;&#x2F;限定作用域</span></pre></td></tr><tr><td class="code"><pre><span class="line">color eyes&#x3D;green;</span></pre></td></tr><tr><td class="code"><pre><span class="line">peppers p&#x3D;peppers::red;</span></pre></td></tr></table></figure>
<p>默认情况下，枚举值从0开始，依次加1<br>可以定义枚举类型的constexpr变量<br>可以作为case标签，也能将枚举类型作为非类型模板形参，还能在类的定义中初始化枚举类型的静态数据成员<br>只能用该类型的一个枚举成员或者另一个对象来赋值</p>
<h3 id="指定enum的大小"><a href="#指定enum的大小" class="headerlink" title="指定enum的大小"></a>指定enum的大小</h3><p>不限定作用域的枚举类型的对象或枚举成员会自动隐式转换为int，而限定作用域的枚举类型不会进行这样的隐式转换<br>不限定作用域的枚举类型，它的枚举成员不存在默认类型，我们指定潜在类型时要注意，枚举成员的值必须在指定的类型取值范围内，不然就会出错<br>而限定作用域默认情况下是int</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum a:unsigned long long&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	-------</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h3><p>前置声明必须与它的定义一致，无论是作用域是否限定还是指定的潜在类型，不然就会报错</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语言</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 18(下)</title>
    <url>/2019/12/04/C++%20Primer%2018(%E4%B8%8B)/</url>
    <content><![CDATA[<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><h3 id="新建命名空间"><a href="#新建命名空间" class="headerlink" title="新建命名空间"></a>新建命名空间</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace x&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	------</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;	&#x2F;&#x2F;不需要分号</span></pre></td></tr></table></figure>
<p>不能定义在函数或类的内部<br>命名空间成员的定义可以在外部，但是必须在所属命名空间的外层命名空间中</p>
<a id="more"></a>
<h3 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h3><p>模板特例化必须定义在原始模板所属的命名空间中，只要在该命名空间中声明了特例化，就可以在外部定义它了</p>
<h3 id="内联命名空间"><a href="#内联命名空间" class="headerlink" title="内联命名空间"></a>内联命名空间</h3><p>可以直接被外层命名空间使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline namespace x&#123;--------&#125;</span></pre></td></tr></table></figure>
<p>inline必须出现在第一次定义的时候，后续打开可不写</p>
<h3 id="未命名的命名空间"><a href="#未命名的命名空间" class="headerlink" title="未命名的命名空间"></a>未命名的命名空间</h3><p>静态生命周期，第一次使用前创建，直到程序结束销毁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace &#123;--------&#125;</span></pre></td></tr></table></figure>
<p>不能跨越多个文件，一个包含了未命名的命名空间的头文件被多个文件使用时，在这多个文件里的名字将对应不同的实体<br>它的名字可以直接使用，因此当处于最外层作用域时，它里面的名字要区分于全局作用域中的名字</p>
<h3 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a>using 声明</h3><p>一次引入一个命名空间的一个成员名字<br>当它出现在类的作用域中时，这个声明只能指向基类成员</p>
<h3 id="using-指示"><a href="#using-指示" class="headerlink" title="using 指示"></a>using 指示</h3><p>一次引入一个命名空间所有名字，可以说是将名字都注入到外层作用域中，using指示不能出现在类的作用域中</p>
<h3 id="头文件与using"><a href="#头文件与using" class="headerlink" title="头文件与using"></a>头文件与using</h3><p>头文件应该只负责定义接口的名字，所以只能在它的函数或命名空间内使用using声明和指示</p>
<h3 id="实参查找与类类型形参"><a href="#实参查找与类类型形参" class="headerlink" title="实参查找与类类型形参"></a>实参查找与类类型形参</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">operator&gt;&gt;(std::cin,s);</span></pre></td></tr></table></figure>
<p>当编译器发现&gt;&gt;时，首先在当前作用域查找，然后在外层作用域查找，最后由于&gt;&gt;的形参是类类型的，所以编译器还会在cin和s的类所属的命名空间查找</p>
<h3 id="实参查找与友元"><a href="#实参查找与友元" class="headerlink" title="实参查找与友元"></a>实参查找与友元</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace A&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	class C&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#x2F;&#x2F;隐式成为命名空间A的成员</span></pre></td></tr><tr><td class="code"><pre><span class="line">		friend void f2();</span></pre></td></tr><tr><td class="code"><pre><span class="line">		friend void f(const C&amp;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	A::C cobj;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	f(cobj);	&#x2F;&#x2F;正确，通过形参C找到A的命名空间</span></pre></td></tr><tr><td class="code"><pre><span class="line">	f2();	&#x2F;&#x2F;错误，找不到它的声明</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="使用using"><a href="#使用using" class="headerlink" title="使用using"></a>使用using</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using NS::print(int);</span></pre></td></tr><tr><td class="code"><pre><span class="line">using NS::print;</span></pre></td></tr></table></figure>
<p>using声明会引入函数到本作用域<br>如果using声明引入一个同名同参的函数，会报错<br>而using指示不会<br>using指示是将命名空间的成员提升到外层作用域</p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><h3 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using Base1::Base1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">using Base2::Base2;</span></pre></td></tr></table></figure>
<p>如果继承了相同形参列表的构造函数，会报错，这时我们需要为该形参再自己定义一个构造函数，既然定义了构造函数，那么这个时候最好也定义一个默认构造函数</p>
<h3 id="派生类的控制成员"><a href="#派生类的控制成员" class="headerlink" title="派生类的控制成员"></a>派生类的控制成员</h3><p>如果定义了自己的拷贝/赋值构造函数和赋值运算符，必须在完整的对象上执行拷贝、移动、赋值操作<br>如果使用的是合成的，就会对其基类部分执行这些操作</p>
<h3 id="静态类型与操作"><a href="#静态类型与操作" class="headerlink" title="静态类型与操作"></a>静态类型与操作</h3><p>对象、指针和引用的静态类型决定能够使用哪些成员，例如一个指向基类的指针，只能使用基类部分的成员</p>
<h3 id="多重继承的二义性调用"><a href="#多重继承的二义性调用" class="headerlink" title="多重继承的二义性调用"></a>多重继承的二义性调用</h3><p>当从多个基类继承了同名函数时，调用需要指明哪个作用域下的函数，不然就会出现二义性错误，也可以再本作用域下再定义一个同名函数</p>
<h3 id="使用虚继承"><a href="#使用虚继承" class="headerlink" title="使用虚继承"></a>使用虚继承</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Bear:virtual public zoo&#123;------&#125;;</span></pre></td></tr></table></figure>
<p>派生类中只有虚继承的类一个实例</p>
<h3 id="虚基类的构造"><a href="#虚基类的构造" class="headerlink" title="虚基类的构造"></a>虚基类的构造</h3><p>虚基类是由最低层的派生类初始化的，如果有多个虚基类，则按照在派生列表中中出现的顺序初始化，然后才按顺序初始化其他基类<br>析构顺序与构造顺序相反</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语言</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 18(上)</title>
    <url>/2019/12/04/C++%20Primer%2018(%E4%B8%8A)/</url>
    <content><![CDATA[<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="栈展开"><a href="#栈展开" class="headerlink" title="栈展开"></a>栈展开</h3><p>异常发生在try语句块内–&gt;在跟自己的try语句块关联的catch里找<br>若该try语句块嵌套在另一个try内–&gt;继续在外面的这个try语句块找<br>若该函数被调用–&gt;在调用它的函数找<br>若是找到catch，则在与原来try语句块关联的最后一个catch后的点继续执行程序<br>最后找不到就会调用标准库函数terminate强行终止程序</p>
<a id="more"></a>
<h3 id="析构函数与异常"><a href="#析构函数与异常" class="headerlink" title="析构函数与异常"></a>析构函数与异常</h3><p>栈展开可能使用析构函数–&gt;如果析构函数需要执行某个可能抛出异常的操作，这个操作应该在析构函数内部得到处理<br>因为如果最后没有捕获到catch，就会调用terminate，此前分配的资源就无法被释放，所以这个可能抛出异常的操作就应该在析构函数内部就得到处理</p>
<h3 id="异常对象"><a href="#异常对象" class="headerlink" title="异常对象"></a>异常对象</h3><p>位于编译器管理的空间，由异常抛出表达式拷贝初始化，该表达式的静态编译时类型决定了异常对象的类型，如果一条throw表达式解引用了一个指向基类的指针，而该指针实际指向的是派生类对象，则抛出的对象被切掉一部分，只有基类部分被抛出（不要指向局部对象）</p>
<h3 id="catch的异常声明"><a href="#catch的异常声明" class="headerlink" title="catch的异常声明"></a>catch的异常声明</h3><p>异常声明必须是完全类型，可以是左值引用，不能是右值引用<br>如果是基类的非引用类型，用派生类对象初始化时会切掉一部分<br>如果是基类的引用类型，以常规方式绑定异常对象，catch无法使用派生类特有的成员<br>异常声明用数组或函数初始化时，会转换为指针</p>
<h3 id="重新抛出"><a href="#重新抛出" class="headerlink" title="重新抛出"></a>重新抛出</h3><p>catch处理了一部分异常，重新抛出，将异常对象沿着调用链向上传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">throw;</span></pre></td></tr></table></figure>
<p>如果空throw出现在处理代码之外的区域，编译器j将调用terminate<br>只有当catch异常声明是引用类型时我们对参数作的改变才会被保留并继续传播</p>
<h3 id="处理所有异常"><a href="#处理所有异常" class="headerlink" title="处理所有异常"></a>处理所有异常</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">catch(...)</span></pre></td></tr></table></figure>
<p>通常与重新抛出一起使用</p>
<h3 id="函数测试块"><a href="#函数测试块" class="headerlink" title="函数测试块"></a>函数测试块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Blob&lt;T&gt;::Blob(std::initializer_list&lt;T&gt; il) try:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	data(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;catch(const std::bad_alloc &amp;e)&#123;--------&#125;</span></pre></td></tr></table></figure>
<h3 id="不抛出声明"><a href="#不抛出声明" class="headerlink" title="不抛出声明"></a>不抛出声明</h3><p>noexcept在声明和定义中同时出现，也在尾置返回类型之前<br>在类型别名中不能出现noexcept<br>在成员函数中，noexcept在const和引用限定符之后，final，override或虚函数的=0之前</p>
<p>异常说明的实参</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void func1(int a)noexcept(true)&#x2F;&#x2F;不会抛出异常</span></pre></td></tr><tr><td class="code"><pre><span class="line">void func2(int b)noexcept(false)&#x2F;&#x2F;可能抛出异常</span></pre></td></tr></table></figure>
<h3 id="noexcept-运算符"><a href="#noexcept-运算符" class="headerlink" title="noexcept 运算符"></a>noexcept 运算符</h3><p>返回bool类型的右值常量表达式，不会求其运算对象的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void f()noexcept (noexcept(g()));</span></pre></td></tr></table></figure>
<h3 id="一致的异常说明"><a href="#一致的异常说明" class="headerlink" title="一致的异常说明"></a>一致的异常说明</h3><p>函数指针和指针指向的函数<br>虚函数和它的派生函数<br>合成拷贝控制成员时</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语言</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 17(下)</title>
    <url>/2019/12/04/C++%20Primer%2017(%E4%B8%8B)/</url>
    <content><![CDATA[<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><h3 id="随机数引擎类"><a href="#随机数引擎类" class="headerlink" title="随机数引擎类"></a>随机数引擎类</h3><p>函数对象类，定义了调用运算符，不接受参数并返回一个随机数unsigned整数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default_random_engine e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;10;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cout&lt;&lt;e()&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="随机数引擎操作"><a href="#随机数引擎操作" class="headerlink" title="随机数引擎操作"></a>随机数引擎操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Engine e(s)		&#x2F;&#x2F;使用整型值s作为种子</span></pre></td></tr><tr><td class="code"><pre><span class="line">e.seed(s)		&#x2F;&#x2F;使用种子s重置引擎的状态</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;使用相同种子的引擎将生成相同的序列</span></pre></td></tr><tr><td class="code"><pre><span class="line">e.min()		e.max()</span></pre></td></tr><tr><td class="code"><pre><span class="line">Engine::result_type		&#x2F;&#x2F;此引擎可生成的值类型</span></pre></td></tr><tr><td class="code"><pre><span class="line">e.discard(ull)	&#x2F;&#x2F;将引擎推进Ull步，这个值是unsigned long long</span></pre></td></tr></table></figure>
<h3 id="使用分布类"><a href="#使用分布类" class="headerlink" title="使用分布类"></a>使用分布类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uniform_int_distribution&lt;unsigned&gt; u(0,9);</span></pre></td></tr><tr><td class="code"><pre><span class="line">default_random_engine e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">u(e);</span></pre></td></tr></table></figure>
<p>对于一个给定的随机数发生器，每次运行程序它都会返回相同的数值序列，可以通过将e和u定义为static，然后就可以在函数调用中保持状态</p>
<h3 id="使用系统函数time"><a href="#使用系统函数time" class="headerlink" title="使用系统函数time"></a>使用系统函数time</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义在ctime头文件中，返回从一个特定时刻到当前经过了多少秒</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;函数time接受单个指针参数，指向用于写入时间的数据结构</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;如果此指针为空，则简单地返回时间</span></pre></td></tr><tr><td class="code"><pre><span class="line">default_random_engine e(time(0));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;如果程序作为自动过程地一部分，则种子不变</span></pre></td></tr></table></figure>
<h3 id="生成随机实数"><a href="#生成随机实数" class="headerlink" title="生成随机实数"></a>生成随机实数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uniform_real_distribution&lt;double&gt; u(0,1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">uniform_real_distribution&lt;&gt;	u(0,1)	&#x2F;&#x2F;默认生成double类型</span></pre></td></tr><tr><td class="code"><pre><span class="line">u(e);</span></pre></td></tr></table></figure>
<h3 id="分布类型的操作"><a href="#分布类型的操作" class="headerlink" title="分布类型的操作"></a>分布类型的操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d.min()		d.max()</span></pre></td></tr><tr><td class="code"><pre><span class="line">d.reset();&#x2F;&#x2F;重建d的状态，使得随后对d的使用不依赖于d已经生成的值</span></pre></td></tr></table></figure>
<h3 id="生成非均匀分布的随机数"><a href="#生成非均匀分布的随机数" class="headerlink" title="生成非均匀分布的随机数"></a>生成非均匀分布的随机数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">normal_distribution&lt;&gt; n(4,1.5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">n(e);</span></pre></td></tr></table></figure>
<h3 id="使用lround函数"><a href="#使用lround函数" class="headerlink" title="使用lround函数"></a>使用lround函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义在cmath中</span></pre></td></tr><tr><td class="code"><pre><span class="line">unsigned v&#x3D;lround(n(e));</span></pre></td></tr></table></figure>
<h3 id="bernoulli-distribution类"><a href="#bernoulli-distribution类" class="headerlink" title="bernoulli_distribution类"></a>bernoulli_distribution类</h3><p>不接受模板参数，返回bool值，概率默认0.5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bernoulli_distribution	b;&#x2F;&#x2F;默认true概率0.5</span></pre></td></tr><tr><td class="code"><pre><span class="line">bernoulli_distribution  b(.55)	&#x2F;&#x2F;true为0.55</span></pre></td></tr></table></figure>
<h2 id="IO库再探"><a href="#IO库再探" class="headerlink" title="IO库再探"></a>IO库再探</h2><h3 id="操纵符"><a href="#操纵符" class="headerlink" title="操纵符"></a>操纵符</h3><p>函数或对象，影响流的状态，返回处理的流对象<br>用于控制数值的输出以及控制补白的数量和位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolalpha	noboolalpha		showbase noshowbase</span></pre></td></tr><tr><td class="code"><pre><span class="line">showpoint 	noshowpoint 	showpos noshowpos</span></pre></td></tr><tr><td class="code"><pre><span class="line">uppercase 	nouppercase		dec		hex 	oct</span></pre></td></tr><tr><td class="code"><pre><span class="line">left	right	internal	&#x2F;&#x2F;在值的左右&#x2F;符号和值之间填充字符</span></pre></td></tr><tr><td class="code"><pre><span class="line">fixed	scientific	hexfloat	defaultfloat</span></pre></td></tr><tr><td class="code"><pre><span class="line">unitbuf	nounitbuf	skipws	noskipws</span></pre></td></tr><tr><td class="code"><pre><span class="line">flush	ends	endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">setfill(ch)	setprecision(ch)	setw(w)	setbase(b)</span></pre></td></tr></table></figure>
<p>默认情况下，输入运算符会忽略空白符</p>
<h3 id="单字节操作"><a href="#单字节操作" class="headerlink" title="单字节操作"></a>单字节操作</h3><p>单字节底层IO操作会读取而不是忽略空白符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">is.get(ch)	</span></pre></td></tr><tr><td class="code"><pre><span class="line">is.get()	&#x2F;&#x2F;返回int	</span></pre></td></tr><tr><td class="code"><pre><span class="line">os.put(ch)</span></pre></td></tr><tr><td class="code"><pre><span class="line">is.putback(ch)	is.unget()	</span></pre></td></tr><tr><td class="code"><pre><span class="line">is.peek();	&#x2F;&#x2F;返回Int</span></pre></td></tr></table></figure>
<p>返回int是因为这样可以返回文件尾标记<br>标准库用负值表示文件尾<br>头文件cstdio定义了EOF，这是一个const</p>
<h3 id="多字节底层操作"><a href="#多字节底层操作" class="headerlink" title="多字节底层操作"></a>多字节底层操作</h3><p>自己分配并管理用来保存和提取数据的字符数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">is.get(sink,size,delim)</span></pre></td></tr><tr><td class="code"><pre><span class="line">is.getline(sink,size,delim)</span></pre></td></tr><tr><td class="code"><pre><span class="line">is.read(sink.size)</span></pre></td></tr><tr><td class="code"><pre><span class="line">is.gcount()	&#x2F;&#x2F;从上一个操作读取的字节数</span></pre></td></tr><tr><td class="code"><pre><span class="line">os.write(source,size)</span></pre></td></tr><tr><td class="code"><pre><span class="line">is.isgnore(size,delim)	&#x2F;&#x2F;size默认1，delim默认EOF</span></pre></td></tr></table></figure>
<h3 id="流的随机访问"><a href="#流的随机访问" class="headerlink" title="流的随机访问"></a>流的随机访问</h3><p>只用于sstream和fstream</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tellg()	tellp()</span></pre></td></tr><tr><td class="code"><pre><span class="line">seekg(pos)	seekp(pos)	&#x2F;&#x2F;将标记定位到绝对地址</span></pre></td></tr><tr><td class="code"><pre><span class="line">seekg(off,from)	seekp(off,from)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;from是stream::beg&#x2F;cur&#x2F;end</span></pre></td></tr></table></figure>
<p>标记只有一个，表示缓冲区中的当前位置，标准库将p和g版本的读写位置都映射到这个单一的标记，在读写操作间切换时，就必须进行seek进行重定位标记</p>
<p>pos的类型是pos_type<br>off的类型是off_type        //可以是负的<br>它们定义在头文件istream和ostream中</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语言</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 17(上）</title>
    <url>/2019/12/03/C++%20Primer%2017(%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>tuple类型和它的伴随类型都在tuple头文件中<br>初始化tuple</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tuple&lt;size_t,size_t,size_t&gt;threeD&#x3D;&#123;1,2,3&#125;;&#x2F;&#x2F;错误</span></pre></td></tr><tr><td class="code"><pre><span class="line">tuple&lt;size_t,size_t,size_t&gt;threeD&#123;1,2,3&#125;&#x2F;&#x2F;正确，也可值初始化</span></pre></td></tr></table></figure>
<a id="more"></a>
<p>访问tuple</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get&lt;i&gt;(t)&#x2F;&#x2F;返回引用，若t为左值，则左值引用，否则右值引用</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;i必须是一个常量表达式</span></pre></td></tr></table></figure>
<p>tuple成员的数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tuple_size&lt;tupleType&gt;::value;&#x2F;&#x2F;返回size_t</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#x2F;&#x2F;注意：tupleType不是tuple对象，而是类型</span></pre></td></tr><tr><td class="code"><pre><span class="line">typedef decltype(item) trans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">size_t sz&#x3D;tuple_size&lt;trans&gt;::value;</span></pre></td></tr></table></figure>
<p>tuple成员的类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tuple_element&lt;i,tupleType&gt;::type;</span></pre></td></tr></table></figure>
<p>只有两个tuple具有相同数量成员才可以进行比较<br>默认情况下，equal_range使用&lt;运算符来比较元素</p>
<h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><p>定义在头文件bitset中<br>初始化bitset</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitset&lt;n&gt; b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">bitset&lt;n&gt; b(u);	&#x2F;&#x2F;这两个是constexpr的构造函数</span></pre></td></tr><tr><td class="code"><pre><span class="line">bitset&lt;n&gt; b(s,pos,m,zero,one);</span></pre></td></tr><tr><td class="code"><pre><span class="line">bitset&lt;n&gt; b(cp,pos,m,zero,one);</span></pre></td></tr></table></figure>
<p>当用一个整型值来初始化bitset时，它会被转换为unsigned long long类型并当作位模式处理<br>操作bitset</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b.any();	b.all();	b.none();	b.count()</span></pre></td></tr><tr><td class="code"><pre><span class="line">b.size();&#x2F;&#x2F;constexpr函数</span></pre></td></tr><tr><td class="code"><pre><span class="line">b.text(pos);	b.set(pos,v)	b.set()</span></pre></td></tr><tr><td class="code"><pre><span class="line">b.reset(pos)	b.reset()	b.flip(pos)		b.flip();</span></pre></td></tr><tr><td class="code"><pre><span class="line">b[pos]	&#x2F;&#x2F;若b为const，返回bool值，否则可用来操作位</span></pre></td></tr><tr><td class="code"><pre><span class="line">b.to_ulong()	b.to_ullong()	b.to_string(zero,one)</span></pre></td></tr><tr><td class="code"><pre><span class="line">os&lt;&lt;b	is&gt;&gt;b;</span></pre></td></tr></table></figure>
<h2 id="正则表达式（RE）"><a href="#正则表达式（RE）" class="headerlink" title="正则表达式（RE）"></a>正则表达式（RE）</h2><p>RE库定义在头文件regex中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string pattern(&quot;[^c]ei&quot;);&#x2F;&#x2F;任意非c后接ei</span></pre></td></tr><tr><td class="code"><pre><span class="line">pattern&#x3D;&quot;[[:alpha:]]*&quot;+pattern+&quot;[[:alpha:]]*&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;0个或多个，若*换+，则表示1个或多个</span></pre></td></tr><tr><td class="code"><pre><span class="line">regex r(pattern);</span></pre></td></tr><tr><td class="code"><pre><span class="line">smatch results;</span></pre></td></tr><tr><td class="code"><pre><span class="line">string test_str&#x3D;&quot;receipt freind theif receive&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">if(regex_search(test_str,results,r))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cout&lt;&lt;result.str()&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#x2F;&#x2F;输出freind</span></pre></td></tr></table></figure>
<p>regex_search 找到一个匹配子串就会停止查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">regex(re,f)</span></pre></td></tr><tr><td class="code"><pre><span class="line">r1.assign(re,f)</span></pre></td></tr><tr><td class="code"><pre><span class="line">r.mark_count()	&#x2F;&#x2F;r中子表达式的数目</span></pre></td></tr><tr><td class="code"><pre><span class="line">r.flags() &#x2F;&#x2F;返回r的标志集</span></pre></td></tr></table></figure>
<p>三个标志特别记忆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">icase</span></pre></td></tr><tr><td class="code"><pre><span class="line">nosubs</span></pre></td></tr><tr><td class="code"><pre><span class="line">optimize	&#x2F;&#x2F;执行速度优先于构造速度</span></pre></td></tr></table></figure>
<p>使用标志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">regex r(&quot;[[:alnum:]]+\\.(cpp|cxx|cc)$&quot;,regex::icase);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;反斜线和点在C++中都是特殊字符，需要先用一个反斜线去掉其特殊含义</span></pre></td></tr></table></figure>
<p>正则表达式是在运行时，当一个regex对象被初始化或赋予一个新模式才被“编译”的，即是说，一个正则表达式的语法是否正确是在运行时解析的（特别耗时）<br>若是编写的正则表达式存在错误，那么在运行时标准库会抛出regex_error的异常，它有what()和code()成员，来描述错误和某个错误类型对应的数值编码</p>
<p>容器参数的类型要与输入序列的类型一致</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string-&gt;regex,smatch,ssub_match,sregex_iterator</span></pre></td></tr><tr><td class="code"><pre><span class="line">const char*-&gt;regex,cmatch,csub_match,cregex_iterator</span></pre></td></tr></table></figure>
<p>使用sregex_iterator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(sregex_iterator it(file.begin(),file.end(),r),end_it;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		it!&#x3D;end_it;++it)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cout&lt;&lt;it-&gt;str()&lt;&lt;endl;</span></pre></td></tr></table></figure>
<p>查找上下文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for....</span></pre></td></tr><tr><td class="code"><pre><span class="line">		auto pos &#x3D; it-&gt;prefix().length();</span></pre></td></tr><tr><td class="code"><pre><span class="line">		pos&#x3D;pos&gt;40?pos-40:0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cout&lt;&lt;it-&gt;prefix().str().substr(pos)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;&lt;&quot;\n\t\t&gt;&gt;&gt;&quot;&lt;&lt;it-&gt;str()&lt;&lt;&quot;&lt;&lt;&lt;\n&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;&lt;it-&gt;suffix().str().substr(0,40)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;&lt;endl;</span></pre></td></tr></table></figure>
<p>smatch操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m.ready()	m.size()	m.empty()</span></pre></td></tr><tr><td class="code"><pre><span class="line">m.prefix()	m.suffix()	m.format(...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">m.length(n)	m.position(n)	&#x2F;&#x2F;第n个子表达式序列距开始的距离</span></pre></td></tr><tr><td class="code"><pre><span class="line">m.str(n)	m[n]</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;m.str(0) 保存完整的匹配</span></pre></td></tr><tr><td class="code"><pre><span class="line">m.begin(),m.end()</span></pre></td></tr><tr><td class="code"><pre><span class="line">m.cbegin(),m.cend()</span></pre></td></tr></table></figure>
<p>？sub_match操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">matched		first	second		length()	str()</span></pre></td></tr></table></figure>
<p>使用regex_replace</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string fmt&#x3D;&quot;$2.$5.$7&quot;	&#x2F;&#x2F;表某个子表达式</span></pre></td></tr><tr><td class="code"><pre><span class="line">cout&lt;&lt;regex_replace(s,r,fmt)&lt;&lt;endl;</span></pre></td></tr></table></figure>
<p>匹配和格式化标志的类型为match_flag_type，定义在regex_constants的命名空间，也在std中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using std::regex_constants::format_no_copy;</span></pre></td></tr></table></figure>
<p>使用格式标志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;regex_replace(s,r,fmt,format_no_copy)&lt;&lt;endl;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语言</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 16 (下)</title>
    <url>/2019/12/02/C++%20Primer%2016(%E4%B8%8B)/</url>
    <content><![CDATA[<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>std::move是一个函数模板，它的定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="转发实参"><a href="#转发实参" class="headerlink" title="转发实参"></a>转发实参</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename F,typename T1,typename T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void flip1(F f,T1 t1,T2 t2)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	f(t2,t1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void f(int v1,int &amp;v2)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cout&lt;&lt;v1&lt;&lt;&quot; &quot;&lt;&lt;++v2&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">flip1(f,j,42);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;f中的引用参数绑定到局部变量t1，而不会改变j</span></pre></td></tr></table></figure>
<p>希望可以保持给定实参的“左值性”和参数的const属性<br>通过将函数参数定义为一个指向模板类型参数的右值引用，可以保持实参的所有信息，而使用引用可以保持其const属性，因为该const是底层的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename F,typename T1,typename T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void flip2(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	f(t2,t1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">flip2(f,j,42)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;此时t1类型为int&amp;,绑定到j,可以改变j</span></pre></td></tr></table></figure>
<p>此时不能用于接受右值引用参数的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void g(int &amp;&amp;i,int &amp;j)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">flip2(g,i,42)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;此时右值42传递给t2，t2为右值引用绑定到42，即t2本身是一个左值表达式，flip2中对g的调用将传递给g的右值引用一个左值（t2)</span></pre></td></tr></table></figure>
<h2 id="使用std-forward"><a href="#使用std-forward" class="headerlink" title="使用std::forward"></a>使用std::forward</h2><p>forward函数位于utility头文件中，它返回显式实参类型的右值引用，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">forward&lt;T&gt;-&gt;T&amp;&amp;</span></pre></td></tr></table></figure>
<p>使用forward重写翻转函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename F,typename T1,typename T2&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void flip(F f,T1 &amp;&amp;t1,T2 &amp;&amp;t2)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	f(std::forward&lt;T2&gt;(t2),std::forward&lt;T1&gt;(t1));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">flip(g,i,42);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;此时会保持实参的所有细节</span></pre></td></tr></table></figure>
<h2 id="模板与重载"><a href="#模板与重载" class="headerlink" title="模板与重载"></a>模板与重载</h2><p>非模板函数匹配度更高</p>
<p>数组到指针的转换对于函数匹配来说是精确匹配</p>
<p>当有多个重载模板时对一个调用提供同样好的匹配时，选择更加特例化的版本，比如没有const的参数，因为带const的参数更加通用<br>IO库为char * 值定义了一个&lt;&lt;版本，此版本假定指针表示一个空字符结尾的数组，并打印数组的内容而不是地址值</p>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>声明方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T,typename...Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void foo(const T&amp;t,const Args&amp;...rest);</span></pre></td></tr></table></figure>
<p>对于可变参数模板，编译器还会推断包中参数的数目</p>
<h2 id="使用sizeof…运算符"><a href="#使用sizeof…运算符" class="headerlink" title="使用sizeof…运算符"></a>使用sizeof…运算符</h2><p>返回常量表达式，不会对其实参求值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sizeof...(Args);</span></pre></td></tr></table></figure>
<h2 id="可变参数函数与递归"><a href="#可变参数函数与递归" class="headerlink" title="可变参数函数与递归"></a>可变参数函数与递归</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ostream &amp;print(ostream &amp;os,const T&amp;t)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return os&lt;&lt;t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;	&#x2F;&#x2F;这个递归基要提前声明</span></pre></td></tr><tr><td class="code"><pre><span class="line">template&lt;typename T,typename...Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ostream &amp;print(ostream &amp;os,const T &amp;t,const Args&amp;...rest)&#123;	&#x2F;&#x2F;第一个包扩展</span></pre></td></tr><tr><td class="code"><pre><span class="line">	os&lt;&lt;t&lt;&lt;&quot; &quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return print(os,rest...);&#x2F;&#x2F;第二个包扩展</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>非可变参数模板比可变参数模板更加特例化<br>包扩展的另一种用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename...Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ostream &amp;errormsg(ostream &amp;os,const Args&amp;...rest)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return print(os,debug_rep(rest)...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注意:debug_rep(rest...)是错误的，因为debug_rep没有对应多个参数的版本，扩展中的模式会独立地应用于包中的每一个元素</span></pre></td></tr></table></figure>
<h2 id="转发参数包"><a href="#转发参数包" class="headerlink" title="转发参数包"></a>转发参数包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename...Args&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">inline void StrVec::emplace_back(Args&amp;&amp;...args)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	alloc_construct(first_free++,std::forward&lt;Args&gt;(args)...);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;std::forward&lt;Args&gt;(args)...既扩展了模板参数包也扩展了函数参数包，std::forward&lt;Ti&gt;(ti)</span></pre></td></tr></table></figure>
<h2 id="定义函数模板特例化"><a href="#定义函数模板特例化" class="headerlink" title="定义函数模板特例化"></a>定义函数模板特例化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int compare(const char * const &amp;p1,const char * const &amp;p2)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return strcmp(p1,p2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;	&#x2F;&#x2F;该函数参数类型需要与下面这个模板对应的类型匹配</span></pre></td></tr><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int compare(const T&amp;,const T&amp;);</span></pre></td></tr></table></figure>
<p>一个特例化版本本质上是一个实例，会影响到函数匹配过程<br>模板及其特例化版本声明在同一个头文件中</p>
<h2 id="hash-类）模板的特例化"><a href="#hash-类）模板的特例化" class="headerlink" title="hash(类）模板的特例化"></a>hash(类）模板的特例化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;打开命名空间</span></pre></td></tr><tr><td class="code"><pre><span class="line">namespace std&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	template&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	struct hash&lt;Sales_data&gt;&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			typedef size_t&#x3D;result_type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			typedef Sales_data&#x3D;argument_type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			size_t operator()(const Sales_data &amp;s)const;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	size_t</span></pre></td></tr><tr><td class="code"><pre><span class="line">	hash&lt;Sales_data&gt;::operator()(const Sales_data &amp;s)const&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			return hash&lt;string&gt;()(s.bookNo)^</span></pre></td></tr><tr><td class="code"><pre><span class="line">						hash&lt;unsigned&gt;()(s.units_sold)^</span></pre></td></tr><tr><td class="code"><pre><span class="line">						hash&lt;double&gt;()(s.revenue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;&#x2F;&#x2F;关闭命名空间</span></pre></td></tr></table></figure>
<p>将各个结果进行异或运算得到整个对象完整的哈希值</p>
<h2 id="类模板部分特例化"><a href="#类模板部分特例化" class="headerlink" title="类模板部分特例化"></a>类模板部分特例化</h2><p>只能部分特例化类模板，不能部分特例化函数模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt; struct remove_reference&lt;T&amp;&gt;&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	typedef T type;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">template&lt;typename T&gt; struct remove_reference&lt;T&amp;&amp;&gt;&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	typedef T type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="特例化特定成员"><a href="#特例化特定成员" class="headerlink" title="特例化特定成员"></a>特例化特定成员</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void Foo&lt;int&gt;::Bar()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		-------</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这里我们只特例化Bar这个成员函数，其他的仍由模板提供</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语言</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 16 (中）</title>
    <url>/2019/12/02/C++%20Primer%2016(%E4%B8%AD)/</url>
    <content><![CDATA[<h2 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h2><p>通过显式实例化来避免在多个对象文件中实例化相同模板的开销</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern template declaration;</span></pre></td></tr><tr><td class="code"><pre><span class="line">template declaration;&#x2F;&#x2F;其中declaration的模板参数已被替换为实参</span></pre></td></tr></table></figure>
<a id="more"></a>
<p>注意：要将两个对象文件链接在一起<br>其中实例化定义会实例化所有成员，不管是不是要用到，所以用来显式实例化一个类模板的类型，必须能用于模板的所有成员</p>
<h2 id="智能指针模板"><a href="#智能指针模板" class="headerlink" title="智能指针模板"></a>智能指针模板</h2><p>shared_ptr 的删除器必须是指针或封装了指针的类，该删除器的类型直到运行时才知道，我们可以随时改变它的类型<br>通常，类成员的类型在运行时是不可以改变的，所以我们可以得知，shared_pte的删除器不是保存为成员的形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del? del(p):delete p;</span></pre></td></tr></table></figure>
<p>删除器的类型是unique_ptr对象类型的一部分，所以删除器的类型是编译时就知道的，就可以直接调用实例化的删除器，避免运行时开销<br>而shared_ptr使得用户重载删除器更加方便</p>
<h2 id="模板与类型转换"><a href="#模板与类型转换" class="headerlink" title="模板与类型转换"></a>模板与类型转换</h2><p>非const可以传给const的形参<br>若形参不是引用，数组和函数可以转换为指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt; T foun(const T&amp;,const T&amp;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">foun(a,b);&#x2F;&#x2F;a,b为数组名，错误</span></pre></td></tr></table></figure>
<h2 id="模板显式实参"><a href="#模板显式实参" class="headerlink" title="模板显式实参"></a>模板显式实参</h2><p>当返回类型与参数列表中任何类型都不相同时，要用户控制模板实例化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T1,typename T2,typename T3&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">T1 sum(T2,T3)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">auto val3&#x3D;sum&lt;long long&gt;(a,b);&#x2F;&#x2F;也可以显式指定3个参数</span></pre></td></tr></table></figure>
<h2 id="尾置返回类型"><a href="#尾置返回类型" class="headerlink" title="尾置返回类型"></a>尾置返回类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">auto (T *beg,T *end)-&gt;decltype(*beg)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return *beg;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="使用类型转换模板"><a href="#使用类型转换模板" class="headerlink" title="使用类型转换模板"></a>使用类型转换模板</h2><p>头文件type_traits</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remove_reference</span></pre></td></tr><tr><td class="code"><pre><span class="line">remove_pointer</span></pre></td></tr><tr><td class="code"><pre><span class="line">remove_extent      &#x2F;&#x2F;X[n]-&gt;X </span></pre></td></tr><tr><td class="code"><pre><span class="line">remove_all_extents	&#x2F;&#x2F;X[n1][n2]... -&gt;X</span></pre></td></tr><tr><td class="code"><pre><span class="line">add_pointer</span></pre></td></tr><tr><td class="code"><pre><span class="line">add_const</span></pre></td></tr><tr><td class="code"><pre><span class="line">add_lvalue_reference</span></pre></td></tr><tr><td class="code"><pre><span class="line">add_rvalue_reference</span></pre></td></tr><tr><td class="code"><pre><span class="line">make_signed</span></pre></td></tr><tr><td class="code"><pre><span class="line">make_unsigned</span></pre></td></tr></table></figure>
<p>类型转换模板的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typename remove_reference&lt;decltype(*beg)&gt;::type</span></pre></td></tr></table></figure>
<h2 id="指向函数模板实例的指针"><a href="#指向函数模板实例的指针" class="headerlink" title="指向函数模板实例的指针"></a>指向函数模板实例的指针</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt; int compare(const T&amp;,const T&amp;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">int (*ptf)(const int&amp;,const int&amp;)&#x3D;compare;</span></pre></td></tr></table></figure>
<p>显式指定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func(compare&lt;int&gt;);&#x2F;&#x2F;接受一个函数指针，指向一个函数实例</span></pre></td></tr></table></figure>
<h2 id="模板形参是引用"><a href="#模板形参是引用" class="headerlink" title="模板形参是引用"></a>模板形参是引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt; void f1(T&amp;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;传递进来的实参必须是左值</span></pre></td></tr><tr><td class="code"><pre><span class="line">template&lt;typename T&gt; void f2(const T&amp;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;实参可以是任何类型（包括右值）</span></pre></td></tr><tr><td class="code"><pre><span class="line">template&lt;typename T&gt; void f3(T&amp;&amp;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;实参可以是任何类型，若实参为右值，T为该右值的类型</span></pre></td></tr></table></figure>
<p>若f3发生重载，则T绑定到非const右值<br>f3这样的右值引用形参通常用于模板转发其实参或模板被重载</p>
<h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>若用一个int对象传入f3，此时T推断为int&amp;,发生引用折叠。<br>引用折叠除了T&amp;&amp; &amp;&amp;折叠为T&amp;&amp;，其他都是折叠为T&amp;</p>
<p>可以通过类型别名或通过模板类型参数间接定义引用的引用，引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语言</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 16 （上）</title>
    <url>/2019/12/02/C++%20Primer%2016(%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h2 id="非类型参数"><a href="#非类型参数" class="headerlink" title="非类型参数"></a>非类型参数</h2><p>在模板中可以通过一个特定的类型名定义非类型参数<br>非类型参数：<br>1、整型     （实参要求：常量表达式）<br>2、指向对象或函数的指针 （实参要求：静态生存期）<br>3、左值引用    （实参要求：静态生存期）<br>实参要求的原因：模板转换成实例发生在编译的时候<br>（指针参数也可以用nullptr或0来实例化）</p>
<p>模板非类型参数是一个常量值</p>
<a id="more"></a>
<h2 id="模板的声明和定义"><a href="#模板的声明和定义" class="headerlink" title="模板的声明和定义"></a>模板的声明和定义</h2><p>模板的inline和constexpr声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;tepename T&gt; inline T min(const T&amp;,const T&amp;)</span></pre></td></tr></table></figure>
<p>函数模板和类模板成员函数的定义都在头文件</p>
<p>类模板成员函数的类外定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ret-type B&lt;T&gt;::member_name(parm-list)&#123;--------&#125;</span></pre></td></tr></table></figure>
<p>一个类模板的成员函数只有程序用到它时才进行实例化，因此即使某种类型不能完全符合模板操作的要求，我们仍然能使用该类型实例化类</p>
<p>在类模板的作用域内，我们可以直接使用模板名而不用提供实参</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt; class B&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	--------</span></pre></td></tr><tr><td class="code"><pre><span class="line">	B&amp; operator++();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>在类模板外定义的成员函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt; </span></pre></td></tr><tr><td class="code"><pre><span class="line">B&lt;T&gt;  B&lt;T&gt;::operator++(int) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	------</span></pre></td></tr><tr><td class="code"><pre><span class="line">	B ret &#x3D;*this;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="模板的友元"><a href="#模板的友元" class="headerlink" title="模板的友元"></a>模板的友元</h2><p>如果类模板有一个非模板友元，该友元可以访问所有类模板实例<br>如果友元本身是一个模板，类可以授权可以所有友元模板实例，也可以只授权给特定实例</p>
<p>要使模板的一个实例作为友元，需要先声明这个模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename&gt; class A;</span></pre></td></tr><tr><td class="code"><pre><span class="line">template &lt;typename T&gt; class B&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	friend class A&lt;T&gt;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	friend class A&lt;B&gt;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	template &lt;typename X&gt; friend class C;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	friend T; &#x2F;&#x2F;将访问权限授予用来实例化B的类型，也可以用内置类型来实例化该类</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="模板的类型别名"><a href="#模板的类型别名" class="headerlink" title="模板的类型别名"></a>模板的类型别名</h2><p>可以定义一个typedef来引用实例化的类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef B&lt;string&gt; BB;</span></pre></td></tr></table></figure>
<p>为类模板定义一个类型别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt; using twin&#x3D;pair&lt;T,T&gt;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">twin &lt;string&gt; authors;</span></pre></td></tr></table></figure>
<p>固定一个或多个模板参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt; using parTo&#x3D;pair&lt;T,unsigned&gt;;</span></pre></td></tr></table></figure>
<h2 id="模板的Static数据成员"><a href="#模板的Static数据成员" class="headerlink" title="模板的Static数据成员"></a>模板的Static数据成员</h2><p>类模板的每个实例都有其自己的static数据成员<br>static数据成员的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">size_t F&lt;T&gt;::ctr &#x3D; 0;</span></pre></td></tr></table></figure>
<p>访问static数据成员</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Foo&lt;int&gt; f;</span></pre></td></tr><tr><td class="code"><pre><span class="line">auto ct&#x3D;Foo&lt;int&gt;::count();</span></pre></td></tr><tr><td class="code"><pre><span class="line">ct&#x3D;f.count();</span></pre></td></tr></table></figure>
<p>用：：访问static成员和类型成员，默认情况下，C++假定通过：：访问的不是类型。可以通过显式说明访问的名字是类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">typename T::value_type top(const T&amp; c)-------</span></pre></td></tr></table></figure>
<p>一个static成员函数只有在使用时才会实例化</p>
<h2 id="模板参数名要求"><a href="#模板参数名要求" class="headerlink" title="模板参数名要求"></a>模板参数名要求</h2><p>在模板内不能重用模板参数名（用作变量名）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T,typename T&gt; &#x2F;&#x2F;错误</span></pre></td></tr></table></figure>

<h2 id="默认模板实参的使用"><a href="#默认模板实参的使用" class="headerlink" title="默认模板实参的使用"></a>默认模板实参的使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T,typename F&#x3D;less&lt;T&gt;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int compare (const T&amp; a,const T&amp; b, F f&#x3D;F())--------</span></pre></td></tr></table></figure>
<p>对于模板参数，只有当它右侧所有参数都有默认实参时，它才可以有默认实参，有默认实参的时候，我们可以这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A&lt;&gt; a;</span></pre></td></tr></table></figure>
<h2 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h2><p>本身是模板的成员函数不能是虚函数</p>
<p>使用具有成员模板的类（调用运算符函数）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;int,DebugDelete&gt; p (new int , DebugDelete());</span></pre></td></tr><tr><td class="code"><pre><span class="line">unique_ptr&lt;string,DebugDelete&gt; p (new string , DebugDelete());</span></pre></td></tr></table></figure>
<p>类模板的成员模板的外定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">template &lt;typename A&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	B&lt;T&gt;::B(A a,A b)-------</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C++ Primer</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语言</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2019/12/02/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="堆排序原理"><a href="#堆排序原理" class="headerlink" title="堆排序原理"></a>堆排序原理</h2><p>首先利用堆的性质维护来建立最大堆，然后不断将最大堆中首元素与尾元素交换，并减少相应的堆中的有效元素数量，再以首元素为标志点进行堆的性质维护</p>
<a id="more"></a>
<p>注意：i的左孩子为2i,右孩子为2i+1,父结点为i/2往下取整<br>这里用的n是元素个数，再通过n来计算下标，而不是直接传下标</p>
<h2 id="堆性质维护算法（C-）"><a href="#堆性质维护算法（C-）" class="headerlink" title="堆性质维护算法（C++）"></a>堆性质维护算法（C++）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;堆的性质维护算法</span></pre></td></tr><tr><td class="code"><pre><span class="line">void max_heapify(int arr[], int n) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int left_child, right_child, largest;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	left_child &#x3D; 2 * n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	right_child &#x3D; 2 * n + 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (left_child &lt;&#x3D; len &amp;&amp; arr[left_child - 1] &gt; arr[n - 1]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		largest &#x3D; left_child;	&#x2F;&#x2F;len表示堆的有效元素数量</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else largest &#x3D; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (right_child &lt;&#x3D; len &amp;&amp; arr[right_child - 1] &gt; arr[largest - 1]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		largest &#x3D; right_child;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (largest !&#x3D; n) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		swap(arr[n - 1], arr[largest - 1]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		max_heapify(arr, largest);	&#x2F;&#x2F;largest处的值变小了，所以要对他进行维护</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h2><p>建堆时在n/2处可能交换某个元素，而在n/2-1处三个元素中那个相同的元素却没有被交换，此时元素的相对次序发生改变，所以是不稳定的</p>
<h2 id="建堆（C-）"><a href="#建堆（C-）" class="headerlink" title="建堆（C++）"></a>建堆（C++）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;建立最大堆</span></pre></td></tr><tr><td class="code"><pre><span class="line">void build_max_heap(int arr[], int n) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	for (int i &#x3D; n &#x2F; 2; i &gt; 0; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		max_heapify(arr, i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;	&#x2F;&#x2F;叶节点集合为A【n&#x2F;2+1---n】，性质维护是从n&#x2F;2到1；</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="堆排序（C-）"><a href="#堆排序（C-）" class="headerlink" title="堆排序（C++）"></a>堆排序（C++）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;堆排序算法</span></pre></td></tr><tr><td class="code"><pre><span class="line">void heap_sort(int arr[], int n) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	build_max_heap(arr, n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	for (int i &#x3D; len; i &gt; 1; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		swap(arr[0], arr[i-1]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		len--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		max_heapify(arr, 1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="测试-（C-）"><a href="#测试-（C-）" class="headerlink" title="测试 （C++）"></a>测试 （C++）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;测试代码</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void heap_sort(int arr[], int n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">void build_max_heap(int arr[], int n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">void max_heapify(int arr[], int n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">int len;	&#x2F;&#x2F;用一个全局的len来表示有效长度</span></pre></td></tr><tr><td class="code"><pre><span class="line">int main() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int arr[] &#x3D; &#123; 1,5,3,11,4,6,7,9,8 &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	len &#x3D; sizeof(arr) &#x2F; 4;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	heap_sort(arr, len);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	for (auto x : arr) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		cout &lt;&lt; x &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2019/12/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="快速排序原理"><a href="#快速排序原理" class="headerlink" title="快速排序原理"></a>快速排序原理</h2><p>首先通过一趟排序将数字分割两半，其中一半的元素全部小于另外一半，然后用同样的方式递归处理两边的数组，直到数组有序</p>
<a id="more"></a>
<h2 id="代码实现（C-）"><a href="#代码实现（C-）" class="headerlink" title="代码实现（C++）"></a>代码实现（C++）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void quickSort(int a[], int low ,int high)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if(low&lt;high)  &#x2F;&#x2F;递归的终止条件，只有数组内元素大于1时才进行排序</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		int i &#x3D; low, j &#x3D; high;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">		int x &#x3D; a[low];                                     </span></pre></td></tr><tr><td class="code"><pre><span class="line">		while(i&lt;j)  </span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		  while(i&lt;j &amp;&amp; a[j] &gt;&#x3D; x) j--;  &#x2F;&#x2F;右边开始，找到不满足条件的j</span></pre></td></tr><tr><td class="code"><pre><span class="line">		  if(i&lt;j) a[i++] &#x3D; a[j];   &#x2F;&#x2F;若此时扫描未完成，将其代替哨兵，哨兵右移</span></pre></td></tr><tr><td class="code"><pre><span class="line">		  while(i&lt;j &amp;&amp; a[i] &lt;&#x3D; x) i++; &#x2F;&#x2F;左边开始，找到不满足条件的i</span></pre></td></tr><tr><td class="code"><pre><span class="line">		  if(i&lt;j) a[j--] &#x3D; a[i];  </span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">	     a[i] &#x3D; x;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">		quickSort(a, low ,i-1);  </span></pre></td></tr><tr><td class="code"><pre><span class="line">		quickSort(a, i+1 ,high);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最坏情况下的时间复杂度：O（n^2)<br>平均情况的时间复杂度：O（nLog2n)<br>最好的时间复杂度：O（nLog2n)<br>空间复杂度：  O(Log2n)-O(n)<br>稳定性：不稳定</p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>快速排序的一次划分算法从两头交替搜索，直到low和high重合，因此其时间复杂度是O(n)；而整个快速排序算法的时间复杂度与划分的趟数有关。</p>
<p>理想的情况，每次划分所选择的中间数恰好将当前序列几乎等分，经过logn趟划分，便可得到长度为1的子表。此时，整个算法的时间复杂度为O(nlogn)。 </p>
<p>最坏的情况，每次所选的中间数是当前序列中的最大或最小元素，这使得每次划分所得的子表中一个为空表，另一子表的长度为原表的长度-1。此时，整个排序算法的时间复杂度为O(n^2)。</p>
<p>可以证明，快速排序的平均时间复杂度也是O(nlogn)。因此，该排序方法被认为是目前最好的一种内部排序方法。 </p>
<p>从空间性能上看，尽管快速排序只需要一个元素的辅助空间，但快速排序需要一个栈空间来实现递归。</p>
<p>最好的情况下，即快速排序的每一趟排序都将元素序列均匀地分割成长度相近的两个子表，所需栈的最大深度为log(n+1)；此时空间复杂度为O（logn)<br>但最坏的情况下，栈的最大深度为n。此时，快速排序的空间复杂度为O(n)。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2019/12/01/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>因为KMP算法优化了朴素字符串匹配算法，所以在看KMP算法之前建议先看一下朴素字符串匹配算法<br><a href="https://czp-love-code.github.io/2019/12/01/朴素字符串匹配算法/#more" target="_blank" rel="noopener">朴素字符串匹配算法</a></p>
<a id="more"></a>
<h2 id="分析朴素算法"><a href="#分析朴素算法" class="headerlink" title="分析朴素算法"></a>分析朴素算法</h2><p> 朴素算法在进行扫描的时候每次不匹配都是将A的初始扫描点后移一位，再重新进行扫描，而在这个过程中会有很多没有必要的比对情况出现。比如我们对字符串“REGRET”和“REGROW”，在第一次扫描失配的时候，我们就已经知道<code>A[1]</code>必然不等于<code>B[0]</code>，那么就没有必要再进行这两个字符的比对了</p>
<p>想象A上B下进行比对，此时我们就应该跳过<code>A[1]</code>跟<code>B[0]</code>这样已经知道结果的比对。既然我们知道了<code>A[3]=B[0]</code>,那么我们再继续比对<code>A[4]</code>和<code>B[1]</code>就OK了</p>
<h2 id="KMP算法思想"><a href="#KMP算法思想" class="headerlink" title="KMP算法思想"></a>KMP算法思想</h2><p> A字符串的扫描位置不断后移，而B字符串的扫描位置 j 若是不匹配就寻找下一个 j 进行比对， 这次比对是对从失配的A[ i ]开始的，我们就要找到B[ j ]（失配位置）前面子串的前后两个相等的两个真子串，比如B串中子串“REGR”的前后两个相等的真子串就是”R“，然后将B串右移使得A[ i ] 前面的子串跟B[next[ j ] ] （此时即为B[1]）前面的子串匹配，再开始进行比对</p>
<h2 id="构造next表"><a href="#构造next表" class="headerlink" title="构造next表"></a>构造next表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* BuildNext(string B) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int n &#x3D; B.size(), j &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int* N &#x3D; new int[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int t &#x3D; N[0] &#x3D; -1;	&#x2F;&#x2F;这里记得先初始化N[0]为-1；</span></pre></td></tr><tr><td class="code"><pre><span class="line">	while (j &lt; n - 1) &#123;	&#x2F;&#x2F;这里不取最后一个元素是因为讨论的是“当前元素不匹配，然后要找前面的子串自匹配的情况，然后找到下一个j值</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (t &lt; 0||B[j] &#x3D;&#x3D; B[t] ) &#123;		&#x2F;&#x2F;注意这里的短路求值</span></pre></td></tr><tr><td class="code"><pre><span class="line">			j++; t++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			N[j] &#x3D; t;		&#x2F;&#x2F;此代码可以优化</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		else t &#x3D; N[t];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return N;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="next表构造优化"><a href="#next表构造优化" class="headerlink" title="next表构造优化"></a>next表构造优化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* BuildNext(string B) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int n &#x3D; B.size(), j &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int* N &#x3D; new int[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int t &#x3D; N[0] &#x3D; -1;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	while (j &lt; n - 1) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (t &lt; 0||B[j] &#x3D;&#x3D; B[t] ) &#123;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">			j++; t++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			N[j] &#x3D; (B[j] !&#x3D; B[t]) ? t : N[t];	&#x2F;&#x2F;修改了next表的定义</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;	&#x2F;&#x2F;最后的元素不与之前匹配失败的元素相等</span></pre></td></tr><tr><td class="code"><pre><span class="line">		else t &#x3D; N[t];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return N;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="KMP主算法"><a href="#KMP主算法" class="headerlink" title="KMP主算法"></a>KMP主算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;KMP主算法 O（m) 模式串长度</span></pre></td></tr><tr><td class="code"><pre><span class="line">int match(string A, string B) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int m &#x3D; A.size();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int n &#x3D; B.size();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int i &#x3D; 0, j &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	while (i &lt; m &amp;&amp; j &lt; n) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if ( j &lt; 0 || A[i] &#x3D;&#x3D; B[j]) &#123;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">			i++; j++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		else j &#x3D; next[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	delete[ ] next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return i - j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O（n+m）</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>字符串匹配</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素字符串匹配算法</title>
    <url>/2019/12/01/%E6%9C%B4%E7%B4%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定两个字符串A和B，我们要判断A中是否包含B，并找到A与B相等的第一个位置下标</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>我们将两个字符串都从头开始扫描，然后若是扫描的两个位置字符相同，则两个字符串继续往后扫描。若是扫描的位置字符不相同，那么我们就将字符串B从头开始扫描，而字符串A就从刚才扫描它的初始位置往后挪一位接着扫描</p>
<a id="more"></a>
<h2 id="算法实现（C-）"><a href="#算法实现（C-）" class="headerlink" title="算法实现（C++）"></a>算法实现（C++）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;朴素字符串匹配算法</span></pre></td></tr><tr><td class="code"><pre><span class="line">int match(string A, string B) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int m &#x3D; A.size(), i &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int n &#x3D; B.size(), j &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	while (i &lt; m &amp;&amp; j &lt; n) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (A[i] &#x3D;&#x3D; B[j]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			i++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			j++;	&#x2F;&#x2F;若匹配，两个字符串同时往后扫描</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			i &#x3D; i-j+1;	&#x2F;&#x2F;字符串A扫描回到原点并后移一位</span></pre></td></tr><tr><td class="code"><pre><span class="line">			j &#x3D; 0;		&#x2F;&#x2F;重置字符串B的扫描</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		return i - j;	&#x2F;&#x2F;若值大于m-n时不存在匹配</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;                             </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>朴素算法至多迭代m-n+1轮，各轮至多n次比对，因n&gt;&gt;m，所以其时间复杂度为O（nm)</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>字符串匹配</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2019/12/01/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="插入排序的原理"><a href="#插入排序的原理" class="headerlink" title="插入排序的原理"></a>插入排序的原理</h2><p>插入排序其实就像是我们平时玩扑克牌时的取牌操作，初始时我们手中没有任何牌，拿到第一张牌之后自然就不用做任何的移动操作。接着我们继续拿到牌，将每次新拿到的牌跟前面（已排序）的牌依次进行对比，然后将之放到正确的位置上。</p>
<a id="more"></a>
<h2 id="插入排序的实现（C"><a href="#插入排序的实现（C" class="headerlink" title="插入排序的实现（C++)"></a>插入排序的实现（C++)</h2><p>按照原理我们首先实现直接插入排序（直插法）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;直插法</span></pre></td></tr><tr><td class="code"><pre><span class="line">void insertSort(int arr[], int n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;	&#x2F;&#x2F;假设我们手中已经有第一张牌</span></pre></td></tr><tr><td class="code"><pre><span class="line">	for (int j &#x3D; 1; j &lt; n; ++j)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">		int key &#x3D;arr[j];	&#x2F;&#x2F;保留新拿到的牌值</span></pre></td></tr><tr><td class="code"><pre><span class="line">		int i &#x3D; j - 1;		&#x2F;&#x2F;新牌前面待对比的牌下标</span></pre></td></tr><tr><td class="code"><pre><span class="line">		while(i&gt;&#x3D;0&amp;&amp;key&lt;arr[i])	</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;		&#x2F;&#x2F;当key小时不断对前面比它大的元素往后移动</span></pre></td></tr><tr><td class="code"><pre><span class="line">			arr[i+1] &#x3D; arr[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">			--i;		&#x2F;&#x2F;然后继续循环对比前面一个元素</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;		&#x2F;&#x2F;当i的元素值大于key或i&#x3D;-1时退出循环</span></pre></td></tr><tr><td class="code"><pre><span class="line">		arr[i+1] &#x3D; key;		&#x2F;&#x2F;最后i+1即为该新牌的位置下标</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>最好情况：数组已经有序，此时只需要进行n-1次比较，时间复杂度为O（n）;</p>
<p>最坏情况是数组逆序排序，此时需要进行n(n-1)/2次比较以及n-1次赋值操作（插入）；</p>
<p>平均来说插入排序算法的复杂度为O(n^2)。</p>
<p>直接插入排序采用就地排序（in-place)，空间复杂度为O（1）</p>
<h3 id="插入排序使用时机"><a href="#插入排序使用时机" class="headerlink" title="插入排序使用时机"></a>插入排序使用时机</h3><p>不适合对大量数据进行排序应用，但排序数量级小于1000时插入排序的效率还不错，可以考虑使用。</p>
<h2 id="二分法插入排序"><a href="#二分法插入排序" class="headerlink" title="二分法插入排序"></a>二分法插入排序</h2><p>直插法每次都是将新牌的值与前面的序列元素依次对比，那么我们能不能更快地确定新牌的位置呢？<br>答案当然是有的，由于我们当前手中的牌都是已经牌好序的，那么我们就可以通过直接跟当前牌最中间的牌值进行比较，然后就可以进一步确定牌的位置</p>
<h3 id="二分插入法的实现（C-）"><a href="#二分插入法的实现（C-）" class="headerlink" title="二分插入法的实现（C++）"></a>二分插入法的实现（C++）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二插法找到该新牌的位置</span></pre></td></tr><tr><td class="code"><pre><span class="line">int BinarySearch(int array[], int start, int end, int key)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    while (start &lt;&#x3D; end)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        int middle &#x3D; (start + end) &#x2F; 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        int middleData &#x3D; array[middle];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (middleData &gt; key)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            end &#x3D; middle - 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        else</span></pre></td></tr><tr><td class="code"><pre><span class="line">            start &#x3D; middle + 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return start;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;总的实现函数，找到位置后进行元素移动</span></pre></td></tr><tr><td class="code"><pre><span class="line">void BinaryInsertSort(int array[], int n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;		判断数组是否需要排序</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (array &#x3D;&#x3D; NULL || n &lt; 0)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int i, j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (i &#x3D; 1; i &lt; n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;		&#x2F;&#x2F;确认该新牌需要移动</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (array[i]&lt;array[i - 1])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            int temp &#x3D; array[i];	&#x2F;&#x2F;提前保存新牌的值</span></pre></td></tr><tr><td class="code"><pre><span class="line">            int insertIndex &#x3D; BinarySearch(array,0,i,array[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            for (j &#x3D; i - 1; j&gt;&#x3D;insertIndex; j--) &#x2F;&#x2F;将比新牌值大的元素后移</span></pre></td></tr><tr><td class="code"><pre><span class="line">                array[j + 1] &#x3D; array[j];        </span></pre></td></tr><tr><td class="code"><pre><span class="line">            array[insertIndex] &#x3D; temp;    &#x2F;&#x2F;最后插入元素</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>这个二分查找的算法并不会因为等于某一个值而停止查找，它将查找整个序列直到start&lt;=end条件不满足而得到插入的位置，所以对于长度为n的数组来说，比较次数为log2n ,时间复杂度为O（log2n）。二分插入排序的主要操作为比较+后移赋值，则：<br>最坏情况：每次都在有序序列的起始位置插入，则整个有序序列的元素需要后移，时间复杂度为O（n^2）</p>
<p>最好情况：待排序数组本身就是正序的，每个元素所在位置即为它的插入位置，此时时间复杂度仅为比较时的时间复杂度，为O(log2n)</p>
<p>平均情况：O（n^2）</p>
<p>空间复杂度上， 二分插入排序也是就地排序算法，它的空间复杂度为O（1）.</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
</search>

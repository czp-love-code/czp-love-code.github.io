<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>KMP算法</title>
    <url>/2019/12/01/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>因为KMP算法优化了朴素字符串匹配算法，所以在学习KMP算法之前建议先学习一下朴素字符串匹配算法<br><a href="https://czp-love-code.github.io/2019/12/01/朴素字符串匹配算法/#more" target="_blank" rel="noopener">朴素字符串匹配算法</a></p>
<a id="more"></a>
<h2 id="分析朴素算法"><a href="#分析朴素算法" class="headerlink" title="分析朴素算法"></a>分析朴素算法</h2><p> 朴素算法在进行扫描的时候每次不匹配都是将A的初始扫描点后移一位，再重新进行扫描，而在这个过程中会有很多没有必要的比对情况出现，比如我们比对“REGRET”和“REGROW”，在第一次扫描失配的时候，我们就会发现，通过前面的比对我们已经知道两个串前面四个字符都是匹配的，而且<code>A[3]=B[3]=B[0]</code>,那么这个时候我们再重头开始扫描已经没有必要了，因为我们知道<code>A[1]</code>必然不等于<code>B[0]</code><br> <img src="./KMP.png" alt="1"></p>
<p>想象A上B下进行比对，此时我们就应该跳过<code>A[1]</code>跟<code>B[0]</code>这样已经知道结果的比对。既然我们知道了<code>A[3]=B[0]</code>,那么我们再继续比对<code>A[4]</code>和<code>B[1]</code>就OK了</p>
<h2 id="KMP算法思想"><a href="#KMP算法思想" class="headerlink" title="KMP算法思想"></a>KMP算法思想</h2><p> 第二次比对是对从失配的A[ i ]开始的，那么我们就要找到B[ j ]（失配位置）前面子串的前后两个相等的两个真子串，比如B串中子串“REGR”的前后两个相等的真子串就是”R“，然后将B串右移使得A[ i ] 前面的子串跟B[next[ j ] ] 前面的子串匹配，再开始进行比对             </p>
<h2 id="构造next表"><a href="#构造next表" class="headerlink" title="构造next表"></a>构造next表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* BuildNext(string B) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int n &#x3D; B.size(), j &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int* N &#x3D; new int[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int t &#x3D; N[0] &#x3D; -1;	&#x2F;&#x2F;这里记得先初始化N[0]为-1；</span></pre></td></tr><tr><td class="code"><pre><span class="line">	while (j &lt; n - 1) &#123;	&#x2F;&#x2F;这里不取最后一个元素是因为讨论的是“当前元素不匹配，然后要找前面的子串自匹配的情况，然后找到下一个j值</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (t &lt; 0||B[j] &#x3D;&#x3D; B[t] ) &#123;		&#x2F;&#x2F;注意这里的短路求值</span></pre></td></tr><tr><td class="code"><pre><span class="line">			j++; t++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			N[j] &#x3D; t;		&#x2F;&#x2F;此代码可以优化</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		else t &#x3D; N[t];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return N;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="next表构造优化"><a href="#next表构造优化" class="headerlink" title="next表构造优化"></a>next表构造优化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* BuildNext(string B) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int n &#x3D; B.size(), j &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int* N &#x3D; new int[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int t &#x3D; N[0] &#x3D; -1;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	while (j &lt; n - 1) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (t &lt; 0||B[j] &#x3D;&#x3D; B[t] ) &#123;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">			j++; t++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			N[j] &#x3D; (B[j] !&#x3D; B[t]) ? t : N[t];	&#x2F;&#x2F;修改了next表的定义</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;	&#x2F;&#x2F;最后的元素不与之前匹配失败的元素相等</span></pre></td></tr><tr><td class="code"><pre><span class="line">		else t &#x3D; N[t];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return N;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="KMP主算法"><a href="#KMP主算法" class="headerlink" title="KMP主算法"></a>KMP主算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;KMP主算法 O（m) 模式串长度</span></pre></td></tr><tr><td class="code"><pre><span class="line">int match(string A, string B) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int m &#x3D; A.size();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int n &#x3D; B.size();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int i &#x3D; 0, j &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	while (i &lt; m &amp;&amp; j &lt; n) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if ( j &lt; 0 || A[i] &#x3D;&#x3D; B[j]) &#123;	&#x2F;&#x2F;注意这里的短路求值</span></pre></td></tr><tr><td class="code"><pre><span class="line">			i++; j++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		else j &#x3D; next[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	delete[ ] next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return i - j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O（n+m）</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>字符串匹配</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素字符串匹配算法</title>
    <url>/2019/12/01/%E6%9C%B4%E7%B4%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定两个字符串A和B，我们要判断A中是否包含B，并找到A与B相等的第一个位置下标</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>我们将两个字符串都从头开始扫描，然后若是扫描的两个位置字符相同，则两个字符串继续往后扫描。若是扫描的位置字符不相同，那么我们就将字符串B从头开始扫描，而字符串A就从刚才扫描它的初始位置往后挪一位接着扫描</p>
<a id="more"></a>
<h2 id="算法实现（C-）"><a href="#算法实现（C-）" class="headerlink" title="算法实现（C++）"></a>算法实现（C++）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;朴素字符串匹配算法</span></pre></td></tr><tr><td class="code"><pre><span class="line">int match(string A, string B) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int m &#x3D; A.size(), i &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	int n &#x3D; B.size(), j &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	while (i &lt; m &amp;&amp; j &lt; n) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (A[i] &#x3D;&#x3D; B[j]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			i++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			j++;	&#x2F;&#x2F;若匹配，两个字符串同时往后扫描</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			i &#x3D; i-j+1;	&#x2F;&#x2F;字符串A扫描回到原点并后移一位</span></pre></td></tr><tr><td class="code"><pre><span class="line">			j &#x3D; 0;		&#x2F;&#x2F;重置字符串B的扫描</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		return i - j;	&#x2F;&#x2F;若值大于m-n时不存在匹配</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;                             </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>朴素算法至多迭代m-n+1轮，各轮至多n次比对，因n&gt;&gt;m，所以其时间复杂度为O（nm)</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>字符串匹配</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2019/12/01/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="插入排序的原理"><a href="#插入排序的原理" class="headerlink" title="插入排序的原理"></a>插入排序的原理</h2><p>插入排序其实就像是我们平时玩扑克牌时的取牌操作，初始时我们手中没有任何牌，拿到第一张牌之后自然就不用做任何的移动操作。接着我们继续拿到牌，将每次新拿到的牌跟前面（已排序）的牌依次进行对比，然后将之放到正确的位置上。</p>
<a id="more"></a>
<h2 id="插入排序的实现（C"><a href="#插入排序的实现（C" class="headerlink" title="插入排序的实现（C++)"></a>插入排序的实现（C++)</h2><p>按照原理我们首先实现直接插入排序（直插法）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;直插法</span></pre></td></tr><tr><td class="code"><pre><span class="line">void insertSort(int arr[], int n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;	&#x2F;&#x2F;假设我们手中已经有第一张牌</span></pre></td></tr><tr><td class="code"><pre><span class="line">	for (int j &#x3D; 1; j &lt; n; ++j)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">		int key &#x3D;arr[j];	&#x2F;&#x2F;保留新拿到的牌值</span></pre></td></tr><tr><td class="code"><pre><span class="line">		int i &#x3D; j - 1;		&#x2F;&#x2F;新牌前面待对比的牌下标</span></pre></td></tr><tr><td class="code"><pre><span class="line">		while(key&lt;arr[i]&amp;&amp;i&gt;&#x3D;0)	</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;		&#x2F;&#x2F;当key小时不断对前面比它大的元素往后移动</span></pre></td></tr><tr><td class="code"><pre><span class="line">			arr[i+1] &#x3D; arr[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">			--i;		&#x2F;&#x2F;然后继续循环对比前面一个元素</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;		&#x2F;&#x2F;当i的元素值大于key或i&#x3D;-1时退出循环</span></pre></td></tr><tr><td class="code"><pre><span class="line">		arr[i+1] &#x3D; key;		&#x2F;&#x2F;最后i+1即为该新牌的位置下标</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>最好情况：数组已经有序，此时只需要进行n-1次比较，时间复杂度为O（n）;</p>
<p>最坏情况是数组逆序排序，此时需要进行n(n-1)/2次比较以及n-1次赋值操作（插入）；</p>
<p>平均来说插入排序算法的复杂度为O(n^2)。</p>
<p>直接插入排序采用就地排序（in-place)，空间复杂度为O（1）</p>
<h3 id="插入排序使用时机"><a href="#插入排序使用时机" class="headerlink" title="插入排序使用时机"></a>插入排序使用时机</h3><p>不适合对大量数据进行排序应用，但排序数量级小于1000时插入排序的效率还不错，可以考虑使用。</p>
<h2 id="二分法插入排序"><a href="#二分法插入排序" class="headerlink" title="二分法插入排序"></a>二分法插入排序</h2><p>直插法每次都是将新牌的值与前面的序列元素依次对比，那么我们能不能更快地确定新牌的位置呢？<br>答案当然是有的，由于我们当前手中的牌都是已经牌好序的，那么我们就可以通过直接跟当前牌最中间的牌值进行比较，然后就可以进一步确定牌的位置</p>
<h3 id="二分插入法的实现（C-）"><a href="#二分插入法的实现（C-）" class="headerlink" title="二分插入法的实现（C++）"></a>二分插入法的实现（C++）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;二插法找到该新牌的位置</span></pre></td></tr><tr><td class="code"><pre><span class="line">int BinarySearch(int array[], int start, int end, int key)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    while (start &lt;&#x3D; end)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        int middle &#x3D; (start + end) &#x2F; 2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        int middleData &#x3D; array[middle];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (middleData &gt; key)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            end &#x3D; middle - 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        else</span></pre></td></tr><tr><td class="code"><pre><span class="line">            start &#x3D; middle + 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return start;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;总的实现函数，找到位置后进行元素移动</span></pre></td></tr><tr><td class="code"><pre><span class="line">void BinaryInsertSort(int array[], int n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;		判断数组是否需要排序</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (array &#x3D;&#x3D; NULL || n &lt; 0)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int i, j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (i &#x3D; 1; i &lt; n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;		&#x2F;&#x2F;确认该新牌需要移动</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (array[i]&lt;array[i - 1])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            int temp &#x3D; array[i];	&#x2F;&#x2F;提前保存新牌的值</span></pre></td></tr><tr><td class="code"><pre><span class="line">            int insertIndex &#x3D; BinarySearch(array,0,i,array[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            for (j &#x3D; i - 1; j&gt;&#x3D;insertIndex; j--) &#x2F;&#x2F;将比新牌值大的元素后移</span></pre></td></tr><tr><td class="code"><pre><span class="line">                array[j + 1] &#x3D; array[j];        </span></pre></td></tr><tr><td class="code"><pre><span class="line">            array[insertIndex] &#x3D; temp;    &#x2F;&#x2F;最后插入元素</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>这个二分查找的算法并不会因为等于某一个值而停止查找，它将查找整个序列直到start&lt;=end条件不满足而得到插入的位置，所以对于长度为n的数组来说，比较次数为log2n ,时间复杂度为O（log2n）。二分插入排序的主要操作为比较+后移赋值，则：<br>最坏情况：每次都在有序序列的起始位置插入，则整个有序序列的元素需要后移，时间复杂度为O（n^2）</p>
<p>最好情况：待排序数组本身就是正序的，每个元素所在位置即为它的插入位置，此时时间复杂度仅为比较时的时间复杂度，为O(log2n)</p>
<p>平均情况：O（n^2）</p>
<p>空间复杂度上， 二分插入排序也是就地排序算法，它的空间复杂度为O（1）.</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>暗夜--撕裂</title>
    <url>/2019/11/29/%E6%9A%97%E5%A4%9C--%E6%92%95%E8%A3%82/</url>
    <content><![CDATA[<h2 id="欢迎来到我的博客"><a href="#欢迎来到我的博客" class="headerlink" title="欢迎来到我的博客"></a>欢迎来到我的博客</h2><h3 id="搭建这个网站的初衷"><a href="#搭建这个网站的初衷" class="headerlink" title="搭建这个网站的初衷"></a>搭建这个网站的初衷</h3><p>作为一个半路出家（终于回到正轨）的伪程序员来说，找工作是一大难关，然后我就考虑到找工作时设计简历的问题，看到网上的大神说简历上附上自己的博客和github比较好，所以我就猛的一脚踹开了博客大门。</p>
<a id="more"></a>
<h3 id="为什么要自己搭建博客"><a href="#为什么要自己搭建博客" class="headerlink" title="为什么要自己搭建博客"></a>为什么要自己搭建博客</h3><p>其实这是挺奇怪的事情，我没有用CSDN，也没有用其他的博客，但是偶然看到网上教人搭建博客的视频，一时心血来潮就动起手来了，这两天的时间什么事情都没干就在搞这个。其实框架倒是挺好搭建的，就是配置的优化实在是不好搞（主要还是因为我没学过前端吧哈哈）。</p>
<p>像是网站的小图标我就搞了一小时，结果才知道要部署到Github上才会显示网站图标，气摔！之前还出了一个发布不了文章的Bug，但是我搞很久都没搞定就直接全部重头开始了。还有今天才解决的显示页面的问题，网上看了很多大神的博客都没解决，到群上问，各大神也都不知道怎么搞。结果一个比我还弱鸡的人让换个编辑器试试，我抱着大不了重头开始的想法试了一下，最后居然解决了哈哈哈哈哈。</p>
<p>感谢群里的各位大神和弱鸡。</p>
<p>这个网站大概就这模样了，其他的我就不搞了，不搞版权也不搞赞赏，评论我也不搞，可能后面会优化一下搜索引擎吧。</p>
<h3 id="我会发布什么内容"><a href="#我会发布什么内容" class="headerlink" title="我会发布什么内容"></a>我会发布什么内容</h3><p>之前我是用oneNote记录的，里面有很多基础的东西，其他的也都是网上可以搜到的，感觉好像就没什么再PO到网上的必要。但是后面会进行精简吧，在复习的过程中我会把一些（对我来说）比较难的点PO上来，或者利用这个网站重新系统化自己学过的东西。</p>
<p>当然，也不排除情绪低落的时候跑到这里发Sao的可能，毕竟对生活的记录也是很重要的嘛。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>希望每个进来这里的人能够找到需要的答案<br>希望所有夜里挣扎的人都能找到自己的方向</p>
<p>谢谢。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>

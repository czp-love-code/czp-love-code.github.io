<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈泽平的博客</title>
  
  <subtitle>Always keep it positive</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-11T04:03:42.620Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>耐清</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux/Unix 基本概念理解</title>
    <link href="http://yoursite.com/articles/Linux-Unix-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3.html"/>
    <id>http://yoursite.com/articles/Linux-Unix-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3.html</id>
    <published>2020-04-11T03:54:40.000Z</published>
    <updated>2020-04-11T04:03:42.620Z</updated>
    
    <content type="html"><![CDATA[<p>什么是操作系统？<br><img src="24.png" alt=""></p><p>进程：指运行中的程序</p><a id="more"></a><p>Linux系统的特点：<br>    1、多任务：<br>        多个进程可同时驻留于内存，且每个进程都能获得对CPU的使用权<br>    2、抢占式：<br>        进程对CPU的使用、进程使用的时间都受到一组规则控制，并由内核中的进程调度程序决定</p><p>内核的职责：<br>    1、进程调度<br>    2、内存管理<br>    3、提供文件系统<br>    4、创建和终止进程<br>    5、对设备的访问<br>    6、联网<br>    7、提供系统调用应用编程接口（API）</p><p>虚拟内存：实际内存空间+外部储存器，是程序的运行位置（空间）</p><p>实现虚拟内存的依据：<br>    程序的局部性原理，即程序在运行过程中经常体现出运行在某个局部范围之内的特点<br>    1、时间上：<br>        经常运行相同的指令段和数据（称为时间局部性）<br>    2、空间上：<br>        经常运行某一局部存储空间的指令和数据(称为空间局部性），有些程序段不能同时运行或根本得不到运行。</p><p>虚拟内存的工作原理：虚拟内存是把一个程序所需要的存储空间分成若干页或段，程序运行用到的页和段就放在内存里，暂时不用就放在外存中。当用到外存中的页和段时，就把它们调到内存，反之就把它们送到外存中，装入内存中的页或段可以分散存放。</p><p>虚拟内存管理的优势：<br>    1、降低每个进程对内存的需求量，使RAM中可以同时加载更多的进程<br>    2、隔离进程与进程，进程与内核<br>    3、使得对CPU资源的利用更充分的概率变大</p><p>RAM：即主存，是与CPU直接交换数据的内部存储器。它可以随时读写（刷新时除外），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质。</p><p>RAM的特点：<br>    1、工作时可以随时从任何一个指定的地址写入（存入）或读出（取出）信息。<br>    2、数据易失，即一旦断电所存储的数据将随之丢失</p><p>交换空间：在物理内存（RAM）被充满时被使用。如果系统需要更多的内存资源，而物理内存已经充满，内存中不活跃的页就会被移到交换空间去。<br>特点：位于硬盘驱动器上，它比进入物理内存要慢。 </p><p>虚拟内存区域划分：<br>    用户空间部分+内核空间部分<br>    用户空间:即进程的虚拟地址空间          </p><p>CPU运行状态：<br>    1、用户态，此时CPU只能访问用户空间部分<br>    2、内核态：此时CPU可以访问整个虚拟内存</p><p>核心态的CPU能执行特定操作：<br>    1、执行halt指令去关闭系统<br>    2、访问内存管理硬件<br>    3、设备I/O操作的初始化等</p><p>内核记账（bookkeeping）数据结构：<br>    1、包含所有与正在运行的进程有关的信息(进程ID，用户ID，组ID，终止状态等)<br>    2、将程序使用的文件名转换为磁盘的物理位置<br>    3、包含进程的虚拟内存与计算机物理内存和磁盘交换区的映射关系</p><p>shell：一个特殊的程序，用以读取用户输入的命令，并执行相应的程序作为响应<br>    PS：有些操作系统将shell集成于内核中，而对于Unix系统而言，shell只是一个用户进程<br>shell脚本：包含shell命令的文本文件</p><p>硬链接：<br>    链接<br>        指把文件名和计算机文件系统使用的节点号链接起来，<br>    硬链接<br>        就是一个文件的一个或多个文件名，这些文件名可以在同一目录或不同目录。<br>软链接：又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。</p><p>硬链接和软链接的区别：<br>    1、限制不同<br>        硬链接只能对已存在的文件进行创建，不能交叉文件系统进行硬链接的创建；<br>        软链接可对不存在的文件或目录创建软链接；可交叉文件系统；<br>    2、创建方式不同<br>        硬链接不能对目录进行创建，只可对文件创建；<br>        软链接可对文件或目录创建；<br>    3、影响不同<br>        删除一个硬链接文件并不影响其他有相同 inode 号的文件。<br>        删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</p><p>I/O通用性：同一套系统调用所执行的I/O操作，可施之于所有文件类型（open(),read(),write(),close()）</p><p>随机访问：在处理磁盘文件、磁盘或磁带时，可以用lseek()系统调用来随机访问</p><p>文件描述符：一个非负整数，用以指代打开的文件<br>获取方式：open()，参数为路径名</p><p>关于标准输入输出：<br><img src="25.png" alt=""></p><p>可再生资源：如CPU，网络带宽等，在进程间平等共享</p><p>进程的内存布局：<br><img src="26.png" alt=""></p><p>创建进程：<br><img src="27.png" alt=""></p><p>进程ID：<br><img src="28.png" alt=""></p><p>终止进程的方法：<br>    1、_exit()系统调用（或相关的exit()库函数）<br>    2、向进程传递信号，将其杀死</p><p>终止状态：进程退出后生成的一个非负小整数</p><p>进程的用户和组<br><img src="29.png" alt=""></p><p>init进程：<br><img src="30.png" alt=""></p><p>守护进程：<br><img src="31.png" alt=""></p><p>环境列表：<br><img src="32.png" alt=""></p><p>资源限制：<br>    使用系统调用setrlimit()<br>    硬限制：<br>    可以在任何时候任何进程中设置 ，但只能由超级用户提起，只能调低，不能调高<br>    软限制：<br>    内核实际执行的限制，任何进程都可以将软限制设置为任意小于等于对进程限制的硬限制的值<br><img src="33.png" alt=""></p><p>内存映射：<br><img src="34.png" alt=""></p><p>映射共享：<br><img src="35.png" alt=""></p><p>静态库：<br>    指在我们的应用中，有一些公共代码是需要反复使用，就把这些代码编译为“库”文件；在链接步骤中，连接器将从库文件取得所需的代码，复制到生成的可执行文件中的这种库。<br>静态库的缺点：<br>    当程序与静态库连接时，库中目标文件所含的所有将被程序使用的函数的机器码被copy到最终的可执行文件中。这就会导致最终生成的可执行代码量相对变多，相当于编译器将代码补充完整了，这样运行起来相对就快些。不过会有个缺点: 占用磁盘和内存空间. 静态库会被添加到和它连接的每个程序中, 而且这些程序运行时, 都会被加载到内存中. 无形中又多消耗了更多的内存空间</p><p>动态库：<br>     与共享库连接的可执行文件只包含它需要的函数的引用表，而不是所有的函数代码，只有在程序执行时, 那些需要的函数代码才被拷贝到内存中。这样就使可执行文件比较小, 节省磁盘空间，更进一步，操作系统使用虚拟内存，使得一份共享库驻留在内存中被多个程序使用，也同时节约了内存。不过由于运行时要去链接库会花费一定的时间，执行速度相对会慢一些。</p><p>静态库和动态库的区别：<br>    1、总的来说静态库是牺牲了空间效率，换取了时间效率，共享库是牺牲了时间效率换取了空间效率，没有好与坏的区别，只看具体需要了。<br>    2、另外，一个程序编好后，有时需要做一些修改和优化，如果我们要修改的刚好是库函数的话，在接口不变的前提下，使用共享库的程序只需要将共享库重新编译就可以了，而使用静态库的程序则需要将静态库重新编译好后，将程序再重新编译一遍。</p><p>进程间通信（IPC）<br><img src="36.png" alt=""></p><p>内核向进程发送信号的情况：<br><img src="37.png" alt=""></p><p>收到信号的三种行为：<br><img src="38.png" alt=""></p><p>信号处理器：<br><img src="39.png" alt=""></p><p>信号的挂起：信号从产生到送达期间，一直处于挂起状态<br>信号屏蔽：程序可以将信号纳入信号屏蔽列表，以求阻塞该信号，使该信号一直处于挂起状态</p><p>任务控制：shell提供的一种交互式特性，将管道中的所有进程置于一个新进程组或任务中，组中的所有进程具有相同的进程标识符，也是进程组组长的进程ID<br>作用：允许用户同时执行并操纵多条命令或管道</p><p>shell与会话：<br><img src="40.png" alt=""></p><p>控制终端与会话：<br><img src="41.png" alt=""></p><p>伪终端：一对相互连接的虚拟设备，其间有一条IPC信道，可供数据进行双向传输</p><p>/proc文件系统：以文件的形式提供一个指向内核数据结构的接口</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是操作系统？&lt;br&gt;&lt;img src=&quot;24.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;进程：指运行中的程序&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux/Unix 系统编程手册" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux-Unix-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>浏览器如何生成信息</title>
    <link href="http://yoursite.com/articles/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%BF%A1%E6%81%AF.html"/>
    <id>http://yoursite.com/articles/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%BF%A1%E6%81%AF.html</id>
    <published>2020-04-11T03:38:26.000Z</published>
    <updated>2020-04-11T03:48:34.836Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器工作流程：<br>    1、解析网址（URL），将域名解析成IP地址（通过DNS解析器）<br>    2、从具有IP地址的内存中将IP地址取出<br>    3、生成请求信息<br>    4、并委托操作系统向Web服务器发送请求</p><a id="more"></a><p>Socket库：<br>    其中包含的程序组件可以让其他应用程序调用操作系统的网络功能<br>DNS解析器（gethostbyname）：<br>    1、一段程序，包含在操作系统的Socket库中，是一个用来向DNS服务器发出查询信息的DNS客户端<br>    2、可以直接从应用程序中调用，首先生成查询信息并发送到DNS服务器（发送和接收的操作会委托给操作系统中的协议栈来进行）<br>    3、然后接收DNS服务器返回的响应信息，取出其中的IP地址<br>    4、将IP地址写入浏览器指定的内存地址中<br><img src="12.png" alt=""></p><p>具体流程<br><img src="13.png" alt=""><br>DNS服务器的基本工作：<br><img src="14.png" alt=""></p><p>根域的DNS服务器：<br>    分配给根域DNS服务器的IP地址全世界仅有13个，其相关信息已包含在DNS服务器程序的配置文件中，用于从客户端找到根域服务器<br>DNS服务器之间的查询操作：<br><img src="15.png" alt=""><br>DNS服务器中的缓存：<br>    DNS服务器会记住之前查询过的域名，即存放在缓存中，但缓存的信息具备一个有效期<br>URL的格式：<br><img src="16.png" alt=""><br>IP地址的表示：<br><img src="17.png" alt=""><br>DNS服务器的IP地址：<br>    作为TCP/IP的一个设置项目事先设置好的，不需要再去查询<br>网络号和主机号：<br><img src="18.png" alt=""><br>端口号:<br>    用来识别要连接的服务器程序的编号<br>CGI：<br>    对Web服务器程序调用其他程序的规则所做的定义<br>CGI程序：<br>    按照CGI规范来工作的程序<br>HTTP协议：<br>    定义了客户端和服务器之间交互的信息内容和步骤<br>HTTP的基本思路：<br><img src="19.%5Bng" alt=""><br>请求信息：<br>    1、方法：<br>        指名让服务器完成怎样的工作<br>    2、URI（Uniform Resource indentifier）：<br>        各种访问目标，如存放数据的文件名或一个CGI程序的文件名<br>    3、头字段（可有可无的附加信息）<br>    4、数据<br>响应信息：<br>    1、状态码<br>        一个数字，用来向程序告知执行的结果<br>    2、头字段<br>    3、网页数据<br><img src="20.png" alt=""><br>两种信息的结构：<br><img src="21.png" alt=""><br>响应短语：<br>    一段文字，用来告诉人们执行的结果<br>HTTP的主要方法：<br><img src="22.png" alt=""><br>GET方法的特点：<br>    能够发送的数据只有几百个字节，超过的话就要用POST方法来发送<br>POST的工作流程：<br>    1、URI会指向服务器中运行的一个应用程序的文件名<br>    2、请求信息中加上传递给该应用程序或脚本的数据<br>    3、服务器将数据传递给该应用程序或脚本<br>    4、服务器接收应用程序输出的结构，并存放在响应信息中，返回给客户端<br><img src="23.png" alt=""><br>当网页有图片时的处理情况：<br>    1、当网页中包含图片时，会在网页中的相应位置嵌入表示图片文件的标签的控制信息。<br>    2、浏览器会在显示文字时搜索相应的标签，当遇到图片相关的标签时，会在屏幕上留出用来显示图片的空间，然后再次访问 Web 服务器，按照标签中指定的文件名向 Web 服务器请求获取相应的图片并显示在预留的空间中。<br>    3、这个步骤和获取网页文件时一样，只要在 URI 部分写上图 片的文件名并生成和发送请求消息就可以了。 由于每条请求消息中只能写 1 个 URI，所以每次只能获取 1 个文件， 如果需要获取多个文件，必须对每个文件单独发送 1 条请求。<br>    4、比如 1 个 网页中包含 3 张图片，那么获取网页加上获取图片，一共需要向 Web 服务 器发送 4 条请求。</p><p>收发数据的流程：协议栈执行，每个过程都调用了Socket库中的程序组件<br>    （1）创建套接字（创建套接字阶段）<br>            调用Socket库中的socket程序组件来创建，创建完之后协议栈会返回一个描述符，应用程序会将收到的描述符存放在内存中。描述符是用来识别不同的套接字的<br>    （2）将管道连接到服务器端的套接字上（连接阶段）<br>            1、应用程序通过调用 Socket 库中的名为 connect 的程序组件来完成。这里的要点是当调用 connect 时，需要指定描述符、 服务器 IP 地址和端口号这 3 个参数（端口号大概可以理解为区分服务器上某个具体套接字）<br>            2、服务器上的端口号是事先规定好的<br>            3、客户端在创建套接字时，协议栈会为这个套接字随便分配一个端口号 A。接下来当协议栈执行连接操作时，会将这个随便分配的端口号通知给服务器<br>    （3）收发数据（通信阶段）<br>            1、发送：应用程序通过调用Socket库中的write程序组件来完成，当调用 write 时，需要指定描述符（确定是哪一个套接字）和发送数据，然后协议栈就会将数据发送到服务器。<br>            2、接收：调用Socket 库中的 read 程序组件委托协议栈来完成的，需要指定用于存放接收到的响应消息的内存地址，这一内存地址称为接收缓冲区。由于接收缓冲区是一块位于应用程序内部的内存空间，因此当消息被存放到接收缓冲区中时，就相当于已经转交给了应用程序。<br>    （4）断开管道并删除套接字（断开阶段）<br>            要调用 Socket 库的 close 程序组件进入断开阶段</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器工作流程：&lt;br&gt;    1、解析网址（URL），将域名解析成IP地址（通过DNS解析器）&lt;br&gt;    2、从具有IP地址的内存中将IP地址取出&lt;br&gt;    3、生成请求信息&lt;br&gt;    4、并委托操作系统向Web服务器发送请求&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="网络是怎么连接的" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="tcp/ip" scheme="http://yoursite.com/tags/tcp-ip/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统漫游</title>
    <link href="http://yoursite.com/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8.html"/>
    <id>http://yoursite.com/articles/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8.html</id>
    <published>2020-04-10T15:41:01.000Z</published>
    <updated>2020-04-11T03:37:24.250Z</updated>
    
    <content type="html"><![CDATA[<p>文本文件：只由ASCII字符构成<br>二进制文件：除了文本文件之外的文件</p><a id="more"></a><p>编译系统<br><img src="%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F.png" alt=""></p><p>汇编语言：为不同高级语言的不同编译器提供了通用的输出语言<br>链接：像printf这样的函数是每个C编译器都提供的C标准库的一个函数，存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中，这就是链接<br>可执行程序：存放在磁盘上</p><p>GNU项目的目标：开发出一个完整的类UNIX的系统<br>        ○ 特点：其源代码能够不受限制地被修改和传播</p><p>总线：贯穿整个系统的一组电子管道，携带信息字节并负责在各个部件间传递<br>特点：传送定长的字节快（字）<br><img src="shuchu.png" alt=""></p><p>IO设备：通过控制器或适配器与IO总线相连<br>控制器：IO设备本身或系统的主印制电路板（主板）上的芯片组<br>适配器：一块插在主板插槽上的卡<br>    控制器和适配器的作用都是在IO总线和IO设备之间传递信息</p><p>主存：一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据<br>    • 物理上：由一组动态随机存取存储器（DRAM）芯片组成<br>    • 逻辑上：一个线性的字节数组，每个字节都有其唯一的地址，这些地址都是从零开始的</p><p>处理器（CPU）：解释（执行）存储在主存中指令的引擎。<br>    • 核心：程序计数器（PC），是一个大小为一个字的存储设备。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）<br>    • 工作流程：CPU从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令的操作，然后更新PC，使其指向下一条指令，但该指令并不一定和内存中刚刚执行过的指令相邻</p><p>寄存器文件：由一些单个字长的寄存器组成，每个寄存器都有唯一的名字<br>ALU（算术/逻辑单元）：计算新的数据和地址值<br><img src="1.png" alt=""></p><p>直接存储器存取（DMA）：数据可以不通过CPU而直接从磁盘到主存<br><img src="2.png" alt=""></p><p>高速缓存存储器（cache memory）：L1,L2,L3三级，用于存放可能经常访问的数据<br>    • 实现：静态随机访问存储器（SRAM），一种硬件技术<br>    • 依据：程序的局部性原理，即程序具有访问局部区域里的数据和代码的趋势<br><img src="3.png" alt=""><br><img src="4.png" alt=""></p><p>并发运行：一个CPU可以并发地执行多个进程，CPU在进程间切换，一个进程的指令和另一个进程的指令是交错执行的（上下文切换）<br>上下文：进程运行所需的所有状态信息，如PC和寄存器文件的当前值，以及主存的内容<br>    注意：单处理器系统在任何时刻都只能执行一个进程的代码，当操作系统把控制权从当前进程转移到另一进程的时候，就会进行上下文切换<br>    上下文切换：保存当前进程的上下文，恢复新进程的上下文，并将控制权传递到新进程<br><img src="5.png" alt=""></p><p>内核：操作系统代码常驻主存的部分，是系统管理全部进程所用代码和数据结构的集合<br><img src="6.png" alt=""></p><p>线程：一个进程实际上由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据<br>    • 注意：多线程之间比多进程之间更容易共享数据<br><img src="7.png" alt=""></p><p>虚拟内存的运作需要对处理器生成的每个地址进行硬件翻译<br>    基本思想：把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存<br><img src="8.png" alt=""><br><img src="9.png" alt=""></p><p>多核处理器：将多个CPU集成到一个集成电路芯片上<br><img src="10.png" alt=""></p><p>线程级并行<br>    • 超线程（同时多线程）：一个CPU执行多个控制流（线程）<br>    • 举例：一个线程必须等到某些数据被装载到高速缓存中，这个时候CPU可以去执行另一个线程<br>    • 要求：程序以多线程方式来书写</p><p>指令级并行：CPU同时执行多条指令<br>    • 依据：流水线的使用，将每一条指令所需要的活动划分成不同的步骤，并将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同步骤<br>    • 超标量处理器：可以达到一个周期一条指令更快的执行速率的处理器</p><p>单指令、多数据并行（SIMD并行）：一条指令产生多个可以并行执行的操作<br><img src="11.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文本文件：只由ASCII字符构成&lt;br&gt;二进制文件：除了文本文件之外的文件&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="计算机系统" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>GDB 基本应用</title>
    <link href="http://yoursite.com/articles/GDB-%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8.html"/>
    <id>http://yoursite.com/articles/GDB-%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8.html</id>
    <published>2020-03-28T05:58:06.000Z</published>
    <updated>2020-03-28T05:59:22.703Z</updated>
    
    <content type="html"><![CDATA[<p>GDB使用：编译的时候加 -g参数<br>启动GDB：gdb + app(可执行程序名)<br>在GDB里启动程序：<br>1、    r(un)启动    （后面可以接实参）<br>2、    start启动(停留在main函数，相当于分步调试)，再输入n(ext)下一条指令，或者s（tep）,可以进入函数内部，但是库函数不能进<br>退出GDB：q(quit)</p><a id="more"></a><p>设置启动参数：set args 10 6，set argv[2]=”adsa”;<br>list:显示10行代码，按enter显示下10行(默认主函数对应文件)<br>list func.c :1<br>设置断点：b(break) 17 在17行设置断点        b sum 在sum函数处设置断点<br>b main.c :25        指定文件行数<br>设置条件断点：b line if i==1<br>info b  查看断点相关信息（会显示断点序号）<br>d（el）+断点序号    删除断点<br>c 执行至下一个断点（continue）<br>p argc 打印参数<br>ptype i 查看i的类型<br>display argc    显示argc的信息（后面执行任何指令都会display argc）<br>info display    显示display过的信息（序号）<br>undisplay+序号    删除之前的display</p><p>GDB跟踪core(段错误，核心已转储，会默认设置core大小为0，就看不到)<br>ulimit -c 设置生成core<br>ulimit -c unlimited<br>gdb app core查看是哪里出了问题(案发现场)，也可以再敲where<br>设置core文件格式：/proc/sys/kernel/core_pattern<br>文件不能vi，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GDB使用：编译的时候加 -g参数&lt;br&gt;启动GDB：gdb + app(可执行程序名)&lt;br&gt;在GDB里启动程序：&lt;br&gt;1、    r(un)启动    （后面可以接实参）&lt;br&gt;2、    start启动(停留在main函数，相当于分步调试)，再输入n(ext)下一条指令，或者s（tep）,可以进入函数内部，但是库函数不能进&lt;br&gt;退出GDB：q(quit)&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="GDB" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/GDB/"/>
    
    
      <category term="GDB" scheme="http://yoursite.com/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>makefile</title>
    <link href="http://yoursite.com/articles/makefile.html"/>
    <id>http://yoursite.com/articles/makefile.html</id>
    <published>2020-03-28T02:50:36.000Z</published>
    <updated>2020-03-28T02:52:12.829Z</updated>
    
    <content type="html"><![CDATA[<p>makefile的用处：封装命令，一次编写，终身受益<br>命名规则：makefile/Makefile<br>三要素：目标，依赖，规则命令（依赖可以不写，规则也可以不写）<br>写法：<br>目标：依赖<br>tab    规则命令</p><a id="more"></a><p>例：<br>app:main.c a.c b.c<br>    gcc -o app -I ./czp  main.c a.c b.c<br>此时的弊端：如果改变其中一个源码文件，所有的源码都需要重新编译<br>解决方案：可以考虑过程分解，先生成.o文件</p><p>定义变量：<br>ObjFiles=main.c ,a.c,b.c<br>变量的使用：$(ObjFiles)<br>makefile的隐含规则：默认处理第一个目标<br>如果想处理某个目标：make app<br>使用函数：<br>SrcFiles=$(wildcard 星.c)        文件匹配<br>ObjFiles=$(patsubst %.c,%.o,$(SrcFiles))    内容替换    所有.c变成.o<br>test:<br>    echo $(SrcFiles)<br>    echo $(ObjFiles)</p><p>makefile的变量：<br>$@ 代表目标<br>$^    代表全部依赖<br>$&lt;    代表第一个依赖<br>$?    第一个变化的依赖<br>例：<br>%.o:%.c<br>    gcc -c $&lt; -I ./czp -o $@<br>$&lt;和$&lt;只能在规则中出现<br>若是不想执行make 后看见指令，就在规则前加@<br>在规则前加-号，若是出了错误（如文件不存在）继续执行</p><p>防止目录下有同名文件：<br>.PHONY:clean（表示clean为伪目标）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;makefile的用处：封装命令，一次编写，终身受益&lt;br&gt;命名规则：makefile/Makefile&lt;br&gt;三要素：目标，依赖，规则命令（依赖可以不写，规则也可以不写）&lt;br&gt;写法：&lt;br&gt;目标：依赖&lt;br&gt;tab    规则命令&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="makefile" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/makefile/"/>
    
    
      <category term="makefile" scheme="http://yoursite.com/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>静态库和动态库</title>
    <link href="http://yoursite.com/articles/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93.html"/>
    <id>http://yoursite.com/articles/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93.html</id>
    <published>2020-03-27T16:21:53.000Z</published>
    <updated>2020-03-27T16:23:40.106Z</updated>
    
    <content type="html"><![CDATA[<p>制作静态库：（Linux下是libxxx.a文件，共享库是.so结尾）<br>1、编译为.o文件<br>2、打包.o文件：ar rcs libmycalc.a file1.o file2.o……<br>3、需要将头文件和库一起发布<br>编译时需要加静态库名</p><a id="more"></a><p>优点：执行快，发布应用时不需要发布库<br>缺点：执行程序体积会比较大，库变更时需要重新编译应用</p><p>32位系统的最大寻址范围是4G</p><p>制作动态库：<br>1、编译与位置无关的代码，生成.o文件，关键参数：-fPIC(大写i)<br>2、将.o文件打包：-shared<br>3、将库和头文件一起发布</p><p>注意：<br>使用静态库是直接将代码加进代码区<br>而使用的动态库临时加载进栈和堆之间，用完即释放，比如使用库里的add函数，就临时加载进去，因为是临时加载，所以不确定是哪个地址，就不能直接与位置绑定。因此要编译成与位置无关的代码，也就是说我们知道自己所使用函数在库中的相对位置就可以了。使用时首先知道库名，然后知道使用的函数在库中的偏移，进行定位，这样才能使用这个函数<br>eg: gcc -shared -o libcalc.so a.c b.c<br>使用动态库生成的程序比使用静态库生成的程序小，因为是使用时才临时加进去的，一般动态库变更不需要重新编译，除非接口修改了</p><p>举例：运行a.out时，首先检查内存中是否有相同的库代码在运行，如果有，则计算出正确的逻辑地址以备使用；否则先确定逻辑地址，再载入代码到内存中。</p><p>根据载入程序何时确定动态库代码的逻辑地址，可分为：<br>1静态绑定<br>程序一载入内存就把动态代码地址算出，这样程序刚运行时初始化时间较长，但一旦完成动态装载，程序运行就很快。<br>2动态绑定<br>在程序真正调用动态库中代码时才计算相关逻辑地址，故初始化时间较短，但运行性能不如静态绑定。</p><p>可以用ldd命令检查程序链接情况，程序执行时可能会出现.so文件not found<br>可以使用软链接：ln -s /lib/a.so(绝对路径) /lib/a.so，也可以将库路径添加到环境变量LD_LIBRARY_PATH中<br>export LD_LIBRARY_PATH=/home/czp/……/lib/（绝对路径）:$LD_LIBRARY_PATH<br>还可以进/etc/ld.so.conf进行设置：添加lib的绝对路径，然后进行sudo ldconfig -v</p><p>系统库位置：/lib,/usr/lib</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;制作静态库：（Linux下是libxxx.a文件，共享库是.so结尾）&lt;br&gt;1、编译为.o文件&lt;br&gt;2、打包.o文件：ar rcs libmycalc.a file1.o file2.o……&lt;br&gt;3、需要将头文件和库一起发布&lt;br&gt;编译时需要加静态库名&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础知识" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="库的制作" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/"/>
    
    
      <category term="静态库" scheme="http://yoursite.com/tags/%E9%9D%99%E6%80%81%E5%BA%93/"/>
    
      <category term="动态库" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>gcc 笔记</title>
    <link href="http://yoursite.com/articles/gcc-%E7%AC%94%E8%AE%B0.html"/>
    <id>http://yoursite.com/articles/gcc-%E7%AC%94%E8%AE%B0.html</id>
    <published>2020-03-27T16:19:50.000Z</published>
    <updated>2020-03-27T16:21:17.409Z</updated>
    
    <content type="html"><![CDATA[<p>gcc编译流程：gcc -E hello.c(调用cpp,预处理+头文件展开+宏替换)–&gt;hello.i<br>gcc -S hello.i/hello.c（生成汇编代码）–&gt;hello.s<br>gcc -c hello.s(编译成二进制文件)–&gt;hello.o<br>调用ld命令    链接–&gt;a.out</p><a id="more"></a><p>gcc -I (大写i) 指定包含头文件的路径<br>gcc -o 指定生成程序名<br>gcc -D 宏定义<br>-L 包含库路径<br>-l(小写L)指定库名（用法：libxxx.so用-lxxx）<br>-g 用于gdb调试    （会在可执行程序里加入调试信息，文件变大）<br>-Wall     显示全部警告<br>-lstdc++        编译C++代码（或者直接使用g++）<br>-O        优化1-3，数字越大优化强度越强（-O1，-O2，-O3）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;gcc编译流程：gcc -E hello.c(调用cpp,预处理+头文件展开+宏替换)–&amp;gt;hello.i&lt;br&gt;gcc -S hello.i/hello.c（生成汇编代码）–&amp;gt;hello.s&lt;br&gt;gcc -c hello.s(编译成二进制文件)–&amp;gt;hello.o&lt;br&gt;调用ld命令    链接–&amp;gt;a.out&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译器" scheme="http://yoursite.com/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
      <category term="gcc" scheme="http://yoursite.com/categories/%E7%BC%96%E8%AF%91%E5%99%A8/gcc/"/>
    
    
      <category term="gcc" scheme="http://yoursite.com/tags/gcc/"/>
    
  </entry>
  
  <entry>
    <title>vim 笔记</title>
    <link href="http://yoursite.com/articles/vim-%E7%AC%94%E8%AE%B0.html"/>
    <id>http://yoursite.com/articles/vim-%E7%AC%94%E8%AE%B0.html</id>
    <published>2020-03-27T16:18:13.000Z</published>
    <updated>2020-03-27T16:19:22.624Z</updated>
    
    <content type="html"><![CDATA[<p>vimtutor        vim教程<br>光标移动：hjkl    左下上右<br>0：到行首<br>$：到行尾<br>gg:到文件头<br>G:到文件末行首<br>12G: 到12行</p><a id="more"></a><p>x:删除光标所在位置的字符但不切换模式<br>X：删除光标前的字母<br>s:删除光标所在位置的字符并切换为插入<br>S：删除当前所在行并切换为插入<br>i:不移动光标，光标前插入切换为插入模式<br>大写I:在行首切换为插入模式<br>a:在光标后插入<br>A：在行尾插入<br>o:在下方开启新行，切换为插入模式<br>O：在上方开启新行，切换为插入模式</p><p>进行末行模式：冒号:<br>退出末行模式：两下ESC<br>(末行模式下可以执行命令:! ls -l)<br>：s/jack/jackon    替换jack为jackon，只替换光标后的第一个匹配<br>：s/jack/tom/g    当前行的所有匹配都替换<br>：%s/jack/tom    所有行第一个匹配都替换<br>：%s/jack/tom/g    所有行都替换<br>：w        只保存不退出<br>：q        只退出，文件不能修改<br>：q!        不保存退出<br>：wq    保存退出<br>：x        保存退出<br>：sp+文件名字，横屏分屏显示（按ctrl+w两下就切换当前屏，：q就退一个：qall 全部退出：wqall全部保存退出）<br>：vsp+文件名字，竖屏分屏显示</p><p>ZZ（命令模式下）：保存退出</p><p>u;撤销<br>d+w:从光标位置开始删除后续单词中的部分<br>d+$（D）:删至行尾<br>d+0：删至行首（不包括光标所在位置的字符）<br>dd:删除光标所在行<br>2dd:删除两行<br>yy:复制一行<br>nyy：复制多行<br>p:粘贴到下一行<br>P:粘贴到上一行</p><p>r+某个字母：替换字母<br>v:切换为可视模式（y复制内容+p/P进行粘贴）<br>查找内容：/+内容，n/N进行遍历<br>？+内容，也可行，不过遍历方式不一样<br>光标定位在字符串上用#也可行<br>gg=G    格式调整（对齐）全部<br>&lt;&lt; ，&gt;&gt;单行调整格式(tab)<br>3&lt;&lt;,3&gt;&gt;多行调整格式</p><p>定位到某个函数按K等同于用man搜索帮助文档<br>2+K则是看到声明（2是对应的章）<br>/home/czp/.vimrc        本用户的配置文件</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vimtutor        vim教程&lt;br&gt;光标移动：hjkl    左下上右&lt;br&gt;0：到行首&lt;br&gt;$：到行尾&lt;br&gt;gg:到文件头&lt;br&gt;G:到文件末行首&lt;br&gt;12G: 到12行&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="vim" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/vim/"/>
    
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用命令</title>
    <link href="http://yoursite.com/articles/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>http://yoursite.com/articles/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</id>
    <published>2020-03-27T11:55:56.000Z</published>
    <updated>2020-03-27T11:57:48.611Z</updated>
    
    <content type="html"><![CDATA[<p>echo $BASH（环境变量）        检查系统使用的Shell<br>echo $HOME        家目录环境变量<br>echo 输出变量或字符串<br>alias 命令重命名<br>alias grep=’grep –color=auto’    查找并标红<br>(可以进.bashrc改)<br>cat /etc/shells        查看当前系统下的shell<br>history        显示历史命令<br>date +’%Y%m%d’ 日期显示格式</p><a id="more"></a><p>man man<br>ls         (list)<br>ls -l         显示详细的目录下文件信息<br>(文件权限，硬链接计数，用户，用户组)<br>（-代表普通文件（查找该类型文件时用f）   d目录文件  l表示软连接文件（符号链接）  c字符设备文件（键盘，鼠标）   b块设备文件   p(pipe) 管道设备     s本地套接字）<br>（用户权限+用户组权限+其他人的权限    0777，r读，w写，x执行）</p><p>rwx    111    7<br>rw-    110    6<br>r-x    101    5<br>r–    100    4<br>-wx    011    3<br>-w-    010    2<br>–x    001    1<br>—    000    0</p><p>chmod u|g|o|a +|- r|w|x filename<br>chmod 0777 filename 目录需要有可执行权限才能进入<br>sudo chown a    filename        改变用户<br>sudo chown a:a filename    改变用户和组<br>sudo chgrp filename    改变组</p><p>ln hello hello.hard        建立硬链接，目录也可以<br>ln -s     hello hello.hard    建立软链接    （快捷方式）目录也可以<br>unlink hello.hard        删除链接<br>硬链接计数为0时，文件被删除</p><p>ls -a            显示全部文件（包括隐藏文件）<br>ls -R            递归显示子目录<br>ls -lrt        按时间显示<br>ls *.c<br>ls /            查看根目录下的文件</p><p>cd             change directory        回到用户家目录<br>cd ~            回到用户家目录<br>cd     $HOME    回到用户家目录</p><p>cd /            回到根目录<br>cd -            回到上次的目录</p><p>$            表示普通用户</p><h1 id="表示超级用户"><a href="#表示超级用户" class="headerlink" title="表示超级用户"></a>表示超级用户</h1><p>pwd            显示当前工作目录</p><p>/home/czp    用户家目录<br>/bin         可执行程序的目录<br>/sbin        超级管理员的可执行程序目录<br>/boot        启动相关的文件<br>/lib             存放库的（系统最基本的动态共享库）<br>/media        U盘等外接设备的目录（自动挂载）<br>/mnt         手动挂载<br>/usr            unix system resources    系统资源，自己安装的库等应用<br>/usr/local    用户自己安装的软件的目录<br>（ifconfig）    查看IP<br>/proc         系统内存的映射，进程运行的信息保存位置<br>/etc         系统软件的启动和配置目录<br>/etc/passwd    用户存放文件<br>/dev            设备文件目录</p><p>cat /etc/passwd<br>man 5 passwd    查看文件格式</p><p>mkdir        创建目录，可多个<br>mkdir    aa/cc    aa存在才可以<br>mkdir -p dd/bb    dd不存在也可<br>rmdir -p dd/bb    两个一起remove<br>rmdir    aa    aa非空则不可<br>touch         创建文件，若文件已存在则修改最后访问时间</p><p>which        显示命令位置<br>which cd        什么都没有显示，因为cd是shell本身带的<br>whoami        显示当前用户名<br>date         查看时间日期</p><p>rm -r    递归删除<br>rm -f    强制删除<br>rm -rf *    删除当前目录下所有内容</p><p>cp hello aa    aa为目录<br>cp hello world    world是文件<br>cp -r aa bb<br>mv hello hello1    改名</p><p>cat          concatenate        显示文件信息<br>more        分屏显示文件，空格下一页，回车下一行<br>less            分屏显示文件信息</p><p>head        查看文件头    默认显示10行<br>head -n 5 xxx.c            显示5行<br>tail            查看文件尾<br>tail    -f        可以一直跟踪文件末尾    调试服务器用用</p><p>wc         行、词、字节<br>wc -l -w -c    分开显示</p><p>du    （disk usage）    磁盘使用率 显示目录下文件大小<br>du -h    人性化显示<br>du -h –max-depth=1    只显示一级<br>df -h  (disk free)        空余硬盘</p><p>find dir -option 内容<br>find dir -name “*.c”<br>find dir -type f<br>find dir -size +1M    （k用小写）<br>find dir -size +1M -size -5M<br>不写+-即为等，但不精确<br>find dir -maxdepth -size +1M        (只要一级目录，maxdepth要放前面)<br>find dir -maxdepth -size +1M | ls -l  详细显示，利用了管道，但这个不好使<br>find dir -maxdepth -size +1M | xargs ls -l     这个才可以<br>find dir -maxdepth -size +1M -exec ls -l     { } \：这个也可以用<br>find dir -maxdepth -size +1M -ok ls -l     { } \：会进行询问<br>-exec有弊端，会一下子把前面的东西全部传给后面的指令，很有可能会造成后面的溢出<br>xargs 会把前面查找的结果分成若干个块，按块传递给后面的指令</p><p>find dir -type f | grep txt     直接输出给后面的指令，对文件里的内容进行查找<br>grep “main” *.c    按内容查找，输出文件中对应行<br>grep -rn “main” *.c   递归目录并显示具体行数<br>cat a.c | grep main        结合管道使用<br>tail -f a.c | grep main    结合管道使用<br>tail -f a.c | grep -v main    过滤对应信息</p><p>zip -r dir.zip dir     递归压缩<br>unzip dir.zip<br>gzip与gunzip生成的是.gz文件，只能对文件处理，不能对目录<br>tar zcvf bb.tar.gz bb(压缩包.gz，不带z的话只会生成tar包，压缩c，v显示信息，f代表指定压缩包名字) 生成.tar.gz，最常用<br>tar zxvf bb.tar.gz    （x代表解压）<br>tar jcvf bb.tar.bzip2 bb<br>tar jxvf bb.tar.bzip2    bzip2格式</p><p>rar a -r newdir dir<br>rar x -r newdir.rar</p><p>apt-get 自动安装软件，需要知道软件名称<br>sudo apt-get update    更新源    /etc/apt/sources.list<br>sudo apt-get install<br>sudo apt-get remove<br>sudo apt-get clean</p><p>dpkg 根据deb安装包来安装软件<br>sudo dpkg-i xxx.deb<br>sudo dpkg-r xxx.deb</p><p>源码安装<br>1、    解压缩源代码包<br>2、    cd dir<br>3、    ./config    检测文件是否有缺失，创建makefile，检测编译环境<br>4、    make 编译源码，生成库和可执行程序<br>5、    sudo make install 把库和可执行程序安装到系统路径下<br>6、    sudo make distclean    删除和卸载软件</p><p>ping baidu.com    查看是否联网<br>sudo useradd -s（指定Shell)-g（指定组）-d（用户家目录）-m（家目录不存在时自动创建）<br>例：sudo useradd -s /bin/bash -g czp -d /home/czp -m czp<br>sudo groupadd czp<br>sudo passwd czp<br>suczp    缺少环境变量，可能某些功能有问题<br>su-czp    带有环境变量<br>sudo su 切换到超级用户 super user<br>sudo userdel czp<br>sudo userdel -r czp 连带删除家目录</p><p>umask 补码显示文件权限        umask -S    文字表示显示权限<br>0002 取反 0775 &amp; 0666（touch后的默认文件权限）0664（之后的文件权限）<br>重启：reboot<br>关机 init 0</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;echo $BASH（环境变量）        检查系统使用的Shell&lt;br&gt;echo $HOME        家目录环境变量&lt;br&gt;echo 输出变量或字符串&lt;br&gt;alias 命令重命名&lt;br&gt;alias grep=’grep –color=auto’    查找并标红&lt;br&gt;(可以进.bashrc改)&lt;br&gt;cat /etc/shells        查看当前系统下的shell&lt;br&gt;history        显示历史命令&lt;br&gt;date +’%Y%m%d’ 日期显示格式&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>枚举类型使用注意事项</title>
    <link href="http://yoursite.com/articles/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html"/>
    <id>http://yoursite.com/articles/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html</id>
    <published>2019-12-22T04:23:58.000Z</published>
    <updated>2019-12-22T07:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>未命名的enum只能在定义该enum时定义它的对象（分号前面）</p><a id="more"></a><p>枚举成员是const，提供初始值时必须是常量表达式，同时，我们也可以在任何需要常量表达式的地方使用枚举成员。如使用enum作为switch语句的表达式，而将枚举值作为case标签，也能将枚举类型作为非类型模板形参使用，或者在类的定义中初始化枚举类型的静态数据成员</p><p>初始化已命名的enum对象或对其赋值必须使用一个枚举成员或该类型的另一个对象，同时我们不能将整型值传给enum形参，但是可以将一个不限定作用域的枚举类型的对象或枚举成员传给整型形参，因为一个不限定作用域的枚举类型的对象或枚举成员自动转换为整型，而限定作用域的枚举类型则不会进行这样的隐式转换。<br>此时enum的值类型进行提升，但是永远不会提升成unsigned char，即使枚举值可以用unsigned char存储也是如此</p><p>默认情况下限定作用域的enum成员类型是int，我们可以进行指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum adsa:unsigned long long&#123;</span><br><span class="line">-------</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于不限定作用域的枚举类型的枚举成员则不存在默认类型，一般认为足够大够容纳枚举值，如果我们再指定大小的话容易引发程序错误</p><p>枚举类型的前置声明必须指定其成员的大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum adsa:unsigned long long;</span><br><span class="line">enum class opadsa;&#x2F;&#x2F;限定作用域默认为int</span><br></pre></td></tr></table></figure><p>我们不可以在同一个上下文先声明一个限定作用域的enum名字，再声明一个不限定作用域的同名enum；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;未命名的enum只能在定义该enum时定义它的对象（分号前面）&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>使用using的别名声明与typedef的区别</title>
    <link href="http://yoursite.com/articles/%E5%88%AB%E5%90%8D%E5%A3%B0%E6%98%8E%E4%B8%8Etypedef%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
    <id>http://yoursite.com/articles/%E5%88%AB%E5%90%8D%E5%A3%B0%E6%98%8E%E4%B8%8Etypedef%E7%9A%84%E5%8C%BA%E5%88%AB.html</id>
    <published>2019-12-22T03:09:25.000Z</published>
    <updated>2019-12-22T03:22:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用using的别名声明和typedef完成的是一模一样的工作，那么两个之间有什么区别呢？</p><a id="more"></a><p>一个最重要的区别就是使用using的别名声明可以直接进行模板化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">using MyAllocList&#x3D;std::list&lt;T,MyAlooc&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">MyAllocList&lt;Widget&gt; lw;</span><br></pre></td></tr></table></figure><p>而使用typedef的话，就需要将类型放置在类中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct MyAllocList&#123;</span><br><span class="line">typedef std::list&lt;T,MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;使用模板实例下的类型别名;</span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw;</span><br></pre></td></tr></table></figure><p>此外，如果要在模板内使用typedef来创建一个成员，而且它的类型由模板形参指定的话，就需要添加前缀typename来告知编译器这是一个类型成员，而不是static成员(如果是使用using声明的别名则可以直接使用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Widget&#123;</span><br><span class="line">private:</span><br><span class="line">typename MyAllocList&lt;T&gt;::type list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用using的别名声明和typedef完成的是一模一样的工作，那么两个之间有什么区别呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective Modern C++" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Effective-Modern-C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何使用红黑树实现关联容器map（待更新）</title>
    <link href="http://yoursite.com/articles/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8map(%E5%BE%85%E6%9B%B4%E6%96%B0%EF%BC%89.html"/>
    <id>http://yoursite.com/articles/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8map(%E5%BE%85%E6%9B%B4%E6%96%B0%EF%BC%89.html</id>
    <published>2019-12-20T03:22:55.000Z</published>
    <updated>2019-12-23T02:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>关联容器map是一个pair&lt;const key_type,value_type&gt;，基于此建立了从key到value的映射，并且相关的复杂度是log(N)。那么如何使用红黑树来实现它呢？</p><a id="more"></a><p>首先建立一个红黑树的结点结构体，并且这个结点要关联到map的元素，即一个pair数据成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">enum COLOR&#123;RED,BLACK&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key_type,typename Value_type&gt;</span><br><span class="line">struct RBTreeNode&#123;</span><br><span class="line">RBTreeNode&lt;Key_type, Value_type&gt;* left;</span><br><span class="line">RBTreeNode&lt;Key_type, Value_type&gt;* right;</span><br><span class="line">RBTreeNode&lt;Key_type, Value_type&gt;* parent;</span><br><span class="line">pair&lt;Key_type, Value_type&gt; value;</span><br><span class="line">COLOR color;</span><br><span class="line">RBTreeNode(const Key_type&amp; key &#x3D; Key_type(), const Value_type&amp; value&#x3D;Value_type(),COLOR Color&#x3D;RED)</span><br><span class="line">:left(NULL),right(NULL),parent(NULL),value(key,value),color(Color)&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了红黑树的结点，现在假想我们已经有了一颗以map元素类型为结点的红黑树。那么要遍历一个map容器来进行搜索的话我们就需要遍历这颗红黑树，即从它关键值最小的结点遍历到关键值最大的结点。那么我们就需要一种操作（一个类）来进行红黑树的遍历。不难想到可以构建一个红黑树的迭代器来实现这个遍历操作。</p><p>我们知道，迭代器的begin()指向容器的首元素（最小元素），而end()指向容器的尾后元素（最大元素的后一个位置），那么对于一颗红黑树而言，我们就需要另外构建一个尾后结点来让迭代器的end()指向它。假设这个结点命名为header，因为这个结点不能破坏原先红黑树的性质，、所以不能是黑色，只能是红色。</p><p>现在我们需要将这个游离的结点与原先的红黑树相连接，考虑到我们是打算构建一个迭代器，那么就需要将header与树中最小和最大结点连接，假设树中最小元素为minNode，最大元素为maxNode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header-&gt;left&#x3D;minNode;</span><br><span class="line">header-&gt;right&#x3D;maxNode;</span><br></pre></td></tr></table></figure><p>即我们构建的迭代器的begin()指向header的左孩子，而end()指向header，end()后退一步就指向header的右孩子。</p><p>最后这个header结点还需要连接parent，此时我们可以把它和原先树中的根节点互联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header-&gt;parent&#x3D;rootNode;</span><br><span class="line">rootNode-&gt;parent&#x3D;header;</span><br></pre></td></tr></table></figure><p>接下来就可以开心地实现红黑树的迭代器了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename Key_type,typename Value_type&gt;</span><br><span class="line">class RBTreeIterator</span><br><span class="line">&#123;</span><br><span class="line">typedef RBTreeNode&lt;Key_type, Value_type&gt; Node;</span><br><span class="line">typedef node* NodePtr;</span><br><span class="line">typedef RBTreeIterator&lt;Key_type, Value_type&gt; self;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">RBTreeIterator(NodePtr node_ptr&#x3D;nullptr):nodePtr(node_ptr)&#123;&#125;</span><br><span class="line">RBTreeIterator(const self&amp; s) :nodePtr(s.nodePtr)&#123;&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;Key_type, Value_type&gt;&amp; operator*() &#123;</span><br><span class="line">return nodePtr-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;Key_type, Value_type&gt;* operator-&gt;() &#123;</span><br><span class="line">return &amp;(operator*()):</span><br><span class="line">&#125;</span><br><span class="line">self&amp; operator++() &#123;</span><br><span class="line">RBTreeItIncrement();</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">self operator++(int) &#123;</span><br><span class="line">self tmp(*this);</span><br><span class="line">RBTreeItIncrement();</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line">self&amp; operator--() &#123;</span><br><span class="line">RBTreeItDeCrement();</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">self operator--(int) &#123;</span><br><span class="line">self tmp(*this);</span><br><span class="line">RBTreeItDecrement();</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line">bool operator&#x3D;&#x3D;(const self&amp; s) &#123;</span><br><span class="line">return nodePtr &#x3D;&#x3D; s.nodePtr;</span><br><span class="line">&#125;</span><br><span class="line">bool operator!&#x3D;(const self&amp; s) &#123;</span><br><span class="line">return !(this &#x3D;&#x3D; s);</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">void RBTreeItIncrement() &#123;</span><br><span class="line">if (nodePtr-&gt;right) &#123;</span><br><span class="line">nodePtr &#x3D; nodePtr-&gt;right;</span><br><span class="line">while (nodePtr-&gt;left)</span><br><span class="line">nodePtr &#x3D; nodePtr-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">NodePtr nodeParent &#x3D; nodePtr-&gt;parent;</span><br><span class="line">while (nodePtr &#x3D;&#x3D; nodeParent-&gt;right) &#123;</span><br><span class="line">nodePtr &#x3D; nodeParent;</span><br><span class="line">nodeParent &#x3D; nodePtr-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line">if (nodePtr-&gt;right !&#x3D; nodeParent)</span><br><span class="line">nodePtr &#x3D; nodeParent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void RBTreeItDecrement() &#123;</span><br><span class="line">if (nodePtr-&gt;parent-&gt;parent &#x3D;&#x3D; nodePtr &amp;&amp; nodePtr-&gt;color &#x3D;&#x3D; RED)</span><br><span class="line">nodePtr &#x3D; nodePtr-&gt;right;</span><br><span class="line">else if (nodePtr-&gt;left) &#123;</span><br><span class="line">nodePtr &#x3D; nodePtr-&gt;left;</span><br><span class="line">while (nodePtr-&gt;right)</span><br><span class="line">nodePtr &#x3D; nodePtr-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">NodePtr nodeParent &#x3D; nodePtr-&gt;parent;</span><br><span class="line">while (nodePtr &#x3D;&#x3D; nodePtr-&gt;left) &#123;</span><br><span class="line">nodePtr &#x3D; nodeParent;</span><br><span class="line">nodeParent &#x3D; nodePtr-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line">nodePtr &#x3D; nodeParent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">NodePtr nodePtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关联容器map是一个pair&amp;lt;const key_type,value_type&amp;gt;，基于此建立了从key到value的映射，并且相关的复杂度是log(N)。那么如何使用红黑树来实现它呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="STL源码剖析" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>为什么说vector的接口设计是败笔</title>
    <link href="http://yoursite.com/articles/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4vector%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E6%98%AF%E8%B4%A5%E7%AC%94.html"/>
    <id>http://yoursite.com/articles/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4vector%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E6%98%AF%E8%B4%A5%E7%AC%94.html</id>
    <published>2019-12-18T15:03:09.000Z</published>
    <updated>2019-12-18T15:31:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个类的设计者，我们应该把构造函数设计成客户无论使用小括号还是大括号都不会影响要调用的重载版本，而vector的构造函数却恰恰破坏了这个隐性规定。我们知道，在构造一个vector的时候，使用大小括号来构造对象会产生完全不一样的结果。</p><a id="more"></a><p>为什么会这样呢？<br>首先，使用大括号来进行初始化对象有三个特点，第一个特点就是它禁止了会损失精度的隐式转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double x,y,z;</span><br><span class="line">int sum&#123;x+y+z&#125;; &#x2F;&#x2F;错误</span><br></pre></td></tr></table></figure><p>第二个特点就是不会变成一个函数的声明，因为用小括号来调用不带参数的构造函数的时候就会变成一个函数的声明，而大括号则不会，依旧会调用没有形参的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Widget w1();&#x2F;&#x2F;这是一个函数声明</span><br><span class="line">Widget w2&#123; &#125;;&#x2F;&#x2F;这调用了没有形参的构造函数</span><br></pre></td></tr></table></figure><p>第三个特点就是在构造函数的重载决议期间，只要大括号内的实参能与带std::initializer_list类型的形参匹配或进行隐式转换，就会调用这个构造函数，而若是存在带std::initializer_list类型的形参的构造函数，而实参与形参之间需要进行转换且转换会损失精度，那么就会出错。此外如果该构造函数的形参与实参完全不匹配（无法进行隐式转换，如实参int形参string），才会考虑其他的候选函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget(std::initializer_list&lt;bool&gt; il);&#x2F;&#x2F;其中一个构造函数</span><br><span class="line"></span><br><span class="line">Widget w&#123;10,5.0&#125;;&#x2F;&#x2F;错误，bool无法精确表示这两个值中的任何一个</span><br><span class="line"></span><br><span class="line">Widget(std::initializer_list&lt;string&gt; il)&#x2F;&#x2F;其中一个构造函数</span><br><span class="line"></span><br><span class="line">Widget w2&#123;10,5.0&#125;; &#x2F;&#x2F;考虑匹配其他构造函数</span><br></pre></td></tr></table></figure><p>还有一点需要注意的就是当实参为空的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w1&#123; &#125;;&#x2F;&#x2F;调用默认构造函数</span><br><span class="line">Widget w2 (&#123; &#125;);&#x2F;&#x2F;调用带std::initializer_list的构造函数</span><br><span class="line">Widget w2 &#123;&#123; &#125;&#125;;&#x2F;&#x2F;调用带std::initializer_list的构造函数</span><br></pre></td></tr></table></figure><p>我们知道vector中有一个带initializer_list的构造函数和一个不带initializer_list形参的构造函数，那么用大小括号来初始化它的对象的时候，就会出现完全不一样的结果，但是我们原先却是希望无论使用大小括号都不要影响到调用的重载版本的。所以才说vector的接口设计就是败笔</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个类的设计者，我们应该把构造函数设计成客户无论使用小括号还是大括号都不会影响要调用的重载版本，而vector的构造函数却恰恰破坏了这个隐性规定。我们知道，在构造一个vector的时候，使用大小括号来构造对象会产生完全不一样的结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective Modern C++" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Effective-Modern-C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何理解auto与隐形代理类之间的冲突</title>
    <link href="http://yoursite.com/articles/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3auto%E4%B8%8E%E4%BB%A3%E7%90%86%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%B2%E7%AA%81.html"/>
    <id>http://yoursite.com/articles/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3auto%E4%B8%8E%E4%BB%A3%E7%90%86%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%B2%E7%AA%81.html</id>
    <published>2019-12-18T04:07:13.000Z</published>
    <updated>2019-12-18T05:51:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>代理类：指为了模拟或增广其他类型的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;bool&gt;类下的operator[ ]返回一个隐形代理类对象，即std::vector&lt;bool&gt;::reference对象</span><br><span class="line"></span><br><span class="line">std::bitset::reference也是同样的隐形代理类</span><br></pre></td></tr></table></figure><a id="more"></a><p>为什么说是隐形？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;bool&gt;是一个经过特例化的类，它的对象采用了一种压缩的方式表示其特有的bool元素，</span><br><span class="line">每一个bool元素用一个比特来表示。</span><br><span class="line">因为C++中禁止了比特的引用，所以它的operator[ ]不能返回bool&amp;。</span><br><span class="line">那么它就需要返回一个像bool&amp;的对象。</span><br><span class="line">即需要模拟bool&amp;，就是用std::vector&lt;bool&gt;::reference这个代理类对象来代理bool&amp;,</span><br><span class="line">所以要保证它像bool&amp;，而且所有能用bool&amp;的地方都能用这个对象代替。</span><br></pre></td></tr></table></figure><p>那么auto为什么会与隐形代理类有冲突呢？<br>考虑下面这个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;bool&gt; reference(const Widget &amp;w);</span><br><span class="line">Widget w;</span><br><span class="line">auto highPriority&#x3D;features(w)[5];</span><br><span class="line">processWidet(w,highPriority);&#x2F;&#x2F;未定义行为</span><br></pre></td></tr></table></figure><p>为什么最后会是未定义的行为呢？因为processWidget函数中的highPriority参数中接受的实参是一个指针，然后这个指针指向了一个临时对象。<br>下面来一步步剖析这个行为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先features(w)产生一个std::vector&lt;bool&gt;临时对象temp,</span><br><span class="line">执行opterator[ ]后产生一个std::vector&lt;bool&gt;::reference的代理类对象，</span><br><span class="line">这个对象中含有一个指向临时对象temp中的指针，然后再加上5个偏移量。</span><br><span class="line">而processWidget函数中的参数拷贝了这个指针的地址，</span><br><span class="line">在auto highPriority&#x3D;features(w)[5]这条表达式结束的时候，</span><br><span class="line">临时对象temp销毁，但我们却还在后面使用了一个指向这个临时对象temp的指针，</span><br><span class="line">该指针就变成了一个空悬指针，最后就导致了未定义行为。</span><br></pre></td></tr></table></figure><p>那么如何避免这种行为呢？<br>可以采用直接转换的方式，将产生的那个临时对象temp中的某个地址的bool值拷贝下来即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool highPriority&#x3D;features(w)[5];</span><br></pre></td></tr></table></figure><p>也同样可以使用auto+强制类型转换的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto highPriority&#x3D;static_cast&lt;bool&gt;(features(w)[5]);</span><br></pre></td></tr></table></figure><p>综上，auto表达式右边不能直接使用代理类对象，因为auto会推断出一个代理类对象的类型，而不是它想要的类型，就上面这个例子而言，它想要的是一个bool值，而不是一个指向临时对象中的bool的指针。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理类：指为了模拟或增广其他类型的类&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;bool&amp;gt;类下的operator[ ]返回一个隐形代理类对象，即std::vector&amp;lt;bool&amp;gt;::reference对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;std::bitset::reference也是同样的隐形代理类&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective Modern C++" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Effective-Modern-C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>auto、decltype与模板类型推断的异同</title>
    <link href="http://yoursite.com/articles/auto-decltype%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E7%9A%84%E5%BC%82%E5%90%8C.html"/>
    <id>http://yoursite.com/articles/auto-decltype%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E7%9A%84%E5%BC%82%E5%90%8C.html</id>
    <published>2019-12-17T13:22:32.000Z</published>
    <updated>2019-12-18T04:10:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>auto和模板类型推断在一般情况下等价（除非遇到列表实参的情况），这两种推断方式同样会忽略掉初始化表达式的引用性，同样会在形参不是引用的情况下将数组名和函数名退化为指针，而在形参是引用的情况将类型推断为数组类型（包括数组大小）和函数类型。</p><a id="more"></a><p>但是在实参为列表的时候，auto会假定用大括号括起来的初始化表达式代表一个initializer_list，而模板类型推断则不会。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">auto x&#x3D;&#123;1,2,3&#125;;&#x2F;&#x2F;推断类型为initializer_list&lt;int&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void f(T param);</span><br><span class="line"></span><br><span class="line">f(&#123;1,2,3&#125;);&#x2F;&#x2F;这个是错误的，因为模板类型推断无法推断出一个initialist_list</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正确做法</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void f(std::initializer_list&lt;T&gt; initList);</span><br><span class="line"></span><br><span class="line">f(&#123;1,2,3&#125;);&#x2F;&#x2F;正确，推断出T为int</span><br></pre></td></tr></table></figure><p>但是！在函数返回值或者lambda表达式的形参中使用auto，表示的就是要使用模板类型推断！此时不能推断出一个initialist_list！</p><p>那么decltype的类型推断方式有什么不同呢？<br>decltype的类型推断其实就是一个“火眼金睛”，它能够还原实参本来的类型，即数组就推断出数组类型，函数就推断出函数类型。除非另外用括号将一个变量括起来，此时会推断出引用类型。</p><p>在C++ 11中，只允许堆单表达式的lambda的返回值进行类型推断，而在C++ 14中，这个范围扩张到了一切lambda和一切函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++ 11中</span><br><span class="line">template&lt;typename Container,typename Index&gt;</span><br><span class="line">auto func(Container &amp;c,Index i)-&gt;decltype(c[i])</span><br><span class="line">&#123;</span><br><span class="line">return c[i];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++ 14 中</span><br><span class="line">template&lt;typename Container,typename Index&gt;</span><br><span class="line">auto func(Container &amp;c,Index i)</span><br><span class="line">&#123;&#x2F;&#x2F;这是不正确的，因为引用性会被忽略</span><br><span class="line">return c[i];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;保存引用性</span><br><span class="line">template&lt;typename Container,typename Index&gt;</span><br><span class="line">delctype(auto) func(Container &amp;c,Index i)</span><br><span class="line">&#123;</span><br><span class="line">return c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decltype(auto)指auto指定了要实施类型推断的类型，然后采用了decltype的规则，即可以保存引用性</p><p>考虑到传进来的容器可能是一个右值容器，我们需要保存实参的类型再进行类型推断，否则就会出现在对一个右值容器进行赋值的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename Container,typename Index&gt;</span><br><span class="line">delctype(auto) func(Container &amp;&amp;c,Index i)</span><br><span class="line">&#123;</span><br><span class="line">return std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;auto和模板类型推断在一般情况下等价（除非遇到列表实参的情况），这两种推断方式同样会忽略掉初始化表达式的引用性，同样会在形参不是引用的情况下将数组名和函数名退化为指针，而在形参是引用的情况将类型推断为数组类型（包括数组大小）和函数类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective Modern C++" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Effective-Modern-C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>对string调用swap迭代器失效的原因</title>
    <link href="http://yoursite.com/articles/%E5%AF%B9string%E8%B0%83%E7%94%A8swap%E4%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0.html"/>
    <id>http://yoursite.com/articles/%E5%AF%B9string%E8%B0%83%E7%94%A8swap%E4%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0.html</id>
    <published>2019-12-17T07:15:57.000Z</published>
    <updated>2019-12-17T07:47:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在《C++ Primer》中提到，除string外的容器在swap后指向容器的迭代器、引用和指针都不会失效，但却没有说明string调用swap后会失效的原因。</p><a id="more"></a><p>在查阅资料后发现，C++中存在对短字符串的优化，即Short String Optimization（SSO)。</p><p>因为在默认情况下，C++的string都是存储在堆中，导致访问string需要经过一次寻址过程，速度较慢，并且这种实现的空间局部性不好，对cache的利用较低。而且很多string的字符串长度很小，这个时候，就可以把字符串存储到栈上，从而不需要进行内存分配，优化创建速度，并且访问栈上数据的局部性很好，速度比较快。</p><p>即C++会自动把较短的字符串放到对象内部，较长的字符串放到动态内存。假如string 用 SSO 实现，而待交换的两个对象中的字符串恰好一长一短，则原先指向短字符串中的迭代器会全部失效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《C++ Primer》中提到，除string外的容器在swap后指向容器的迭代器、引用和指针都不会失效，但却没有说明string调用swap后会失效的原因。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>实现空间配置器（allocator)</title>
    <link href="http://yoursite.com/articles/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8.html"/>
    <id>http://yoursite.com/articles/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8.html</id>
    <published>2019-12-16T13:49:27.000Z</published>
    <updated>2019-12-16T14:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>allocator 是一个空间配置器而不是内存配置器，因为空间也可以是磁盘或其他辅助存储介质，我们可以写一个allocator直接向磁盘取空间</p><a id="more"></a><h2 id="设计一个简单的空间配置器"><a href="#设计一个简单的空间配置器" class="headerlink" title="设计一个简单的空间配置器"></a>设计一个简单的空间配置器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _CZPALLOC_</span><br><span class="line">#define _CZPALLOC_</span><br><span class="line"></span><br><span class="line">#include &lt;new&gt;;&#x2F;&#x2F;使用定位new</span><br><span class="line">#include &lt;cstddef&gt;&#x2F;&#x2F;使用ptrdiff_t,size_t</span><br><span class="line">#include &lt;cstdlib&gt;&#x2F;&#x2F;使用exit()</span><br><span class="line">#include &lt;climits&gt;&#x2F;&#x2F;使用UINT_MAX,指未分配的可用空间</span><br><span class="line">#include &lt;iostream&gt;&#x2F;&#x2F;使用cerr</span><br><span class="line"></span><br><span class="line">namespace CZP &#123;</span><br><span class="line">&#x2F;&#x2F;分配空间</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline T _allocate(ptrdiff_t size, T*) &#123;&#x2F;&#x2F;size表示分配对应类型内存的个数</span><br><span class="line">set_new_handler(0);&#x2F;&#x2F;设置new失败时调用的处理函数，参数0表示处理函数将被设置为默认值，即会执行抛出bad_alloc异常</span><br><span class="line">T* tmp &#x3D; (T*)(::operator new((size_t)(size * sizeof(T))));</span><br><span class="line">if（!tmp)&#123;</span><br><span class="line">cerr &lt;&lt; &quot;out of memory&quot; &lt;&lt; endl;</span><br><span class="line">exit(1);&#x2F;&#x2F;程序异常退出，参数为0时表示程序正常退出</span><br><span class="line">&#125;</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;释放空间</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void _deallocate(T* buffer) &#123;</span><br><span class="line">::operator delete(buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;构造对象</span><br><span class="line">template &lt;typename T1,typename T2&gt;</span><br><span class="line">inline void _construct(T1* p, const T2&amp; value) &#123;</span><br><span class="line">new(p)T1(value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;销毁对象</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline void _destroy(T* ptr) &#123;</span><br><span class="line">ptr-&gt;~T();</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class allocator &#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;各个类型别名的声明</span><br><span class="line">typedef T value_type;</span><br><span class="line">typedef T* pointer;</span><br><span class="line">typedef const T* const_pointer;</span><br><span class="line">typedef T&amp; reference;</span><br><span class="line">typedef const T&amp; const_reference;</span><br><span class="line">typedef size_t size_type;</span><br><span class="line">typedef ptrdiff_t difference_type;</span><br><span class="line">&#x2F;&#x2F;一个嵌套的类模板</span><br><span class="line">template &lt;typename U&gt;</span><br><span class="line">struct rebind &#123;</span><br><span class="line">typedef allocator&lt;U&gt; other;</span><br><span class="line">&#125;;</span><br><span class="line">pointer allocate(size_type n, const void* hint &#x3D; 0) &#123;&#x2F;&#x2F;第二个参数是个提示，可能会利用来增进区域性（locality），可完全忽略</span><br><span class="line">return _allocate((difference_type)n, (pointer)0);</span><br><span class="line">&#125;</span><br><span class="line">void deallocate(pointer p, size_type n) &#123;</span><br><span class="line">_deallocate(p);</span><br><span class="line">&#125;</span><br><span class="line">void construct(pointer p, const T&amp; value) &#123;</span><br><span class="line">_construct(p, value);</span><br><span class="line">&#125;</span><br><span class="line">void destroy(pointer p) &#123;</span><br><span class="line">_destroy(p);</span><br><span class="line">&#125;</span><br><span class="line">pointer address(reference X) &#123;</span><br><span class="line">return (pointer)&amp;X;</span><br><span class="line">&#125;</span><br><span class="line">const_pointer const_address(const_reference X) &#123;</span><br><span class="line">return (const_pointer)&amp;X;</span><br><span class="line">&#125;</span><br><span class="line">size_type max_size()const &#123;</span><br><span class="line">return size_type(UNIT_MAX &#x2F; sizeof(T));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;我们可以用这个空间配置器作为vector的第二个参数来指定使用它分配空间</span><br><span class="line">#endif &#x2F;&#x2F; !_CZPALLOC_</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;allocator 是一个空间配置器而不是内存配置器，因为空间也可以是磁盘或其他辅助存储介质，我们可以写一个allocator直接向磁盘取空间&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="STL源码剖析" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中类的对象模型探讨</title>
    <link href="http://yoursite.com/articles/C-%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%8E%A2%E8%AE%A8.html"/>
    <id>http://yoursite.com/articles/C-%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%8E%A2%E8%AE%A8.html</id>
    <published>2019-12-16T10:14:05.000Z</published>
    <updated>2019-12-16T14:19:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在C++中，类可以发生多继承，那么派生类中就会出现多份数据，进而导致访问出现二义性的情况。此时我们可以通过访问时添加作用域来解决二义性，但却无法避免同时保存多份数据浪费内存的情况。</p><a id="more"></a><p>这个时候，就可以使用虚继承来使派生类中只有一份数据，避免浪费内存，那么这样的虚继承是怎么实现的呢？</p><p>通过实践知道，对于一个空类，它占用的内存是1字节，而对于只有一个虚函数的类，它占用的内存却是4个字节。而这4个字节，就是一个vptr，即一个指向虚函数表的指针。</p><p>虚函数表中会保存类对象的相关类型（动态类型）以及相关的虚函数。派生类若是重新实现了继承下来的虚函数，那么这个时候虚函数表在运行时就会绑定到这个派生类的类型，其中的虚函数也是对应的相关类型的函数，而此时的vptr就是指向这个虚函数表中对应的函数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在C++中，类可以发生多继承，那么派生类中就会出现多份数据，进而导致访问出现二义性的情况。此时我们可以通过访问时添加作用域来解决二义性，但却无法避免同时保存多份数据浪费内存的情况。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度探索C++对象模型" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++移动构造函数为什么需要noexcept</title>
    <link href="http://yoursite.com/articles/C-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81noexcept.html"/>
    <id>http://yoursite.com/articles/C-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81noexcept.html</id>
    <published>2019-12-16T06:15:26.000Z</published>
    <updated>2019-12-16T14:27:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>在C++中，类的移动操作通常“窃取”资源而不分配资源，所以通常不会抛出任何异常。在编写一个不抛出异常的操作时，我们应该实现通知标准库以避免一些额外的工作。此时我们要在移动操作的声明和定义中添加noexcept来告知标准库。</p><a id="more"></a><p>虽然移动操作通常不会抛出异常，但是抛出异常也是允许的。那么当移动操作抛出异常时会发生什么呢？</p><p>举例来说，标准库要求容器能对异常发生时其自身的行为提供保障，如vector保证如果调用push_back然后分配内存的过程发生异常的话，vector自身不会发生改变。</p><p>而在vector重新分配内存的过程中，如果使用的是拷贝构造函数，即使异常发生了，那么只需要销毁新构造的对象然后释放刚分配的内存即可，vector本身自然不会发生任何改变。</p><p>如果使用的是移动构造函数，而这个移动构造函数发生了异常，那么对象可能移动了一部分，而此时明显无法满足vector本身不发生任何改变的要求。也就是说，我们必须把移动构造函数声明为noexcept来告知标准库这个移动操作可以安全使用，不然就必须使用拷贝构造函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在C++中，类的移动操作通常“窃取”资源而不分配资源，所以通常不会抛出任何异常。在编写一个不抛出异常的操作时，我们应该实现通知标准库以避免一些额外的工作。此时我们要在移动操作的声明和定义中添加noexcept来告知标准库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>计数排序</title>
    <link href="http://yoursite.com/articles/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html"/>
    <id>http://yoursite.com/articles/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html</id>
    <published>2019-12-11T12:14:46.000Z</published>
    <updated>2019-12-11T12:37:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>对于每一个元素，确定小于它的元素个数，然后将该元素放置在对应的位置上。</p><a id="more"></a><h2 id="代码实现（C-）"><a href="#代码实现（C-）" class="headerlink" title="代码实现（C++）"></a>代码实现（C++）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void CountSort(vector&lt;int&gt;&amp; arr, int maxVal) &#123;</span><br><span class="line">int len &#x3D; arr.size();</span><br><span class="line">if (len &lt; 1)</span><br><span class="line">return;</span><br><span class="line">vector&lt;int&gt; count(maxVal + 1, 0);</span><br><span class="line">vector&lt;int&gt; tmp(arr);</span><br><span class="line">for (auto x : arr)</span><br><span class="line">count[x]++;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; maxVal; ++i)</span><br><span class="line">count[i] +&#x3D; count[i - 1];</span><br><span class="line">for (int i &#x3D; len - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">arr[count[tmp[i]] - 1] &#x3D; tmp[i];</span><br><span class="line">count[tmp[i]]--;&#x2F;&#x2F;注意这里要减1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），<br>快于任何比较排序算法。</p><p>而且当O(k)&gt;O(nlogn)的时候其效率反而不如基于比较的排序（<br>基于比较的排序的时间复杂度在理论上的下限是O(nlogn), 如归并排序，堆排序）</p><p>稳定性：稳定<br>注意：计数排序算法不是一个基于比较的排序算法，从而它的计算时间下界不再是O(nlogn)。<br>计数排序算法之所以能取得线性计算时间的上界是因为对元素的取值范围作了一定限制，<br>即k=O(n)。如果k=n2,n3,..，就得不到线性时间的上界。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h2&gt;&lt;p&gt;对于每一个元素，确定小于它的元素个数，然后将该元素放置在对应的位置上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法导论" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈泽平的博客</title>
  
  <subtitle>Always keep it positive</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-22T07:19:12.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>耐清</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>枚举类型使用注意事项</title>
    <link href="http://yoursite.com/articles/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html"/>
    <id>http://yoursite.com/articles/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html</id>
    <published>2019-12-22T04:23:58.000Z</published>
    <updated>2019-12-22T07:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>未命名的enum只能在定义该enum时定义它的对象（分号前面）</p><a id="more"></a><p>枚举成员是const，提供初始值时必须是常量表达式，同时，我们也可以在任何需要常量表达式的地方使用枚举成员。如使用enum作为switch语句的表达式，而将枚举值作为case标签，也能将枚举类型作为非类型模板形参使用，或者在类的定义中初始化枚举类型的静态数据成员</p><p>初始化已命名的enum对象或对其赋值必须使用一个枚举成员或该类型的另一个对象，同时我们不能将整型值传给enum形参，但是可以将一个不限定作用域的枚举类型的对象或枚举成员传给整型形参，因为一个不限定作用域的枚举类型的对象或枚举成员自动转换为整型，而限定作用域的枚举类型则不会进行这样的隐式转换。<br>此时enum的值类型进行提升，但是永远不会提升成unsigned char，即使枚举值可以用unsigned char存储也是如此</p><p>默认情况下限定作用域的enum成员类型是int，我们可以进行指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum adsa:unsigned long long&#123;</span><br><span class="line">-------</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于不限定作用域的枚举类型的枚举成员则不存在默认类型，一般认为足够大够容纳枚举值，如果我们再指定大小的话容易引发程序错误</p><p>枚举类型的前置声明必须指定其成员的大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum adsa:unsigned long long;</span><br><span class="line">enum class opadsa;&#x2F;&#x2F;限定作用域默认为int</span><br></pre></td></tr></table></figure><p>我们不可以在同一个上下文先声明一个限定作用域的enum名字，再声明一个不限定作用域的同名enum；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;未命名的enum只能在定义该enum时定义它的对象（分号前面）&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>使用using的别名声明与typedef的区别</title>
    <link href="http://yoursite.com/articles/%E5%88%AB%E5%90%8D%E5%A3%B0%E6%98%8E%E4%B8%8Etypedef%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
    <id>http://yoursite.com/articles/%E5%88%AB%E5%90%8D%E5%A3%B0%E6%98%8E%E4%B8%8Etypedef%E7%9A%84%E5%8C%BA%E5%88%AB.html</id>
    <published>2019-12-22T03:09:25.000Z</published>
    <updated>2019-12-22T03:22:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用using的别名声明和typedef完成的是一模一样的工作，那么两个之间有什么区别呢？</p><a id="more"></a><p>一个最重要的区别就是使用using的别名声明可以直接进行模板化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">using MyAllocList&#x3D;std::list&lt;T,MyAlooc&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">MyAllocList&lt;Widget&gt; lw;</span><br></pre></td></tr></table></figure><p>而使用typedef的话，就需要将类型放置在类中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct MyAllocList&#123;</span><br><span class="line">typedef std::list&lt;T,MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;使用模板实例下的类型别名;</span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw;</span><br></pre></td></tr></table></figure><p>此外，如果要在模板内使用typedef来创建一个成员，而且它的类型由模板形参指定的话，就需要添加前缀typename来告知编译器这是一个类型成员，而不是static成员(如果是使用using声明的别名则可以直接使用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Widget&#123;</span><br><span class="line">private:</span><br><span class="line">typename MyAllocList&lt;T&gt;::type list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用using的别名声明和typedef完成的是一模一样的工作，那么两个之间有什么区别呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective Modern C++" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Effective-Modern-C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何使用红黑树实现关联容器map（待更新）</title>
    <link href="http://yoursite.com/articles/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8map(%E5%BE%85%E6%9B%B4%E6%96%B0%EF%BC%89.html"/>
    <id>http://yoursite.com/articles/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8map(%E5%BE%85%E6%9B%B4%E6%96%B0%EF%BC%89.html</id>
    <published>2019-12-20T03:22:55.000Z</published>
    <updated>2019-12-23T02:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>关联容器map是一个pair&lt;const key_type,value_type&gt;，基于此建立了从key到value的映射，并且相关的复杂度是log(N)。那么如何使用红黑树来实现它呢？</p><a id="more"></a><p>首先建立一个红黑树的结点结构体，并且这个结点要关联到map的元素，即一个pair数据成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">enum COLOR&#123;RED,BLACK&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key_type,typename Value_type&gt;</span><br><span class="line">struct RBTreeNode&#123;</span><br><span class="line">RBTreeNode&lt;Key_type, Value_type&gt;* left;</span><br><span class="line">RBTreeNode&lt;Key_type, Value_type&gt;* right;</span><br><span class="line">RBTreeNode&lt;Key_type, Value_type&gt;* parent;</span><br><span class="line">pair&lt;Key_type, Value_type&gt; value;</span><br><span class="line">COLOR color;</span><br><span class="line">RBTreeNode(const Key_type&amp; key &#x3D; Key_type(), const Value_type&amp; value&#x3D;Value_type(),COLOR Color&#x3D;RED)</span><br><span class="line">:left(NULL),right(NULL),parent(NULL),value(key,value),color(Color)&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了红黑树的结点，现在假想我们已经有了一颗以map元素类型为结点的红黑树。那么要遍历一个map容器来进行搜索的话我们就需要遍历这颗红黑树，即从它关键值最小的结点遍历到关键值最大的结点。那么我们就需要一种操作（一个类）来进行红黑树的遍历。不难想到可以构建一个红黑树的迭代器来实现这个遍历操作。</p><p>我们知道，迭代器的begin()指向容器的首元素（最小元素），而end()指向容器的尾后元素（最大元素的后一个位置），那么对于一颗红黑树而言，我们就需要另外构建一个尾后结点来让迭代器的end()指向它。假设这个结点命名为header，因为这个结点不能破坏原先红黑树的性质，、所以不能是黑色，只能是红色。</p><p>现在我们需要将这个游离的结点与原先的红黑树相连接，考虑到我们是打算构建一个迭代器，那么就需要将header与树中最小和最大结点连接，假设树中最小元素为minNode，最大元素为maxNode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header-&gt;left&#x3D;minNode;</span><br><span class="line">header-&gt;right&#x3D;maxNode;</span><br></pre></td></tr></table></figure><p>即我们构建的迭代器的begin()指向header的左孩子，而end()指向header，end()后退一步就指向header的右孩子。</p><p>最后这个header结点还需要连接parent，此时我们可以把它和原先树中的根节点互联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header-&gt;parent&#x3D;rootNode;</span><br><span class="line">rootNode-&gt;parent&#x3D;header;</span><br></pre></td></tr></table></figure><p>接下来就可以开心地实现红黑树的迭代器了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename Key_type,typename Value_type&gt;</span><br><span class="line">class RBTreeIterator</span><br><span class="line">&#123;</span><br><span class="line">typedef RBTreeNode&lt;Key_type, Value_type&gt; Node;</span><br><span class="line">typedef node* NodePtr;</span><br><span class="line">typedef RBTreeIterator&lt;Key_type, Value_type&gt; self;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">RBTreeIterator(NodePtr node_ptr&#x3D;nullptr):nodePtr(node_ptr)&#123;&#125;</span><br><span class="line">RBTreeIterator(const self&amp; s) :nodePtr(s.nodePtr)&#123;&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;Key_type, Value_type&gt;&amp; operator*() &#123;</span><br><span class="line">return nodePtr-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;Key_type, Value_type&gt;* operator-&gt;() &#123;</span><br><span class="line">return &amp;(operator*()):</span><br><span class="line">&#125;</span><br><span class="line">self&amp; operator++() &#123;</span><br><span class="line">RBTreeItIncrement();</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">self operator++(int) &#123;</span><br><span class="line">self tmp(*this);</span><br><span class="line">RBTreeItIncrement();</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line">self&amp; operator--() &#123;</span><br><span class="line">RBTreeItDeCrement();</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">self operator--(int) &#123;</span><br><span class="line">self tmp(*this);</span><br><span class="line">RBTreeItDecrement();</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line">bool operator&#x3D;&#x3D;(const self&amp; s) &#123;</span><br><span class="line">return nodePtr &#x3D;&#x3D; s.nodePtr;</span><br><span class="line">&#125;</span><br><span class="line">bool operator!&#x3D;(const self&amp; s) &#123;</span><br><span class="line">return !(this &#x3D;&#x3D; s);</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">void RBTreeItIncrement() &#123;</span><br><span class="line">if (nodePtr-&gt;right) &#123;</span><br><span class="line">nodePtr &#x3D; nodePtr-&gt;right;</span><br><span class="line">while (nodePtr-&gt;left)</span><br><span class="line">nodePtr &#x3D; nodePtr-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">NodePtr nodeParent &#x3D; nodePtr-&gt;parent;</span><br><span class="line">while (nodePtr &#x3D;&#x3D; nodeParent-&gt;right) &#123;</span><br><span class="line">nodePtr &#x3D; nodeParent;</span><br><span class="line">nodeParent &#x3D; nodePtr-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line">if (nodePtr-&gt;right !&#x3D; nodeParent)</span><br><span class="line">nodePtr &#x3D; nodeParent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void RBTreeItDecrement() &#123;</span><br><span class="line">if (nodePtr-&gt;parent-&gt;parent &#x3D;&#x3D; nodePtr &amp;&amp; nodePtr-&gt;color &#x3D;&#x3D; RED)</span><br><span class="line">nodePtr &#x3D; nodePtr-&gt;right;</span><br><span class="line">else if (nodePtr-&gt;left) &#123;</span><br><span class="line">nodePtr &#x3D; nodePtr-&gt;left;</span><br><span class="line">while (nodePtr-&gt;right)</span><br><span class="line">nodePtr &#x3D; nodePtr-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">NodePtr nodeParent &#x3D; nodePtr-&gt;parent;</span><br><span class="line">while (nodePtr &#x3D;&#x3D; nodePtr-&gt;left) &#123;</span><br><span class="line">nodePtr &#x3D; nodeParent;</span><br><span class="line">nodeParent &#x3D; nodePtr-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line">nodePtr &#x3D; nodeParent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">NodePtr nodePtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关联容器map是一个pair&amp;lt;const key_type,value_type&amp;gt;，基于此建立了从key到value的映射，并且相关的复杂度是log(N)。那么如何使用红黑树来实现它呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="STL源码剖析" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>为什么说vector的接口设计是败笔</title>
    <link href="http://yoursite.com/articles/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4vector%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E6%98%AF%E8%B4%A5%E7%AC%94.html"/>
    <id>http://yoursite.com/articles/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4vector%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E6%98%AF%E8%B4%A5%E7%AC%94.html</id>
    <published>2019-12-18T15:03:09.000Z</published>
    <updated>2019-12-18T15:31:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个类的设计者，我们应该把构造函数设计成客户无论使用小括号还是大括号都不会影响要调用的重载版本，而vector的构造函数却恰恰破坏了这个隐性规定。我们知道，在构造一个vector的时候，使用大小括号来构造对象会产生完全不一样的结果。</p><a id="more"></a><p>为什么会这样呢？<br>首先，使用大括号来进行初始化对象有三个特点，第一个特点就是它禁止了会损失精度的隐式转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double x,y,z;</span><br><span class="line">int sum&#123;x+y+z&#125;; &#x2F;&#x2F;错误</span><br></pre></td></tr></table></figure><p>第二个特点就是不会变成一个函数的声明，因为用小括号来调用不带参数的构造函数的时候就会变成一个函数的声明，而大括号则不会，依旧会调用没有形参的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Widget w1();&#x2F;&#x2F;这是一个函数声明</span><br><span class="line">Widget w2&#123; &#125;;&#x2F;&#x2F;这调用了没有形参的构造函数</span><br></pre></td></tr></table></figure><p>第三个特点就是在构造函数的重载决议期间，只要大括号内的实参能与带std::initializer_list类型的形参匹配或进行隐式转换，就会调用这个构造函数，而若是存在带std::initializer_list类型的形参的构造函数，而实参与形参之间需要进行转换且转换会损失精度，那么就会出错。此外如果该构造函数的形参与实参完全不匹配（无法进行隐式转换，如实参int形参string），才会考虑其他的候选函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget(std::initializer_list&lt;bool&gt; il);&#x2F;&#x2F;其中一个构造函数</span><br><span class="line"></span><br><span class="line">Widget w&#123;10,5.0&#125;;&#x2F;&#x2F;错误，bool无法精确表示这两个值中的任何一个</span><br><span class="line"></span><br><span class="line">Widget(std::initializer_list&lt;string&gt; il)&#x2F;&#x2F;其中一个构造函数</span><br><span class="line"></span><br><span class="line">Widget w2&#123;10,5.0&#125;; &#x2F;&#x2F;考虑匹配其他构造函数</span><br></pre></td></tr></table></figure><p>还有一点需要注意的就是当实参为空的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w1&#123; &#125;;&#x2F;&#x2F;调用默认构造函数</span><br><span class="line">Widget w2 (&#123; &#125;);&#x2F;&#x2F;调用带std::initializer_list的构造函数</span><br><span class="line">Widget w2 &#123;&#123; &#125;&#125;;&#x2F;&#x2F;调用带std::initializer_list的构造函数</span><br></pre></td></tr></table></figure><p>我们知道vector中有一个带initializer_list的构造函数和一个不带initializer_list形参的构造函数，那么用大小括号来初始化它的对象的时候，就会出现完全不一样的结果，但是我们原先却是希望无论使用大小括号都不要影响到调用的重载版本的。所以才说vector的接口设计就是败笔</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个类的设计者，我们应该把构造函数设计成客户无论使用小括号还是大括号都不会影响要调用的重载版本，而vector的构造函数却恰恰破坏了这个隐性规定。我们知道，在构造一个vector的时候，使用大小括号来构造对象会产生完全不一样的结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective Modern C++" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Effective-Modern-C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>如何理解auto与隐形代理类之间的冲突</title>
    <link href="http://yoursite.com/articles/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3auto%E4%B8%8E%E4%BB%A3%E7%90%86%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%B2%E7%AA%81.html"/>
    <id>http://yoursite.com/articles/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3auto%E4%B8%8E%E4%BB%A3%E7%90%86%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%B2%E7%AA%81.html</id>
    <published>2019-12-18T04:07:13.000Z</published>
    <updated>2019-12-18T05:51:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>代理类：指为了模拟或增广其他类型的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;bool&gt;类下的operator[ ]返回一个隐形代理类对象，即std::vector&lt;bool&gt;::reference对象</span><br><span class="line"></span><br><span class="line">std::bitset::reference也是同样的隐形代理类</span><br></pre></td></tr></table></figure><a id="more"></a><p>为什么说是隐形？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;bool&gt;是一个经过特例化的类，它的对象采用了一种压缩的方式表示其特有的bool元素，</span><br><span class="line">每一个bool元素用一个比特来表示。</span><br><span class="line">因为C++中禁止了比特的引用，所以它的operator[ ]不能返回bool&amp;。</span><br><span class="line">那么它就需要返回一个像bool&amp;的对象。</span><br><span class="line">即需要模拟bool&amp;，就是用std::vector&lt;bool&gt;::reference这个代理类对象来代理bool&amp;,</span><br><span class="line">所以要保证它像bool&amp;，而且所有能用bool&amp;的地方都能用这个对象代替。</span><br></pre></td></tr></table></figure><p>那么auto为什么会与隐形代理类有冲突呢？<br>考虑下面这个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;bool&gt; reference(const Widget &amp;w);</span><br><span class="line">Widget w;</span><br><span class="line">auto highPriority&#x3D;features(w)[5];</span><br><span class="line">processWidet(w,highPriority);&#x2F;&#x2F;未定义行为</span><br></pre></td></tr></table></figure><p>为什么最后会是未定义的行为呢？因为processWidget函数中的highPriority参数中接受的实参是一个指针，然后这个指针指向了一个临时对象。<br>下面来一步步剖析这个行为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先features(w)产生一个std::vector&lt;bool&gt;临时对象temp,</span><br><span class="line">执行opterator[ ]后产生一个std::vector&lt;bool&gt;::reference的代理类对象，</span><br><span class="line">这个对象中含有一个指向临时对象temp中的指针，然后再加上5个偏移量。</span><br><span class="line">而processWidget函数中的参数拷贝了这个指针的地址，</span><br><span class="line">在auto highPriority&#x3D;features(w)[5]这条表达式结束的时候，</span><br><span class="line">临时对象temp销毁，但我们却还在后面使用了一个指向这个临时对象temp的指针，</span><br><span class="line">该指针就变成了一个空悬指针，最后就导致了未定义行为。</span><br></pre></td></tr></table></figure><p>那么如何避免这种行为呢？<br>可以采用直接转换的方式，将产生的那个临时对象temp中的某个地址的bool值拷贝下来即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool highPriority&#x3D;features(w)[5];</span><br></pre></td></tr></table></figure><p>也同样可以使用auto+强制类型转换的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto highPriority&#x3D;static_cast&lt;bool&gt;(features(w)[5]);</span><br></pre></td></tr></table></figure><p>综上，auto表达式右边不能直接使用代理类对象，因为auto会推断出一个代理类对象的类型，而不是它想要的类型，就上面这个例子而言，它想要的是一个bool值，而不是一个指向临时对象中的bool的指针。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理类：指为了模拟或增广其他类型的类&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;bool&amp;gt;类下的operator[ ]返回一个隐形代理类对象，即std::vector&amp;lt;bool&amp;gt;::reference对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;std::bitset::reference也是同样的隐形代理类&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective Modern C++" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Effective-Modern-C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>auto、decltype与模板类型推断的异同</title>
    <link href="http://yoursite.com/articles/auto-decltype%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E7%9A%84%E5%BC%82%E5%90%8C.html"/>
    <id>http://yoursite.com/articles/auto-decltype%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E7%9A%84%E5%BC%82%E5%90%8C.html</id>
    <published>2019-12-17T13:22:32.000Z</published>
    <updated>2019-12-18T04:10:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>auto和模板类型推断在一般情况下等价（除非遇到列表实参的情况），这两种推断方式同样会忽略掉初始化表达式的引用性，同样会在形参不是引用的情况下将数组名和函数名退化为指针，而在形参是引用的情况将类型推断为数组类型（包括数组大小）和函数类型。</p><a id="more"></a><p>但是在实参为列表的时候，auto会假定用大括号括起来的初始化表达式代表一个initializer_list，而模板类型推断则不会。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">auto x&#x3D;&#123;1,2,3&#125;;&#x2F;&#x2F;推断类型为initializer_list&lt;int&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void f(T param);</span><br><span class="line"></span><br><span class="line">f(&#123;1,2,3&#125;);&#x2F;&#x2F;这个是错误的，因为模板类型推断无法推断出一个initialist_list</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正确做法</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void f(std::initializer_list&lt;T&gt; initList);</span><br><span class="line"></span><br><span class="line">f(&#123;1,2,3&#125;);&#x2F;&#x2F;正确，推断出T为int</span><br></pre></td></tr></table></figure><p>但是！在函数返回值或者lambda表达式的形参中使用auto，表示的就是要使用模板类型推断！此时不能推断出一个initialist_list！</p><p>那么decltype的类型推断方式有什么不同呢？<br>decltype的类型推断其实就是一个“火眼金睛”，它能够还原实参本来的类型，即数组就推断出数组类型，函数就推断出函数类型。除非另外用括号将一个变量括起来，此时会推断出引用类型。</p><p>在C++ 11中，只允许堆单表达式的lambda的返回值进行类型推断，而在C++ 14中，这个范围扩张到了一切lambda和一切函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;C++ 11中</span><br><span class="line">template&lt;typename Container,typename Index&gt;</span><br><span class="line">auto func(Container &amp;c,Index i)-&gt;decltype(c[i])</span><br><span class="line">&#123;</span><br><span class="line">return c[i];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;C++ 14 中</span><br><span class="line">template&lt;typename Container,typename Index&gt;</span><br><span class="line">auto func(Container &amp;c,Index i)</span><br><span class="line">&#123;&#x2F;&#x2F;这是不正确的，因为引用性会被忽略</span><br><span class="line">return c[i];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;保存引用性</span><br><span class="line">template&lt;typename Container,typename Index&gt;</span><br><span class="line">delctype(auto) func(Container &amp;c,Index i)</span><br><span class="line">&#123;</span><br><span class="line">return c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decltype(auto)指auto指定了要实施类型推断的类型，然后采用了decltype的规则，即可以保存引用性</p><p>考虑到传进来的容器可能是一个右值容器，我们需要保存实参的类型再进行类型推断，否则就会出现在对一个右值容器进行赋值的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename Container,typename Index&gt;</span><br><span class="line">delctype(auto) func(Container &amp;&amp;c,Index i)</span><br><span class="line">&#123;</span><br><span class="line">return std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;auto和模板类型推断在一般情况下等价（除非遇到列表实参的情况），这两种推断方式同样会忽略掉初始化表达式的引用性，同样会在形参不是引用的情况下将数组名和函数名退化为指针，而在形参是引用的情况将类型推断为数组类型（包括数组大小）和函数类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective Modern C++" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Effective-Modern-C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>对string调用swap迭代器失效的原因</title>
    <link href="http://yoursite.com/articles/%E5%AF%B9string%E8%B0%83%E7%94%A8swap%E4%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0.html"/>
    <id>http://yoursite.com/articles/%E5%AF%B9string%E8%B0%83%E7%94%A8swap%E4%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0.html</id>
    <published>2019-12-17T07:15:57.000Z</published>
    <updated>2019-12-17T07:47:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在《C++ Primer》中提到，除string外的容器在swap后指向容器的迭代器、引用和指针都不会失效，但却没有说明string调用swap后会失效的原因。</p><a id="more"></a><p>在查阅资料后发现，C++中存在对短字符串的优化，即Short String Optimization（SSO)。</p><p>因为在默认情况下，C++的string都是存储在堆中，导致访问string需要经过一次寻址过程，速度较慢，并且这种实现的空间局部性不好，对cache的利用较低。而且很多string的字符串长度很小，这个时候，就可以把字符串存储到栈上，从而不需要进行内存分配，优化创建速度，并且访问栈上数据的局部性很好，速度比较快。</p><p>即C++会自动把较短的字符串放到对象内部，较长的字符串放到动态内存。假如string 用 SSO 实现，而待交换的两个对象中的字符串恰好一长一短，则原先指向短字符串中的迭代器会全部失效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在《C++ Primer》中提到，除string外的容器在swap后指向容器的迭代器、引用和指针都不会失效，但却没有说明string调用swap后会失效的原因。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>实现空间配置器（allocator)</title>
    <link href="http://yoursite.com/articles/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8.html"/>
    <id>http://yoursite.com/articles/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8.html</id>
    <published>2019-12-16T13:49:27.000Z</published>
    <updated>2019-12-16T14:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>allocator 是一个空间配置器而不是内存配置器，因为空间也可以是磁盘或其他辅助存储介质，我们可以写一个allocator直接向磁盘取空间</p><a id="more"></a><h2 id="设计一个简单的空间配置器"><a href="#设计一个简单的空间配置器" class="headerlink" title="设计一个简单的空间配置器"></a>设计一个简单的空间配置器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _CZPALLOC_</span><br><span class="line">#define _CZPALLOC_</span><br><span class="line"></span><br><span class="line">#include &lt;new&gt;;&#x2F;&#x2F;使用定位new</span><br><span class="line">#include &lt;cstddef&gt;&#x2F;&#x2F;使用ptrdiff_t,size_t</span><br><span class="line">#include &lt;cstdlib&gt;&#x2F;&#x2F;使用exit()</span><br><span class="line">#include &lt;climits&gt;&#x2F;&#x2F;使用UINT_MAX,指未分配的可用空间</span><br><span class="line">#include &lt;iostream&gt;&#x2F;&#x2F;使用cerr</span><br><span class="line"></span><br><span class="line">namespace CZP &#123;</span><br><span class="line">&#x2F;&#x2F;分配空间</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline T _allocate(ptrdiff_t size, T*) &#123;&#x2F;&#x2F;size表示分配对应类型内存的个数</span><br><span class="line">set_new_handler(0);&#x2F;&#x2F;设置new失败时调用的处理函数，参数0表示处理函数将被设置为默认值，即会执行抛出bad_alloc异常</span><br><span class="line">T* tmp &#x3D; (T*)(::operator new((size_t)(size * sizeof(T))));</span><br><span class="line">if（!tmp)&#123;</span><br><span class="line">cerr &lt;&lt; &quot;out of memory&quot; &lt;&lt; endl;</span><br><span class="line">exit(1);&#x2F;&#x2F;程序异常退出，参数为0时表示程序正常退出</span><br><span class="line">&#125;</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;释放空间</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void _deallocate(T* buffer) &#123;</span><br><span class="line">::operator delete(buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;构造对象</span><br><span class="line">template &lt;typename T1,typename T2&gt;</span><br><span class="line">inline void _construct(T1* p, const T2&amp; value) &#123;</span><br><span class="line">new(p)T1(value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;销毁对象</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline void _destroy(T* ptr) &#123;</span><br><span class="line">ptr-&gt;~T();</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class allocator &#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;各个类型别名的声明</span><br><span class="line">typedef T value_type;</span><br><span class="line">typedef T* pointer;</span><br><span class="line">typedef const T* const_pointer;</span><br><span class="line">typedef T&amp; reference;</span><br><span class="line">typedef const T&amp; const_reference;</span><br><span class="line">typedef size_t size_type;</span><br><span class="line">typedef ptrdiff_t difference_type;</span><br><span class="line">&#x2F;&#x2F;一个嵌套的类模板</span><br><span class="line">template &lt;typename U&gt;</span><br><span class="line">struct rebind &#123;</span><br><span class="line">typedef allocator&lt;U&gt; other;</span><br><span class="line">&#125;;</span><br><span class="line">pointer allocate(size_type n, const void* hint &#x3D; 0) &#123;&#x2F;&#x2F;第二个参数是个提示，可能会利用来增进区域性（locality），可完全忽略</span><br><span class="line">return _allocate((difference_type)n, (pointer)0);</span><br><span class="line">&#125;</span><br><span class="line">void deallocate(pointer p, size_type n) &#123;</span><br><span class="line">_deallocate(p);</span><br><span class="line">&#125;</span><br><span class="line">void construct(pointer p, const T&amp; value) &#123;</span><br><span class="line">_construct(p, value);</span><br><span class="line">&#125;</span><br><span class="line">void destroy(pointer p) &#123;</span><br><span class="line">_destroy(p);</span><br><span class="line">&#125;</span><br><span class="line">pointer address(reference X) &#123;</span><br><span class="line">return (pointer)&amp;X;</span><br><span class="line">&#125;</span><br><span class="line">const_pointer const_address(const_reference X) &#123;</span><br><span class="line">return (const_pointer)&amp;X;</span><br><span class="line">&#125;</span><br><span class="line">size_type max_size()const &#123;</span><br><span class="line">return size_type(UNIT_MAX &#x2F; sizeof(T));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;我们可以用这个空间配置器作为vector的第二个参数来指定使用它分配空间</span><br><span class="line">#endif &#x2F;&#x2F; !_CZPALLOC_</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;allocator 是一个空间配置器而不是内存配置器，因为空间也可以是磁盘或其他辅助存储介质，我们可以写一个allocator直接向磁盘取空间&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="STL源码剖析" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中类的对象模型探讨</title>
    <link href="http://yoursite.com/articles/C-%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%8E%A2%E8%AE%A8.html"/>
    <id>http://yoursite.com/articles/C-%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%8E%A2%E8%AE%A8.html</id>
    <published>2019-12-16T10:14:05.000Z</published>
    <updated>2019-12-16T14:19:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在C++中，类可以发生多继承，那么派生类中就会出现多份数据，进而导致访问出现二义性的情况。此时我们可以通过访问时添加作用域来解决二义性，但却无法避免同时保存多份数据浪费内存的情况。</p><a id="more"></a><p>这个时候，就可以使用虚继承来使派生类中只有一份数据，避免浪费内存，那么这样的虚继承是怎么实现的呢？</p><p>通过实践知道，对于一个空类，它占用的内存是1字节，而对于只有一个虚函数的类，它占用的内存却是4个字节。而这4个字节，就是一个vptr，即一个指向虚函数表的指针。</p><p>虚函数表中会保存类对象的相关类型（动态类型）以及相关的虚函数。派生类若是重新实现了继承下来的虚函数，那么这个时候虚函数表在运行时就会绑定到这个派生类的类型，其中的虚函数也是对应的相关类型的函数，而此时的vptr就是指向这个虚函数表中对应的函数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在C++中，类可以发生多继承，那么派生类中就会出现多份数据，进而导致访问出现二义性的情况。此时我们可以通过访问时添加作用域来解决二义性，但却无法避免同时保存多份数据浪费内存的情况。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度探索C++对象模型" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++移动构造函数为什么需要noexcept</title>
    <link href="http://yoursite.com/articles/C-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81noexcept.html"/>
    <id>http://yoursite.com/articles/C-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81noexcept.html</id>
    <published>2019-12-16T06:15:26.000Z</published>
    <updated>2019-12-16T14:27:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>在C++中，类的移动操作通常“窃取”资源而不分配资源，所以通常不会抛出任何异常。在编写一个不抛出异常的操作时，我们应该实现通知标准库以避免一些额外的工作。此时我们要在移动操作的声明和定义中添加noexcept来告知标准库。</p><a id="more"></a><p>虽然移动操作通常不会抛出异常，但是抛出异常也是允许的。那么当移动操作抛出异常时会发生什么呢？</p><p>举例来说，标准库要求容器能对异常发生时其自身的行为提供保障，如vector保证如果调用push_back然后分配内存的过程发生异常的话，vector自身不会发生改变。</p><p>而在vector重新分配内存的过程中，如果使用的是拷贝构造函数，即使异常发生了，那么只需要销毁新构造的对象然后释放刚分配的内存即可，vector本身自然不会发生任何改变。</p><p>如果使用的是移动构造函数，而这个移动构造函数发生了异常，那么对象可能移动了一部分，而此时明显无法满足vector本身不发生任何改变的要求。也就是说，我们必须把移动构造函数声明为noexcept来告知标准库这个移动操作可以安全使用，不然就必须使用拷贝构造函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在C++中，类的移动操作通常“窃取”资源而不分配资源，所以通常不会抛出任何异常。在编写一个不抛出异常的操作时，我们应该实现通知标准库以避免一些额外的工作。此时我们要在移动操作的声明和定义中添加noexcept来告知标准库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>计数排序</title>
    <link href="http://yoursite.com/articles/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html"/>
    <id>http://yoursite.com/articles/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html</id>
    <published>2019-12-11T12:14:46.000Z</published>
    <updated>2019-12-11T12:37:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>对于每一个元素，确定小于它的元素个数，然后将该元素放置在对应的位置上。</p><a id="more"></a><h2 id="代码实现（C-）"><a href="#代码实现（C-）" class="headerlink" title="代码实现（C++）"></a>代码实现（C++）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void CountSort(vector&lt;int&gt;&amp; arr, int maxVal) &#123;</span><br><span class="line">int len &#x3D; arr.size();</span><br><span class="line">if (len &lt; 1)</span><br><span class="line">return;</span><br><span class="line">vector&lt;int&gt; count(maxVal + 1, 0);</span><br><span class="line">vector&lt;int&gt; tmp(arr);</span><br><span class="line">for (auto x : arr)</span><br><span class="line">count[x]++;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; maxVal; ++i)</span><br><span class="line">count[i] +&#x3D; count[i - 1];</span><br><span class="line">for (int i &#x3D; len - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">arr[count[tmp[i]] - 1] &#x3D; tmp[i];</span><br><span class="line">count[tmp[i]]--;&#x2F;&#x2F;注意这里要减1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），<br>快于任何比较排序算法。</p><p>而且当O(k)&gt;O(nlogn)的时候其效率反而不如基于比较的排序（<br>基于比较的排序的时间复杂度在理论上的下限是O(nlogn), 如归并排序，堆排序）</p><p>稳定性：稳定<br>注意：计数排序算法不是一个基于比较的排序算法，从而它的计算时间下界不再是O(nlogn)。<br>计数排序算法之所以能取得线性计算时间的上界是因为对元素的取值范围作了一定限制，<br>即k=O(n)。如果k=n2,n3,..，就得不到线性时间的上界。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h2&gt;&lt;p&gt;对于每一个元素，确定小于它的元素个数，然后将该元素放置在对应的位置上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法导论" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="排序算法" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>引论</title>
    <link href="http://yoursite.com/articles/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8601%E5%BC%95%E8%AE%BA.html"/>
    <id>http://yoursite.com/articles/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%8601%E5%BC%95%E8%AE%BA.html</id>
    <published>2019-12-10T13:56:50.000Z</published>
    <updated>2019-12-23T02:55:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>将高级语言翻译为低级语言的程序<br>工作流程：源代码-&gt;预处理器-&gt;编译器-&gt;目标代码-&gt;链接器-&gt;可执行程序</p><a id="more"></a><p>源程序可能被分割称为多个模块，并存放于独立的文件，此时由预处理器来将源程序聚合在一起<br>（预处理器是在真正的编译开始之前由编译器调用的独立程序。预处理器可以删除注释、包含其他文件以及执行宏替代。）</p><p><em>宏是一种抽象，它根据一系列预定义的规则替换一定的文本模式。解释器或编译器在遇到宏时会自动进行这一模式替换。对于编译语言，宏展开在编译时发生，进行宏展开的工具常被称为宏展开器。</em></p><p>汇编语言比较容易输出和调试，所以编译器（可能）产生一个汇编语言程序作为其输出，这个程序由汇编器程序进行处理，并生成<strong>可重定位的机器代码</strong></p><p>因为大型程序经常分为多个部分进行编译，所以可重定位的机器代码有必要和其他可重定位的目标文件以及库文件连接到一起，从而形成真正在机器上运行的代码</p><p>一个文件中的代码可能指向另一个文件中的位置，而链接器能够解决外部内存地址的问题</p><p>最后加载器把所有的可执行目标文件放到内存中执行</p><p>对于C#、VB等高级语言而言，此时编译器完成的功能是把源码编译成通用中间语言（MSIL/CIL）的字节码（ByteCode）。最后运行的时候通过通用语言运行库（虚拟机）的转换，编成最终可以被CPU直接计算的机器码（NativeCode）</p><p>字节码是可以发送给任何平台并且能在那个平台上运行的独立于平台的代码。</p><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>又称为直译器，是一种电脑程序，能够把高级编程语言一行一行直接转译运行。解释器的程序运行速度比较缓慢，但错误诊断效果通常比编译器好</p><h3 id="关于Java"><a href="#关于Java" class="headerlink" title="关于Java"></a>关于Java</h3><p>大多数用任何语言写的程序在每个电脑平台上都必须重编译，甚至有时需要重写。而Java最大的优点之一就是你只需要写和编译一次程序。在任何平台上，Java都会将编译好的字节码解释成能被特定的处理器所理解的指令(即一次编译，到处运行)。Java虚拟机一次只能处理一条字节码指令。</p><h3 id="Java语言处理器"><a href="#Java语言处理器" class="headerlink" title="Java语言处理器"></a>Java语言处理器</h3><p>工作流程：源程序-&gt;（编译）-&gt;字节码-&gt;（虚拟机）-&gt;解释执行<br>即时编译器（JIT compiler）：随虚拟机一起供给的，并可选使用。它把字节码编译成可立即执行的指定平台的可执行代码。选择JIT编译器选项通常会使程序运行地更快，尤其是当某个可执行的方法被重复使用时。<br>（一旦代码被JIT编译器（重）编译后，它在电脑上通常就会运行地更快。）</p><h2 id="编译器的结构"><a href="#编译器的结构" class="headerlink" title="编译器的结构"></a>编译器的结构</h2><p>分析部分+综合部分<br>（即前端+优化+后端）<br>分析部分：分解源程序，按语法结构创建中间表示，并收集源程序的信息存放在称为符号表的数据结构中。最后将符号表和中间表示形式一起传送给综合部分<br>综合部分：利用符号表和中间表示形式来构造用户想要的目标程序</p><!--more--><h3 id="词法分析-扫描"><a href="#词法分析-扫描" class="headerlink" title="词法分析/扫描"></a>词法分析/扫描</h3><p>词法分析器读入组成源程序的字符流，组织成词素的序列，最后将每个词素以词法单元的形式输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">position &#x3D; initial + rate * 60;</span><br><span class="line">&lt;id,1&gt;&lt;&#x3D;&gt;&lt;id,2&gt;&lt;+&gt;&lt;id,3&gt;&lt;*&gt;&lt;60&gt;</span><br></pre></td></tr></table></figure><h3 id="语法分析-解析"><a href="#语法分析-解析" class="headerlink" title="语法分析/解析"></a>语法分析/解析</h3><p>语法分析器使用词法单元来创建树形的中间表示，最后将语法树输出</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语义分析器使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。同时收集类型信息，并存放在语法树和符号表中，以便在随后的中间代码生成过程中使用</p><p>语义分析的一个重要部分：类型检查，即检查每个运算符是否具有匹配的运算分量（可能允许自动类型转换）</p><h3 id="中间代码"><a href="#中间代码" class="headerlink" title="中间代码"></a>中间代码</h3><p>特点：易于生成，且能够被轻松翻译为目标机器上的语言<br>三地址代码：由类似于汇编语言的指令组成，且每个指令（最多）具有三个运算分量，而每个运算分量就像一个寄存器<br>每个三地址赋值指令的右部最多只有一个运算符</p><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>将源程序的中间表示形式映射到目标语言，如果目标语言是机器语言，则必须为程序使用的每个变量选择寄存器或内存位置（要合理分配寄存器以存放变量的值）<br>数字前面加井号表示将该数字当作立即数处理</p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>为每个变量创建一个记录条目，记录的字段就是名字的各个属性。<br><em>符号表可以让编译器迅速查找到每个名字的记录，并向记录中快速存放和获取记录中的数据</em></p><h2 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h2><p>又称为扩建的语言，或者动态语言，是一种编程语言。<br>脚本语言是为了缩短传统的编写-编译-链接-运行过程而创建的计算机编程语言。用来控制软件应用程序，脚本通常以文本（如ASCII)保存，只在被调用时进行解释或编译。</p><p>一个脚本通常是解释执行而非编译。脚本语言通常都有简单、易学、易用的特性，目的就是希望能让程序员快速完成程序的编写工作。而宏语言则可视为脚本语言的分支，两者也有实质上的相同之处。</p><h2 id="并行性"><a href="#并行性" class="headerlink" title="并行性"></a>并行性</h2><p>指令层次：多个运算可以同时执行<br>处理器层次：同一应用的多个不同线程在不同的处理器上运行</p><p>这种并行性可以对程序员隐藏起来，硬件动态地检测顺序指令流之间的依赖关系，并且在可能的时候并法地发出指令。<br>硬件调度器：改变指令的顺序以提高程序的并行性</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编译器&quot;&gt;&lt;a href=&quot;#编译器&quot; class=&quot;headerlink&quot; title=&quot;编译器&quot;&gt;&lt;/a&gt;编译器&lt;/h2&gt;&lt;p&gt;将高级语言翻译为低级语言的程序&lt;br&gt;工作流程：源代码-&amp;gt;预处理器-&amp;gt;编译器-&amp;gt;目标代码-&amp;gt;链接器-&amp;gt;可执行程序&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="编译原理" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://yoursite.com/articles/%E7%BA%A2%E9%BB%91%E6%A0%91.html"/>
    <id>http://yoursite.com/articles/%E7%BA%A2%E9%BB%91%E6%A0%91.html</id>
    <published>2019-12-08T12:54:13.000Z</published>
    <updated>2019-12-16T14:23:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h2><p>每个结点非红即黑，根结点和叶结点为黑色<br>红结点的孩子都是黑结点<br>对每个结点，从该结点到所有后代叶结点的简单路径上，均包含相同数目的黑结点</p><a id="more"></a><h2 id="左旋转操作"><a href="#左旋转操作" class="headerlink" title="左旋转操作"></a>左旋转操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void RBTree::RotateLeft(RBTreeNode* Node) &#123;</span><br><span class="line">RBTreeNode* RNode &#x3D; Node-&gt;right;</span><br><span class="line">Node-&gt;right &#x3D; RNode-&gt;left;</span><br><span class="line">if (RNode-&gt;left !&#x3D; NULL) &#123;</span><br><span class="line">RNode-&gt;left-&gt;parent &#x3D; Node;</span><br><span class="line">&#125;</span><br><span class="line">RNode-&gt;parent&#x3D;Node-&gt;parent; </span><br><span class="line">if (Node-&gt;parent &#x3D;&#x3D; nil) root &#x3D; RNode;</span><br><span class="line">else if (Node-&gt;parent-&gt;left &#x3D;&#x3D; Node) Node-&gt;parent-&gt;left &#x3D; RNode;</span><br><span class="line">else Node-&gt;parent-&gt;right &#x3D; RNode;</span><br><span class="line">RNode-&gt;left &#x3D; Node;</span><br><span class="line">Node-&gt;parent &#x3D; RNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="右旋转操作"><a href="#右旋转操作" class="headerlink" title="右旋转操作"></a>右旋转操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void RBTree::RotateRight(RBTreeNode* Node) &#123;</span><br><span class="line">RBTreeNode* LNode &#x3D; Node-&gt;left;</span><br><span class="line">Node-&gt;left &#x3D; LNode-&gt;right;</span><br><span class="line">if (LNode-&gt;right !&#x3D; NULL) &#123;</span><br><span class="line">LNode-&gt;right-&gt;parent &#x3D; Node;</span><br><span class="line">&#125;</span><br><span class="line">LNode-&gt;parent &#x3D; Node-&gt;parent;</span><br><span class="line">if (Node-&gt;parent &#x3D;&#x3D; nil) root &#x3D; LNode;</span><br><span class="line">else if (Node-&gt;parent-&gt;left &#x3D;&#x3D; Node) Node-&gt;parent-&gt;left &#x3D; LNode;</span><br><span class="line">else Node-&gt;parent-&gt;right &#x3D; LNode;</span><br><span class="line">LNode-&gt;right &#x3D; Node;</span><br><span class="line">Node-&gt;parent &#x3D; LNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//注意：旋转操作中如果旋转结点为红色，且其父结点也是红色，那么旋转之后不会破坏红黑树的最后一条性质</p><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void RBTree::Insert(RBTreeNode* root,RBTreeNode* NNode) &#123;</span><br><span class="line">RBTreeNode* PNode &#x3D; nil;</span><br><span class="line">RBTreeNode* TempNode &#x3D; root;</span><br><span class="line">while (TempNode !&#x3D; NULL) &#123;</span><br><span class="line">PNode &#x3D; TempNode;</span><br><span class="line">if (val &lt; TempNode-&gt;val) TempNode &#x3D; TempNode-&gt;left;</span><br><span class="line">else TempNode &#x3D; TempNode-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">NNode-&gt;parent &#x3D; PNode;</span><br><span class="line">if (PNode &#x3D;&#x3D; nil) root &#x3D; NNode;</span><br><span class="line">else if (val &lt; PNode-&gt;val) PNode-&gt;left &#x3D; NNode;</span><br><span class="line">else PNode-&gt;right &#x3D; NNode;</span><br><span class="line">NNode-&gt;color&#x3D;RED;&#x2F;&#x2F;记得将插入结点的颜色设为红色</span><br><span class="line">InsertFixup(NNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入的性质修复"><a href="#插入的性质修复" class="headerlink" title="插入的性质修复"></a>插入的性质修复</h2><p>因为插入操作中将插入结点设置为红色，就不会破坏红黑树的最后一条性质，即每个结点到叶结点的简单路径上黑色结点树相同。那么此时若是插入结点的父结点为红色，就会破坏一条红黑树的性质，即红结点的孩子结点都是黑色，只要围绕这条性质来修复即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void RBTree::InsertFixup(RBTreeNode* Node) &#123;</span><br><span class="line">while (Node-&gt;parent-&gt;color &#x3D;&#x3D; RED) &#123;</span><br><span class="line">if (Node-&gt;parent-&gt;parent-&gt;left &#x3D;&#x3D; Node-&gt;parent) &#123;</span><br><span class="line">RBTreeNode* UNode &#x3D; Node-&gt;parent-&gt;parent-&gt;right;</span><br><span class="line">if (UNode-&gt;color &#x3D;&#x3D; RED) &#123;</span><br><span class="line">Node-&gt;parent-&gt;color &#x3D; BLACK;</span><br><span class="line">UNode-&gt;color &#x3D; BLACK;</span><br><span class="line">Node-&gt;parent-&gt;parent &#x3D; RED;</span><br><span class="line">Node &#x3D; Node-&gt;parent-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line">else if (Node &#x3D; Node-&gt;parent-&gt;right) &#123;&#x2F;&#x2F;两个结点弄一边</span><br><span class="line">Node &#x3D; Node-&gt;parent;</span><br><span class="line">RotateLeft(Node);</span><br><span class="line">&#125;</span><br><span class="line">Node-&gt;parent-&gt;color &#x3D; BLACK;</span><br><span class="line">Node-&gt;parent-&gt;parent-&gt;color &#x3D; RED;</span><br><span class="line">RotateRight(Node-&gt;parent-&gt;parent);&#x2F;&#x2F;爷结点右转,带动染黑的父结点上移，维护性质</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">RBTreeNode* UNode &#x3D; Node-&gt;parent-&gt;parent-&gt;left;</span><br><span class="line">if (UNode-&gt;color &#x3D;&#x3D; RED) &#123;</span><br><span class="line">UNode-&gt;color &#x3D; BLACK;</span><br><span class="line">Node-&gt;parent-&gt;color &#x3D; BLACK;</span><br><span class="line">Node-&gt;parent-&gt;parent-&gt;color &#x3D; RED;</span><br><span class="line">Node &#x3D; Node-&gt;parent-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line">else if (Node-&gt;parent-&gt;left &#x3D; Node) &#123;</span><br><span class="line">Node &#x3D; Node-&gt;parent;</span><br><span class="line">RotateRight(Node);</span><br><span class="line">&#125;</span><br><span class="line">Node-&gt;parent-&gt;color &#x3D; BLACK;</span><br><span class="line">Node-&gt;parent-&gt;parent-&gt;color &#x3D; RED;</span><br><span class="line">RotateLeft(Node-&gt;parent-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line">root-&gt;color &#x3D; BLACK;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思想：将破坏性质的红色结点（即插入结点的父结点）层层上移直到根，最后然染黑即可</p><h2 id="移植操作"><a href="#移植操作" class="headerlink" title="移植操作"></a>移植操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void RBTree::Transplant(RBTreeNode* Tree, RBTreeNode* GoneTree, RBTreeNode* NewTree) &#123;</span><br><span class="line">if (GoneTree-&gt;parent &#x3D;&#x3D; nil) </span><br><span class="line">root &#x3D; NewTree;</span><br><span class="line">else if (GoneTree &#x3D;&#x3D; GoneTre                                        e-&gt;parent-&gt;left) </span><br><span class="line">GoneTree-&gt;parent-&gt;left &#x3D; NewTree;</span><br><span class="line">else GoneTree-&gt;parent-&gt;right &#x3D; NewTree;</span><br><span class="line">NewTree-&gt;parent &#x3D; GoneTree-&gt;parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">RBTreeNode* RBTree::DeleteNode(RBTreeNode* root,RBTreeNode* Node) &#123;</span><br><span class="line">RBTreeNode* DNode &#x3D; Node;</span><br><span class="line">RBTreeNode* NNode &#x3D; nil;</span><br><span class="line">RBTreeNode* TempNode &#x3D; nil;</span><br><span class="line">TempNode-&gt;color &#x3D; Node-&gt;color;</span><br><span class="line">if (Node-&gt;left &#x3D;&#x3D; nil) &#123;</span><br><span class="line">NNode &#x3D; Node-&gt;right;</span><br><span class="line">Transplant(root, Node, Node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">else if (Node-&gt;right &#x3D;&#x3D; nil) &#123;</span><br><span class="line">NNode &#x3D; Node-&gt;left;</span><br><span class="line">Transplant(root, Node, Node-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">DNode &#x3D; Minimum(Node-&gt;right);</span><br><span class="line">TempNode-&gt;color &#x3D; DNode-&gt;color;</span><br><span class="line">NNode &#x3D; DNode-&gt;right;</span><br><span class="line">if (DNode-&gt;parent !&#x3D; Node) &#123;</span><br><span class="line">Transplant(root, DNode, DNode-&gt;right);</span><br><span class="line">DNode-&gt;right &#x3D; Node-&gt;right;</span><br><span class="line">Node-&gt;right-&gt;parent &#x3D; DNode;</span><br><span class="line">&#125;</span><br><span class="line">Transplant(root, Node, DNode);</span><br><span class="line">DNode-&gt;left &#x3D; Node-&gt;left;</span><br><span class="line">Node-&gt;left-&gt;parent &#x3D; DNode;</span><br><span class="line">DNode-&gt;color &#x3D; Node-&gt;color;</span><br><span class="line">&#125;</span><br><span class="line">if (TempNode-&gt;color &#x3D;&#x3D; BLACK) DeleteFixup(NNode);</span><br><span class="line">return DNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除操作的性质修复"><a href="#删除操作的性质修复" class="headerlink" title="删除操作的性质修复"></a>删除操作的性质修复</h2><p>赋予破坏红黑树性质的结点双色属性，然后致力于将这种双色属性消除，主要是使得兄弟结点的颜色是黑色，并且其右孩子的颜色是红色，在这种情况下就可以消除掉双色结点的双色属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void RBTree::DeleteFixup(RBTreeNode* Node) &#123;</span><br><span class="line">while (Node !&#x3D; root &amp;&amp; Node-&gt;color &#x3D;&#x3D; BLACK) &#123;</span><br><span class="line">if (Node &#x3D; Node-&gt;parent-&gt;left) &#123;</span><br><span class="line">RBTreeNode* BNode &#x3D; Node-&gt;right;</span><br><span class="line">if (BNode-&gt;color &#x3D;&#x3D; RED) &#123;&#x2F;&#x2F;换个兄弟结点</span><br><span class="line">BNode-&gt;color &#x3D; BLACK;</span><br><span class="line">Node-&gt;parent-&gt;color &#x3D; RED;</span><br><span class="line">RotateLeft(Node-&gt;parent);</span><br><span class="line">BNode &#x3D; Node-&gt;parent-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">if (BNode-&gt;left-&gt;color &#x3D;&#x3D; BLACK &amp;&amp; BNode-&gt;right-&gt;color &#x3D;&#x3D; BLACK) &#123;&#x2F;&#x2F;双色结点上移</span><br><span class="line">BNode-&gt;color &#x3D; RED;</span><br><span class="line">Node &#x3D; Node-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line">else if (BNode-&gt;right-&gt;color &#x3D;&#x3D; BLACK) &#123;</span><br><span class="line">&#x2F;&#x2F;换兄弟，使兄弟为黑，其右孩子为红</span><br><span class="line">BNode-&gt;left-&gt;color &#x3D; BLACK;</span><br><span class="line">BNode-&gt;color &#x3D; RED;</span><br><span class="line">RotateRight(BNode);</span><br><span class="line">BNode &#x3D; Node-&gt;parent-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">BNode-&gt;color &#x3D; Node-&gt;parent-&gt;color;</span><br><span class="line">Node-&gt;parent-&gt;color &#x3D; BLACK;</span><br><span class="line">BNode-&gt;right-&gt;color &#x3D; BLACK;</span><br><span class="line">RotateLeft(Node-&gt;parent);</span><br><span class="line">Node &#x3D; root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">RBTreeNode* BNode &#x3D; Node-&gt;parent-&gt;left;</span><br><span class="line">if (BNode-&gt;color &#x3D; RED) &#123;</span><br><span class="line">BNode-&gt;color &#x3D; BLACK;</span><br><span class="line">Node-&gt;parent-&gt;color &#x3D; RED;</span><br><span class="line">RotateRight(Node-&gt;parent);</span><br><span class="line">BNode &#x3D; Node-&gt;parent-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">else if (BNode-&gt;left-&gt;color &#x3D;&#x3D; BLACK &amp;&amp; BNode-&gt;right-&gt;color &#x3D;&#x3D; BLACK) &#123;</span><br><span class="line">BNode-&gt;color &#x3D; RED;</span><br><span class="line">Node &#x3D; Node-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line">else if (BNode-&gt;left-&gt;color &#x3D;&#x3D; BLACK) &#123;</span><br><span class="line">BNode-&gt;right-&gt;color &#x3D; BLACK;</span><br><span class="line">BNode-&gt;color &#x3D; RED;</span><br><span class="line">RotateLeft(BNode);</span><br><span class="line">BNode &#x3D; Node-&gt;parent-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">BNode-&gt;color &#x3D; Node-&gt;parent-&gt;color;</span><br><span class="line">Node-&gt;parent-&gt;color &#x3D; BLACK;</span><br><span class="line">BNode-&gt;left-&gt;color &#x3D; BLACK;</span><br><span class="line">RotateRight(Node-&gt;parent);</span><br><span class="line">Node &#x3D; root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Node-&gt;color &#x3D; BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;红黑树的性质&quot;&gt;&lt;a href=&quot;#红黑树的性质&quot; class=&quot;headerlink&quot; title=&quot;红黑树的性质&quot;&gt;&lt;/a&gt;红黑树的性质&lt;/h2&gt;&lt;p&gt;每个结点非红即黑，根结点和叶结点为黑色&lt;br&gt;红结点的孩子都是黑结点&lt;br&gt;对每个结点，从该结点到所有后代叶结点的简单路径上，均包含相同数目的黑结点&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法导论" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="http://yoursite.com/articles/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>http://yoursite.com/articles/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2019-12-08T04:08:29.000Z</published>
    <updated>2019-12-16T14:22:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>二叉搜索树的原理无非就是左孩子的值小于等于父节点，右孩子的值大于等于父节点，所有的操作都是围绕这个原理来实现的<br>随机构造一棵二叉搜索树的期望高度为O（lg n），因此二叉搜索树上的动态集合的基本操作平均运行时间为（lg n）</p><a id="more"></a><h2 id="实现（C-）"><a href="#实现（C-）" class="headerlink" title="实现（C++）"></a>实现（C++）</h2><h3 id="结点的结构体定义"><a href="#结点的结构体定义" class="headerlink" title="结点的结构体定义"></a>结点的结构体定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉树的结点的结构体定义</span><br><span class="line">struct treeNode &#123;</span><br><span class="line">int val;</span><br><span class="line">treeNode* left;</span><br><span class="line">treeNode* right;</span><br><span class="line">treeNode* parent;</span><br><span class="line">treeNode(int x) :val(x),left(NULL),right(NULL),parent(NULL)&#123;   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="搜索操作"><a href="#搜索操作" class="headerlink" title="搜索操作"></a>搜索操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉树的搜索操作实现</span><br><span class="line">treeNode* tree_search(treeNode* tree, int x) &#123;</span><br><span class="line">if (tree &#x3D;&#x3D; NULL || tree-&gt;val &#x3D;&#x3D; x)  return tree;</span><br><span class="line">else if (x &lt; tree-&gt;val) return tree_search(tree-&gt;left, x);</span><br><span class="line">else</span><br><span class="line">return tree_search(tree-&gt;right, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找最大-最小结点"><a href="#查找最大-最小结点" class="headerlink" title="查找最大/最小结点"></a>查找最大/最小结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉搜索树的最大&#x2F;最小结点</span><br><span class="line">treeNode* treeMin(treeNode* tree) &#123;</span><br><span class="line">if (tree-&gt;left &#x3D;&#x3D; NULL) return tree;</span><br><span class="line">else return treeMin(tree-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">treeNode* treeMax(treeNode* tree) &#123;</span><br><span class="line">if (tree-&gt;right &#x3D;&#x3D; NULL) return tree;</span><br><span class="line">else return treeMax(tree-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后继结点"><a href="#后继结点" class="headerlink" title="后继结点"></a>后继结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉搜索树的后继结点</span><br><span class="line">treeNode* successor(treeNode* tree) &#123;</span><br><span class="line">if (tree-&gt;right !&#x3D; NULL) return treeMin(tree-&gt;right);</span><br><span class="line">treeNode* y &#x3D; tree-&gt;parent;</span><br><span class="line">while (y !&#x3D; NULL &amp;&amp; y-&gt;left !&#x3D; tree) &#123;</span><br><span class="line">tree &#x3D; y;</span><br><span class="line">y &#x3D; tree-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line">return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前驱结点"><a href="#前驱结点" class="headerlink" title="前驱结点"></a>前驱结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉搜索树的前驱结点</span><br><span class="line">treeNode* predecessor(treeNode* tree) &#123;</span><br><span class="line">if (tree-&gt;left !&#x3D; NULL) return treeMax(tree-&gt;left);</span><br><span class="line">treeNode* y &#x3D; tree-&gt;parent;</span><br><span class="line">while (y !&#x3D; NULL &amp;&amp; y-&gt;right !&#x3D; tree) &#123;</span><br><span class="line">tree &#x3D; y;</span><br><span class="line">y &#x3D; tree-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line">return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉树的结点插入操作实现</span><br><span class="line">treeNode* insert(treeNode* tree, treeNode* node) &#123;</span><br><span class="line">treeNode* y &#x3D; NULL;&#x2F;&#x2F;y作为插入结点的父结点</span><br><span class="line">treeNode* x &#x3D; tree;&#x2F;&#x2F;x为插入结点的位置</span><br><span class="line">while (x !&#x3D; NULL) &#123;</span><br><span class="line">y &#x3D; x;</span><br><span class="line">if (node-&gt;val &lt; x-&gt;val) x &#x3D; x-&gt;left;</span><br><span class="line">else x &#x3D; x-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">node-&gt;parent &#x3D; y;</span><br><span class="line">if (y &#x3D;&#x3D; NULL) tree &#x3D; node;</span><br><span class="line">else if (node-&gt;val &lt; y-&gt;val) y-&gt;left &#x3D; node;</span><br><span class="line">else y-&gt;right &#x3D; node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移植操作"><a href="#移植操作" class="headerlink" title="移植操作"></a>移植操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉树删除操作中使用的移植操作实现</span><br><span class="line">void transplant(treeNode* tree, treeNode* u, treeNode* v) &#123;</span><br><span class="line">if (u-&gt;parent &#x3D;&#x3D; NULL) tree &#x3D; v;</span><br><span class="line">else if (u-&gt;parent-&gt;left &#x3D;&#x3D; u) u-&gt;parent-&gt;left &#x3D; v;</span><br><span class="line">else u-&gt;parent-&gt;right &#x3D; v;&#x2F;&#x2F;切断原来的父结点与要被替换的树的联系</span><br><span class="line">if (v !&#x3D; NULL) v-&gt;parent &#x3D; u-&gt;parent;&#x2F;&#x2F;最后才将新的树与其父节点连接</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;二叉搜索树的删除操作</span><br><span class="line">void treeDelete(treeNode* tree, treeNode* node) &#123;</span><br><span class="line">if (node-&gt;left &#x3D;&#x3D; NULL) transplant(tree,node, node-&gt;right);</span><br><span class="line">else if (node-&gt;right &#x3D;&#x3D; NULL) transplant(tree,node, node-&gt;left);</span><br><span class="line">else &#123;</span><br><span class="line">treeNode* y &#x3D; treeMin(node-&gt;right);</span><br><span class="line">if (y-&gt;parent !&#x3D; node) &#123;&#x2F;&#x2F;y不是删除结点的孩子时</span><br><span class="line">transplant(tree, y, y-&gt;right);&#x2F;&#x2F;先将y独立，用其右孩子将其移植</span><br><span class="line">y-&gt;right &#x3D; node-&gt;right;</span><br><span class="line">y-&gt;right-&gt;parent &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line">transplant(tree, node, y);</span><br><span class="line">y-&gt;left &#x3D; node-&gt;left;&#x2F;&#x2F;左孩子的拼接</span><br><span class="line">y-&gt;left-&gt;parent &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;二叉搜索树的原理无非就是左孩子的值小于等于父节点，右孩子的值大于等于父节点，所有的操作都是围绕这个原理来实现的&lt;br&gt;随机构造一棵二叉搜索树的期望高度为O（lg n），因此二叉搜索树上的动态集合的基本操作平均运行时间为（lg n）&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法导论" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/%E6%A0%91/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 19(下)</title>
    <link href="http://yoursite.com/articles/C++%20Primer%2019(%E4%B8%8B).html"/>
    <id>http://yoursite.com/articles/C++%20Primer%2019(%E4%B8%8B).html</id>
    <published>2019-12-05T06:59:13.000Z</published>
    <updated>2019-12-09T06:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="成员指针"><a href="#成员指针" class="headerlink" title="成员指针"></a>成员指针</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义</span><br><span class="line">auto pdata&#x3D;&amp;Screen::contents;</span><br><span class="line">&#x2F;&#x2F;解引用</span><br><span class="line">auto s&#x3D;myScreen.*pdata;</span><br><span class="line">s&#x3D;pScreen-&gt;*pdata;</span><br><span class="line">&#x2F;&#x2F;指向const限定的成员函数</span><br><span class="line">char(Screen::*pmf2)(Screen::pos,Screen::pos)const;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="使用指针"><a href="#使用指针" class="headerlink" title="使用指针"></a>使用指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char c1&#x3D;(my.Screen.*pmf1)(0,0);</span><br><span class="line">char c2&#x3D;(pScreen-&gt;*pmf2)();</span><br></pre></td></tr></table></figure><h3 id="使用类型别名"><a href="#使用类型别名" class="headerlink" title="使用类型别名"></a>使用类型别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using Action&#x3D;char(Screen::*)(Screen::pos,Screen::pos)const;</span><br><span class="line">Action get&#x3D;&amp;Screen::get;</span><br></pre></td></tr></table></figure><p>当成员函数指针用于形参的时候可以指定默认实参</p><h3 id="使用函数表"><a href="#使用函数表" class="headerlink" title="使用函数表"></a>使用函数表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum Directions&#123;-------&#125;;</span><br><span class="line">Screen&amp; move(Directions);</span><br><span class="line">static Action Menu[];</span><br><span class="line">Screen&amp; Screen::move(Directions cm)&#123;</span><br><span class="line">return (this-&gt;*Menu[cm])();</span><br><span class="line">&#125;</span><br><span class="line">Screen::Action Screen::Menu[]&#x3D;&#123;----------&#125;;</span><br></pre></td></tr></table></figure><h3 id="成员指针与可调用对象"><a href="#成员指针与可调用对象" class="headerlink" title="成员指针与可调用对象"></a>成员指针与可调用对象</h3><p>成员指针不是可调用对象，不能将其传递给算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用function获取可调用对象</span><br><span class="line">function&lt;bool(const string&amp;)&gt;fcn&#x3D;&amp;string::empty;</span><br></pre></td></tr></table></figure><h3 id="使用mem-fn"><a href="#使用mem-fn" class="headerlink" title="使用mem_fn"></a>使用mem_fn</h3><p>定义在function头文件中，接受一个成员指针生成一个可调用对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find_if(vec.begin(),vec.end(),mem_fn(&amp;string::empty));</span><br><span class="line">&#x2F;&#x2F;生成的可调用对象可以接受string对象，string指针&#x2F;地址</span><br></pre></td></tr></table></figure><h3 id="使用bind"><a href="#使用bind" class="headerlink" title="使用bind"></a>使用bind</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_if(vec.begin(),vec.end(),bind(&amp;string::empty,_1))</span><br></pre></td></tr></table></figure><h2 id="union类"><a href="#union类" class="headerlink" title="union类"></a>union类</h2><p>节省空间的类，在任意时刻只有一个数据成员可以有值，不能含有引用类型的成员，默认情况下，它的成员是public的，它不能继承自其他类，也不能作为基类使用，所以不能含有虚函数<br>匿名union的成员在本作用域可以直接访问，但不能包含protected和private成员，也不能定义成员函数<br>如果union含有定义了默认构造函数或拷贝控制成员，则编译器会为union合成对应的版本并声明为删除的<br>含有类类型的union常声明在类内，此时可以用enum在类内定义一个判别式，来追踪union的成员</p><h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><p>定义在函数内部，它的成员必须完整地定义在类的内部，所以不允许为它定义静态数据成员，并且它不能使用本作用域的普通变量，而本作用域对它的私有成员也没有访问权限<br>当局部类中有嵌套类时，嵌套类的定义可以在局部类的外部，但是必须在本作用域中</p><h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>类可以将其非静态数据成员定义成位域，通常用于程序需要向其他程序或硬件设备传递二进制数据时，通常用无符号类型保存一个位域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">unsigned mode:2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类的内部连续定义的位域压缩在同一个整数的相邻位，从而压缩存储<br>取地址符不能作用于位域，任何指针都无法指向类的位域</p><h2 id="volatile限定符"><a href="#volatile限定符" class="headerlink" title="volatile限定符"></a>volatile限定符</h2><p>表示对象的值可能程序的控制或检测之外改变，作用与const相似，区别在于类的拷贝控制成员对volatile对象无效，比如拷贝构造函数的形参是常量引用（非volatile），明显不能将一个非volatile形参绑定到一个volatile对象，此时需要自定义拷贝控制成员</p><h2 id="链接指示：extern-“C”"><a href="#链接指示：extern-“C”" class="headerlink" title="链接指示：extern “C”"></a>链接指示：extern “C”</h2><p>调用其他语言编写的函数时用，指出任意非C++函数所用的语言<br>链接指示可以嵌套</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接指示对整个声明都有效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; void f(void(*)(int));</span><br><span class="line">&#x2F;&#x2F;形参是一个指向C函数的指针</span><br></pre></td></tr></table></figure><p>如果我们希望给C++函数传入一个指向C函数的指针，可以使用类型别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; typedef void FC(int);</span><br><span class="line">void f2(FC*);</span><br></pre></td></tr></table></figure><p>导出C++函数到其他语言</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; double calc(double bd)&#123;------&#125;</span><br><span class="line">&#x2F;&#x2F;该函数可被C程序调用</span><br></pre></td></tr></table></figure><p>在C和C++中编译头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;预处理器定义了_ _cplusplus</span><br><span class="line">#ifdef _ _cpluscplus</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">#endif</span><br><span class="line">int strcmp(const char*,const char*);</span><br></pre></td></tr></table></figure><p>C语言不支持函数重载，所以一个C链接指示只能说明一组重载函数中的一个</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;成员指针&quot;&gt;&lt;a href=&quot;#成员指针&quot; class=&quot;headerlink&quot; title=&quot;成员指针&quot;&gt;&lt;/a&gt;成员指针&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;定义&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;auto pdata&amp;#x3D;&amp;amp;Screen::contents;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;解引用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;auto s&amp;#x3D;myScreen.*pdata;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s&amp;#x3D;pScreen-&amp;gt;*pdata;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;指向const限定的成员函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char(Screen::*pmf2)(Screen::pos,Screen::pos)const;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="语言" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 19(上)</title>
    <link href="http://yoursite.com/articles/C++%20Primer%2019(%E4%B8%8A).html"/>
    <id>http://yoursite.com/articles/C++%20Primer%2019(%E4%B8%8A).html</id>
    <published>2019-12-05T02:02:39.000Z</published>
    <updated>2019-12-05T06:41:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="控制内存分配"><a href="#控制内存分配" class="headerlink" title="控制内存分配"></a>控制内存分配</h2><h3 id="定义new-delete"><a href="#定义new-delete" class="headerlink" title="定义new/delete"></a>定义new/delete</h3><p>全局作用域或类作用域<br>当定义为类的成员时，是隐式static的，无须显式声明</p><p>当将delete定义为类的成员时，可以包含第二个size_t的形参，它是第一个指针形参所指对象的字节数，此也可以用于继承体系中的对象，由动态类型决定字节数</p><a id="more"></a><p>new的第一个形参必须是size_t，并且不能有默认实参，传入的是对象字节数或所有元素所需的空间</p><p>不能重载<code>void *operator new(size_t,void*);</code></p><h3 id="new-delete的查找"><a href="#new-delete的查找" class="headerlink" title="new/delete的查找"></a>new/delete的查找</h3><p>如果被分配/释放的是类类型，则编译器首先在类及其基类的作用域中查找，然后才在全局中查找</p><h3 id="不抛出异常"><a href="#不抛出异常" class="headerlink" title="不抛出异常"></a>不抛出异常</h3><p>类型nothrow_t是new头文件中的一个struct，在这个类型中不包含任何成员，new头文件中还有一个nothrow的const对象，用户通过这个对象请求new的非抛出版本<br>析构函数和delete都不允许抛出异常<br>当重载delete的时候，必须使用noexcept指定其不抛出异常</p><h3 id="使用malloc和free"><a href="#使用malloc和free" class="headerlink" title="使用malloc和free"></a>使用malloc和free</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void *operator new(size_t size)&#123;</span><br><span class="line">if(void *mem&#x3D;malloc(size))</span><br><span class="line">return mem;</span><br><span class="line">else</span><br><span class="line">throw bad_alloc();</span><br><span class="line">&#125;</span><br><span class="line">void operator delete(void *mem)noexcept&#123;</span><br><span class="line">free(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用定位new"><a href="#使用定位new" class="headerlink" title="使用定位new"></a>使用定位new</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new(place_address)type[size]&#123;initializer_list&#125;;</span><br></pre></td></tr></table></figure><p>当仅通过一个地址调用时，使用<code>operator new(size_t,void *)</code>，这个函数不分配任何内存，只是简单返回指针实参，然后在该地址初始化对象</p><h3 id="construct与定位new"><a href="#construct与定位new" class="headerlink" title="construct与定位new"></a>construct与定位new</h3><p>传给construct的指针必须指向同一个allocator对象分配的空间<br>传给定位new的则不用，甚至不用指向动态内存</p><h3 id="指针调用析构函数"><a href="#指针调用析构函数" class="headerlink" title="指针调用析构函数"></a>指针调用析构函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *sp&#x3D;new string(&quot;a value&quot;);</span><br><span class="line">sp-&gt;~string();</span><br></pre></td></tr></table></figure><p>清除给定的对象，但不会释放内存空间，可以重新使用该空间</p><h2 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h2><h3 id="使用dynamic-cast"><a href="#使用dynamic-cast" class="headerlink" title="使用dynamic_cast"></a>使用dynamic_cast</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;转换目标为指针类型</span><br><span class="line">if(Derived *dp&#x3D;dynamic_cast&lt;Derived *&gt;(bp))&#123;</span><br><span class="line">------</span><br><span class="line">&#125;else&#123;----&#125;</span><br></pre></td></tr></table></figure><p>如果转换失败结果为0<br>可以对一个空指针执行该操作，结果是所需类型的空指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;转换目标为引用类型</span><br><span class="line">void f(const Base &amp;b)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">const Derived &amp;d&#x3D;dynamic_cast&lt;const Derived&amp;&gt;(b);</span><br><span class="line">&#125;catch(bad_cast)&#123;</span><br><span class="line">------</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果转换失败抛出std::bad_cast，该异常在typeinfo中</p><h3 id="使用typeid"><a href="#使用typeid" class="headerlink" title="使用typeid"></a>使用typeid</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(typeid(*bp)&#x3D;&#x3D;typeid(Derived))&#123;</span><br><span class="line">---------</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实参是对象，而不是指针<br>作用于数组和函数时不会执行到指针的转换<br>当运算对象是带有虚函数的类时，编译器才会在运行时对表达式进行求值，此时指针必须是有效指针，空指针的话会抛出bad_typeid异常<br>其他情况不会对表达式进行求值，直接返回静态类型</p><h3 id="type-info类"><a href="#type-info类" class="headerlink" title="type_info类"></a>type_info类</h3><p>定义在typeinfo头文件中<br>操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1&#x3D;t2t1!&#x3D;t2</span><br><span class="line">t.name()t1.before(t2)&#x2F;&#x2F;返回bool</span><br></pre></td></tr></table></figure><p>没有默认构造函数，type_info类的拷贝、移动、赋值函数都被定义成删除的，只能通过typeid创建它的对象</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum color&#123;red,yellow,green&#125;;&#x2F;&#x2F;不限定作用域</span><br><span class="line">enum class peppers&#123;red,yellow,green&#125;&#x2F;&#x2F;限定作用域</span><br><span class="line">color eyes&#x3D;green;</span><br><span class="line">peppers p&#x3D;peppers::red;</span><br></pre></td></tr></table></figure><p>默认情况下，枚举值从0开始，依次加1<br>可以定义枚举类型的constexpr变量<br>可以作为case标签，也能将枚举类型作为非类型模板形参，还能在类的定义中初始化枚举类型的静态数据成员<br>只能用该类型的一个枚举成员或者另一个对象来赋值</p><h3 id="指定enum的大小"><a href="#指定enum的大小" class="headerlink" title="指定enum的大小"></a>指定enum的大小</h3><p>不限定作用域的枚举类型的对象或枚举成员会自动隐式转换为int，而限定作用域的枚举类型不会进行这样的隐式转换<br>不限定作用域的枚举类型，它的枚举成员不存在默认类型，我们指定潜在类型时要注意，枚举成员的值必须在指定的类型取值范围内，不然就会出错<br>而限定作用域默认情况下是int</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum a:unsigned long long&#123;</span><br><span class="line">-------</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h3><p>前置声明必须与它的定义一致，无论是作用域是否限定还是指定的潜在类型，不然就会报错</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;控制内存分配&quot;&gt;&lt;a href=&quot;#控制内存分配&quot; class=&quot;headerlink&quot; title=&quot;控制内存分配&quot;&gt;&lt;/a&gt;控制内存分配&lt;/h2&gt;&lt;h3 id=&quot;定义new-delete&quot;&gt;&lt;a href=&quot;#定义new-delete&quot; class=&quot;headerlink&quot; title=&quot;定义new/delete&quot;&gt;&lt;/a&gt;定义new/delete&lt;/h3&gt;&lt;p&gt;全局作用域或类作用域&lt;br&gt;当定义为类的成员时，是隐式static的，无须显式声明&lt;/p&gt;
&lt;p&gt;当将delete定义为类的成员时，可以包含第二个size_t的形参，它是第一个指针形参所指对象的字节数，此也可以用于继承体系中的对象，由动态类型决定字节数&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="语言" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 18(下)</title>
    <link href="http://yoursite.com/articles/C++%20Primer%2018(%E4%B8%8B).html"/>
    <id>http://yoursite.com/articles/C++%20Primer%2018(%E4%B8%8B).html</id>
    <published>2019-12-04T04:22:55.000Z</published>
    <updated>2019-12-09T06:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><h3 id="新建命名空间"><a href="#新建命名空间" class="headerlink" title="新建命名空间"></a>新建命名空间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">namespace x&#123;</span><br><span class="line">------</span><br><span class="line">&#125;&#x2F;&#x2F;不需要分号</span><br></pre></td></tr></table></figure><p>不能定义在函数或类的内部<br>命名空间成员的定义可以在外部，但是必须在所属命名空间的外层命名空间中</p><a id="more"></a><h3 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h3><p>模板特例化必须定义在原始模板所属的命名空间中，只要在该命名空间中声明了特例化，就可以在外部定义它了</p><h3 id="内联命名空间"><a href="#内联命名空间" class="headerlink" title="内联命名空间"></a>内联命名空间</h3><p>可以直接被外层命名空间使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline namespace x&#123;--------&#125;</span><br></pre></td></tr></table></figure><p>inline必须出现在第一次定义的时候，后续打开可不写</p><h3 id="未命名的命名空间"><a href="#未命名的命名空间" class="headerlink" title="未命名的命名空间"></a>未命名的命名空间</h3><p>静态生命周期，第一次使用前创建，直到程序结束销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace &#123;--------&#125;</span><br></pre></td></tr></table></figure><p>不能跨越多个文件，一个包含了未命名的命名空间的头文件被多个文件使用时，在这多个文件里的名字将对应不同的实体<br>它的名字可以直接使用，因此当处于最外层作用域时，它里面的名字要区分于全局作用域中的名字</p><h3 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a>using 声明</h3><p>一次引入一个命名空间的一个成员名字<br>当它出现在类的作用域中时，这个声明只能指向基类成员</p><h3 id="using-指示"><a href="#using-指示" class="headerlink" title="using 指示"></a>using 指示</h3><p>一次引入一个命名空间所有名字，可以说是将名字都注入到外层作用域中，using指示不能出现在类的作用域中</p><h3 id="头文件与using"><a href="#头文件与using" class="headerlink" title="头文件与using"></a>头文件与using</h3><p>头文件应该只负责定义接口的名字，所以只能在它的函数或命名空间内使用using声明和指示</p><h3 id="实参查找与类类型形参"><a href="#实参查找与类类型形参" class="headerlink" title="实参查找与类类型形参"></a>实参查找与类类型形参</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator&gt;&gt;(std::cin,s);</span><br></pre></td></tr></table></figure><p>当编译器发现&gt;&gt;时，首先在当前作用域查找，然后在外层作用域查找，最后由于&gt;&gt;的形参是类类型的，所以编译器还会在cin和s的类所属的命名空间查找</p><h3 id="实参查找与友元"><a href="#实参查找与友元" class="headerlink" title="实参查找与友元"></a>实参查找与友元</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">namespace A&#123;</span><br><span class="line">class C&#123;</span><br><span class="line">&#x2F;&#x2F;隐式成为命名空间A的成员</span><br><span class="line">friend void f2();</span><br><span class="line">friend void f(const C&amp;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">A::C cobj;</span><br><span class="line">f(cobj);&#x2F;&#x2F;正确，通过形参C找到A的命名空间</span><br><span class="line">f2();&#x2F;&#x2F;错误，找不到它的声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用using"><a href="#使用using" class="headerlink" title="使用using"></a>使用using</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using NS::print(int);</span><br><span class="line">using NS::print;</span><br></pre></td></tr></table></figure><p>using声明会引入函数到本作用域<br>如果using声明引入一个同名同参的函数，会报错<br>而using指示不会<br>using指示是将命名空间的成员提升到外层作用域</p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><h3 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">using Base1::Base1;</span><br><span class="line">using Base2::Base2;</span><br></pre></td></tr></table></figure><p>如果继承了相同形参列表的构造函数，会报错，这时我们需要为该形参再自己定义一个构造函数，既然定义了构造函数，那么这个时候最好也定义一个默认构造函数</p><h3 id="派生类的控制成员"><a href="#派生类的控制成员" class="headerlink" title="派生类的控制成员"></a>派生类的控制成员</h3><p>如果定义了自己的拷贝/赋值构造函数和赋值运算符，必须在完整的对象上执行拷贝、移动、赋值操作<br>如果使用的是合成的，就会对其基类部分执行这些操作</p><h3 id="静态类型与操作"><a href="#静态类型与操作" class="headerlink" title="静态类型与操作"></a>静态类型与操作</h3><p>对象、指针和引用的静态类型决定能够使用哪些成员，例如一个指向基类的指针，只能使用基类部分的成员</p><h3 id="多重继承的二义性调用"><a href="#多重继承的二义性调用" class="headerlink" title="多重继承的二义性调用"></a>多重继承的二义性调用</h3><p>当从多个基类继承了同名函数时，调用需要指明哪个作用域下的函数，不然就会出现二义性错误，也可以再本作用域下再定义一个同名函数</p><h3 id="使用虚继承"><a href="#使用虚继承" class="headerlink" title="使用虚继承"></a>使用虚继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Bear:virtual public zoo&#123;------&#125;;</span><br></pre></td></tr></table></figure><p>派生类中只有虚继承的类一个实例</p><h3 id="虚基类的构造"><a href="#虚基类的构造" class="headerlink" title="虚基类的构造"></a>虚基类的构造</h3><p>虚基类是由最低层的派生类初始化的，如果有多个虚基类，则按照在派生列表中中出现的顺序初始化，然后才按顺序初始化其他基类<br>析构顺序与构造顺序相反</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;命名空间&quot;&gt;&lt;a href=&quot;#命名空间&quot; class=&quot;headerlink&quot; title=&quot;命名空间&quot;&gt;&lt;/a&gt;命名空间&lt;/h2&gt;&lt;h3 id=&quot;新建命名空间&quot;&gt;&lt;a href=&quot;#新建命名空间&quot; class=&quot;headerlink&quot; title=&quot;新建命名空间&quot;&gt;&lt;/a&gt;新建命名空间&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;namespace x&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;	&amp;#x2F;&amp;#x2F;不需要分号&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不能定义在函数或类的内部&lt;br&gt;命名空间成员的定义可以在外部，但是必须在所属命名空间的外层命名空间中&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="语言" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 18(上)</title>
    <link href="http://yoursite.com/articles/C++%20Primer%2018(%E4%B8%8A).html"/>
    <id>http://yoursite.com/articles/C++%20Primer%2018(%E4%B8%8A).html</id>
    <published>2019-12-04T04:22:55.000Z</published>
    <updated>2019-12-04T08:28:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="栈展开"><a href="#栈展开" class="headerlink" title="栈展开"></a>栈展开</h3><p>异常发生在try语句块内–&gt;在跟自己的try语句块关联的catch里找<br>若该try语句块嵌套在另一个try内–&gt;继续在外面的这个try语句块找<br>若该函数被调用–&gt;在调用它的函数找<br>若是找到catch，则在与原来try语句块关联的最后一个catch后的点继续执行程序<br>最后找不到就会调用标准库函数terminate强行终止程序</p><a id="more"></a><h3 id="析构函数与异常"><a href="#析构函数与异常" class="headerlink" title="析构函数与异常"></a>析构函数与异常</h3><p>栈展开可能使用析构函数–&gt;如果析构函数需要执行某个可能抛出异常的操作，这个操作应该在析构函数内部得到处理<br>因为如果最后没有捕获到catch，就会调用terminate，此前分配的资源就无法被释放，所以这个可能抛出异常的操作就应该在析构函数内部就得到处理</p><h3 id="异常对象"><a href="#异常对象" class="headerlink" title="异常对象"></a>异常对象</h3><p>位于编译器管理的空间，由异常抛出表达式拷贝初始化，该表达式的静态编译时类型决定了异常对象的类型，如果一条throw表达式解引用了一个指向基类的指针，而该指针实际指向的是派生类对象，则抛出的对象被切掉一部分，只有基类部分被抛出（不要指向局部对象）</p><h3 id="catch的异常声明"><a href="#catch的异常声明" class="headerlink" title="catch的异常声明"></a>catch的异常声明</h3><p>异常声明必须是完全类型，可以是左值引用，不能是右值引用<br>如果是基类的非引用类型，用派生类对象初始化时会切掉一部分<br>如果是基类的引用类型，以常规方式绑定异常对象，catch无法使用派生类特有的成员<br>异常声明用数组或函数初始化时，会转换为指针</p><h3 id="重新抛出"><a href="#重新抛出" class="headerlink" title="重新抛出"></a>重新抛出</h3><p>catch处理了一部分异常，重新抛出，将异常对象沿着调用链向上传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw;</span><br></pre></td></tr></table></figure><p>如果空throw出现在处理代码之外的区域，编译器j将调用terminate<br>只有当catch异常声明是引用类型时我们对参数作的改变才会被保留并继续传播</p><h3 id="处理所有异常"><a href="#处理所有异常" class="headerlink" title="处理所有异常"></a>处理所有异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch(...)</span><br></pre></td></tr></table></figure><p>通常与重新抛出一起使用</p><h3 id="函数测试块"><a href="#函数测试块" class="headerlink" title="函数测试块"></a>函数测试块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob(std::initializer_list&lt;T&gt; il) try:</span><br><span class="line">data(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il)&#123;</span><br><span class="line">&#125;catch(const std::bad_alloc &amp;e)&#123;--------&#125;</span><br></pre></td></tr></table></figure><h3 id="不抛出声明"><a href="#不抛出声明" class="headerlink" title="不抛出声明"></a>不抛出声明</h3><p>noexcept在声明和定义中同时出现，也在尾置返回类型之前<br>在类型别名中不能出现noexcept<br>在成员函数中，noexcept在const和引用限定符之后，final，override或虚函数的=0之前</p><p>异常说明的实参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void func1(int a)noexcept(true)&#x2F;&#x2F;不会抛出异常</span><br><span class="line">void func2(int b)noexcept(false)&#x2F;&#x2F;可能抛出异常</span><br></pre></td></tr></table></figure><h3 id="noexcept-运算符"><a href="#noexcept-运算符" class="headerlink" title="noexcept 运算符"></a>noexcept 运算符</h3><p>返回bool类型的右值常量表达式，不会求其运算对象的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void f()noexcept (noexcept(g()));</span><br></pre></td></tr></table></figure><h3 id="一致的异常说明"><a href="#一致的异常说明" class="headerlink" title="一致的异常说明"></a>一致的异常说明</h3><p>函数指针和指针指向的函数<br>虚函数和它的派生函数<br>合成拷贝控制成员时</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;异常处理&quot;&gt;&lt;a href=&quot;#异常处理&quot; class=&quot;headerlink&quot; title=&quot;异常处理&quot;&gt;&lt;/a&gt;异常处理&lt;/h2&gt;&lt;h3 id=&quot;栈展开&quot;&gt;&lt;a href=&quot;#栈展开&quot; class=&quot;headerlink&quot; title=&quot;栈展开&quot;&gt;&lt;/a&gt;栈展开&lt;/h3&gt;&lt;p&gt;异常发生在try语句块内–&amp;gt;在跟自己的try语句块关联的catch里找&lt;br&gt;若该try语句块嵌套在另一个try内–&amp;gt;继续在外面的这个try语句块找&lt;br&gt;若该函数被调用–&amp;gt;在调用它的函数找&lt;br&gt;若是找到catch，则在与原来try语句块关联的最后一个catch后的点继续执行程序&lt;br&gt;最后找不到就会调用标准库函数terminate强行终止程序&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="语言" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 17(下)</title>
    <link href="http://yoursite.com/articles/C++%20Primer%2017(%E4%B8%8B).html"/>
    <id>http://yoursite.com/articles/C++%20Primer%2017(%E4%B8%8B).html</id>
    <published>2019-12-04T00:51:53.000Z</published>
    <updated>2019-12-10T12:51:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><h3 id="随机数引擎类"><a href="#随机数引擎类" class="headerlink" title="随机数引擎类"></a>随机数引擎类</h3><p>函数对象类，定义了调用运算符，不接受参数并返回一个随机数unsigned整数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e;</span><br><span class="line">for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">cout&lt;&lt;e()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="随机数引擎操作"><a href="#随机数引擎操作" class="headerlink" title="随机数引擎操作"></a>随机数引擎操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Engine e(s)&#x2F;&#x2F;使用整型值s作为种子</span><br><span class="line">e.seed(s)&#x2F;&#x2F;使用种子s重置引擎的状态</span><br><span class="line">&#x2F;&#x2F;使用相同种子的引擎将生成相同的序列</span><br><span class="line">e.min()e.max()</span><br><span class="line">Engine::result_type&#x2F;&#x2F;此引擎可生成的值类型</span><br><span class="line">e.discard(ull)&#x2F;&#x2F;将引擎推进Ull步，这个值是unsigned long long</span><br></pre></td></tr></table></figure><h3 id="使用分布类"><a href="#使用分布类" class="headerlink" title="使用分布类"></a>使用分布类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uniform_int_distribution&lt;unsigned&gt; u(0,9);</span><br><span class="line">default_random_engine e;</span><br><span class="line">u(e);</span><br></pre></td></tr></table></figure><p>对于一个给定的随机数发生器，每次运行程序它都会返回相同的数值序列，可以通过将e和u定义为static，然后就可以在函数调用中保持状态</p><h3 id="使用系统函数time"><a href="#使用系统函数time" class="headerlink" title="使用系统函数time"></a>使用系统函数time</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义在ctime头文件中，返回从一个特定时刻到当前经过了多少秒</span><br><span class="line">&#x2F;&#x2F;函数time接受单个指针参数，指向用于写入时间的数据结构</span><br><span class="line">&#x2F;&#x2F;如果此指针为空，则简单地返回时间</span><br><span class="line">default_random_engine e(time(0));</span><br><span class="line">&#x2F;&#x2F;如果程序作为自动过程的一部分，则种子不变</span><br></pre></td></tr></table></figure><h3 id="生成随机实数"><a href="#生成随机实数" class="headerlink" title="生成随机实数"></a>生成随机实数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uniform_real_distribution&lt;double&gt; u(0,1);</span><br><span class="line">uniform_real_distribution&lt;&gt;u(0,1);&#x2F;&#x2F;默认生成double类型</span><br><span class="line">u(e);</span><br></pre></td></tr></table></figure><h3 id="分布类型的操作"><a href="#分布类型的操作" class="headerlink" title="分布类型的操作"></a>分布类型的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.min()d.max()</span><br><span class="line">d.reset();&#x2F;&#x2F;重建d的状态，使得随后对d的使用不依赖于d已经生成的值</span><br></pre></td></tr></table></figure><h3 id="生成非均匀分布的随机数"><a href="#生成非均匀分布的随机数" class="headerlink" title="生成非均匀分布的随机数"></a>生成非均匀分布的随机数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">normal_distribution&lt;&gt; n(4,1.5);</span><br><span class="line">n(e);</span><br></pre></td></tr></table></figure><h3 id="使用lround函数"><a href="#使用lround函数" class="headerlink" title="使用lround函数"></a>使用lround函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;定义在cmath中</span><br><span class="line">unsigned v&#x3D;lround(n(e));</span><br></pre></td></tr></table></figure><h3 id="bernoulli-distribution类"><a href="#bernoulli-distribution类" class="headerlink" title="bernoulli_distribution类"></a>bernoulli_distribution类</h3><p>不接受模板参数，返回bool值，概率默认0.5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bernoulli_distributionb;&#x2F;&#x2F;默认true概率0.5</span><br><span class="line">bernoulli_distribution  b(.55)&#x2F;&#x2F;true为0.55</span><br></pre></td></tr></table></figure><h2 id="IO库再探"><a href="#IO库再探" class="headerlink" title="IO库再探"></a>IO库再探</h2><h3 id="操纵符"><a href="#操纵符" class="headerlink" title="操纵符"></a>操纵符</h3><p>函数或对象，影响流的状态，返回处理的流对象<br>用于控制数值的输出以及控制补白的数量和位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">boolalphanoboolalphashowbase noshowbase</span><br><span class="line">showpoint noshowpoint showpos noshowpos</span><br><span class="line">uppercase nouppercasedechex oct</span><br><span class="line">leftrightinternal&#x2F;&#x2F;在值的左右&#x2F;符号和值之间填充字符</span><br><span class="line">fixedscientifichexfloatdefaultfloat</span><br><span class="line">unitbufnounitbufskipwsnoskipws</span><br><span class="line">flushendsendl;</span><br><span class="line">setfill(ch)setprecision(ch)setw(w)setbase(b)</span><br></pre></td></tr></table></figure><p>默认情况下，输入运算符会忽略空白符</p><h3 id="单字节操作"><a href="#单字节操作" class="headerlink" title="单字节操作"></a>单字节操作</h3><p>单字节底层IO操作会读取而不是忽略空白符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">is.get(ch)</span><br><span class="line">is.get()&#x2F;&#x2F;返回int</span><br><span class="line">os.put(ch)</span><br><span class="line">is.putback(ch)is.unget()</span><br><span class="line">is.peek();&#x2F;&#x2F;返回Int</span><br></pre></td></tr></table></figure><p>返回int是因为这样可以返回文件尾标记<br>标准库用负值表示文件尾<br>头文件cstdio定义了EOF，这是一个const</p><h3 id="多字节底层操作"><a href="#多字节底层操作" class="headerlink" title="多字节底层操作"></a>多字节底层操作</h3><p>自己分配并管理用来保存和提取数据的字符数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">is.get(sink,size,delim)</span><br><span class="line">is.getline(sink,size,delim)</span><br><span class="line">is.read(sink.size)</span><br><span class="line">is.gcount()&#x2F;&#x2F;从上一个操作读取的字节数</span><br><span class="line">os.write(source,size)</span><br><span class="line">is.isgnore(size,delim)&#x2F;&#x2F;size默认1，delim默认EOF</span><br></pre></td></tr></table></figure><h3 id="流的随机访问"><a href="#流的随机访问" class="headerlink" title="流的随机访问"></a>流的随机访问</h3><p>只用于sstream和fstream</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tellg()tellp()</span><br><span class="line">seekg(pos)seekp(pos)&#x2F;&#x2F;将标记定位到绝对地址</span><br><span class="line">seekg(off,from)seekp(off,from)</span><br><span class="line">&#x2F;&#x2F;from是stream::beg&#x2F;cur&#x2F;end</span><br></pre></td></tr></table></figure><p>标记只有一个，表示缓冲区中的当前位置，标准库将p和g版本的读写位置都映射到这个单一的标记，在读写操作间切换时，就必须进行seek进行重定位标记</p><p>pos的类型是pos_type<br>off的类型是off_type        //可以是负的<br>它们定义在头文件istream和ostream中</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;随机数&quot;&gt;&lt;a href=&quot;#随机数&quot; class=&quot;headerlink&quot; title=&quot;随机数&quot;&gt;&lt;/a&gt;随机数&lt;/h2&gt;&lt;h3 id=&quot;随机数引擎类&quot;&gt;&lt;a href=&quot;#随机数引擎类&quot; class=&quot;headerlink&quot; title=&quot;随机数引擎类&quot;&gt;&lt;/a&gt;随机数引擎类&lt;/h3&gt;&lt;p&gt;函数对象类，定义了调用运算符，不接受参数并返回一个随机数unsigned整数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;default_random_engine e;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int i&amp;#x3D;0;i&amp;lt;10;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout&amp;lt;&amp;lt;e()&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="语言" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer 17(上）</title>
    <link href="http://yoursite.com/articles/C++%20Primer%2017(%E4%B8%8A%EF%BC%89.html"/>
    <id>http://yoursite.com/articles/C++%20Primer%2017(%E4%B8%8A%EF%BC%89.html</id>
    <published>2019-12-03T07:30:31.000Z</published>
    <updated>2019-12-03T14:47:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>tuple类型和它的伴随类型都在tuple头文件中<br>初始化tuple</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;size_t,size_t,size_t&gt;threeD&#x3D;&#123;1,2,3&#125;;&#x2F;&#x2F;错误</span><br><span class="line">tuple&lt;size_t,size_t,size_t&gt;threeD&#123;1,2,3&#125;&#x2F;&#x2F;正确，也可值初始化</span><br></pre></td></tr></table></figure><a id="more"></a><p>访问tuple</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get&lt;i&gt;(t)&#x2F;&#x2F;返回引用，若t为左值，则左值引用，否则右值引用</span><br><span class="line">&#x2F;&#x2F;i必须是一个常量表达式</span><br></pre></td></tr></table></figure><p>tuple成员的数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tuple_size&lt;tupleType&gt;::value;&#x2F;&#x2F;返回size_t</span><br><span class="line">&#x2F;&#x2F;注意：tupleType不是tuple对象，而是类型</span><br><span class="line">typedef decltype(item) trans;</span><br><span class="line">size_t sz&#x3D;tuple_size&lt;trans&gt;::value;</span><br></pre></td></tr></table></figure><p>tuple成员的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple_element&lt;i,tupleType&gt;::type;</span><br></pre></td></tr></table></figure><p>只有两个tuple具有相同数量成员才可以进行比较<br>默认情况下，equal_range使用&lt;运算符来比较元素</p><h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><p>定义在头文件bitset中<br>初始化bitset</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;n&gt; b;</span><br><span class="line">bitset&lt;n&gt; b(u);&#x2F;&#x2F;这两个是constexpr的构造函数</span><br><span class="line">bitset&lt;n&gt; b(s,pos,m,zero,one);</span><br><span class="line">bitset&lt;n&gt; b(cp,pos,m,zero,one);</span><br></pre></td></tr></table></figure><p>当用一个整型值来初始化bitset时，它会被转换为unsigned long long类型并当作位模式处理<br>操作bitset</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b.any();b.all();b.none();b.count()</span><br><span class="line">b.size();&#x2F;&#x2F;constexpr函数</span><br><span class="line">b.text(pos);b.set(pos,v)b.set()</span><br><span class="line">b.reset(pos)b.reset()b.flip(pos)b.flip();</span><br><span class="line">b[pos]&#x2F;&#x2F;若b为const，返回bool值，否则可用来操作位</span><br><span class="line">b.to_ulong()b.to_ullong()b.to_string(zero,one)</span><br><span class="line">os&lt;&lt;bis&gt;&gt;b;</span><br></pre></td></tr></table></figure><h2 id="正则表达式（RE）"><a href="#正则表达式（RE）" class="headerlink" title="正则表达式（RE）"></a>正则表达式（RE）</h2><p>RE库定义在头文件regex中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string pattern(&quot;[^c]ei&quot;);&#x2F;&#x2F;任意非c后接ei</span><br><span class="line">pattern&#x3D;&quot;[[:alpha:]]*&quot;+pattern+&quot;[[:alpha:]]*&quot;</span><br><span class="line">&#x2F;&#x2F;0个或多个，若*换+，则表示1个或多个</span><br><span class="line">regex r(pattern);</span><br><span class="line">smatch results;</span><br><span class="line">string test_str&#x3D;&quot;receipt freind theif receive&quot;;</span><br><span class="line">if(regex_search(test_str,results,r))</span><br><span class="line">cout&lt;&lt;result.str()&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;输出freind</span><br></pre></td></tr></table></figure><p>regex_search 找到一个匹配子串就会停止查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">regex(re,f)</span><br><span class="line">r1.assign(re,f)</span><br><span class="line">r.mark_count()&#x2F;&#x2F;r中子表达式的数目</span><br><span class="line">r.flags() &#x2F;&#x2F;返回r的标志集</span><br></pre></td></tr></table></figure><p>三个标志特别记忆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">icase</span><br><span class="line">nosubs</span><br><span class="line">optimize&#x2F;&#x2F;执行速度优先于构造速度</span><br></pre></td></tr></table></figure><p>使用标志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">regex r(&quot;[[:alnum:]]+\\.(cpp|cxx|cc)$&quot;,regex::icase);</span><br><span class="line">&#x2F;&#x2F;反斜线和点在C++中都是特殊字符，需要先用一个反斜线去掉其特殊含义</span><br></pre></td></tr></table></figure><p>正则表达式是在运行时，当一个regex对象被初始化或赋予一个新模式才被“编译”的，即是说，一个正则表达式的语法是否正确是在运行时解析的（特别耗时）<br>若是编写的正则表达式存在错误，那么在运行时标准库会抛出regex_error的异常，它有what()和code()成员，来描述错误和某个错误类型对应的数值编码</p><p>容器参数的类型要与输入序列的类型一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string-&gt;regex,smatch,ssub_match,sregex_iterator</span><br><span class="line">const char*-&gt;regex,cmatch,csub_match,cregex_iterator</span><br></pre></td></tr></table></figure><p>使用sregex_iterator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(sregex_iterator it(file.begin(),file.end(),r),end_it;</span><br><span class="line">it!&#x3D;end_it;++it)</span><br><span class="line">cout&lt;&lt;it-&gt;str()&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>查找上下文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for....</span><br><span class="line">auto pos &#x3D; it-&gt;prefix().length();</span><br><span class="line">pos&#x3D;pos&gt;40?pos-40:0;</span><br><span class="line">cout&lt;&lt;it-&gt;prefix().str().substr(pos)</span><br><span class="line">&lt;&lt;&quot;\n\t\t&gt;&gt;&gt;&quot;&lt;&lt;it-&gt;str()&lt;&lt;&quot;&lt;&lt;&lt;\n&quot;</span><br><span class="line">&lt;&lt;it-&gt;suffix().str().substr(0,40)</span><br><span class="line">&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>smatch操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m.ready()m.size()m.empty()</span><br><span class="line">m.prefix()m.suffix()m.format(...)</span><br><span class="line">m.length(n)m.position(n)&#x2F;&#x2F;第n个子表达式序列距开始的距离</span><br><span class="line">m.str(n)m[n]</span><br><span class="line">&#x2F;&#x2F;m.str(0) 保存完整的匹配</span><br><span class="line">m.begin(),m.end()</span><br><span class="line">m.cbegin(),m.cend()</span><br></pre></td></tr></table></figure><p>？sub_match操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matchedfirstsecondlength()str()</span><br></pre></td></tr></table></figure><p>使用regex_replace</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string fmt&#x3D;&quot;$2.$5.$7&quot;&#x2F;&#x2F;表某个子表达式</span><br><span class="line">cout&lt;&lt;regex_replace(s,r,fmt)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>匹配和格式化标志的类型为match_flag_type，定义在regex_constants的命名空间，也在std中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using std::regex_constants::format_no_copy;</span><br></pre></td></tr></table></figure><p>使用格式标志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;regex_replace(s,r,fmt,format_no_copy)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tuple&quot;&gt;&lt;a href=&quot;#tuple&quot; class=&quot;headerlink&quot; title=&quot;tuple&quot;&gt;&lt;/a&gt;tuple&lt;/h2&gt;&lt;p&gt;tuple类型和它的伴随类型都在tuple头文件中&lt;br&gt;初始化tuple&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tuple&amp;lt;size_t,size_t,size_t&amp;gt;threeD&amp;#x3D;&amp;#123;1,2,3&amp;#125;;&amp;#x2F;&amp;#x2F;错误&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tuple&amp;lt;size_t,size_t,size_t&amp;gt;threeD&amp;#123;1,2,3&amp;#125;&amp;#x2F;&amp;#x2F;正确，也可值初始化&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C++ Primer" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-Primer/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="语言" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
